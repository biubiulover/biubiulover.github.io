<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,JavaSE,IO,Thread,数据结构," />





  <link rel="alternate" href="/atom.xml" title="BiuBiu" type="application/atom+xml" />






<meta name="description" content="Linux常用命令：​    pwd：用于显示当前工作目录。    ls：用于查看当前工作目录内容。    cd：用于改变当前工作目录。   相对路径：文件或目录相对于当前工作目录的位置。 ​        “.”表示当前目录，“..”表示上一级目录。 绝对路径：文件或目录相对于根目录的位置，绝对路径都从“/”开始。  先编译、后执行的原则通过javac命令将JAVA源程序(.java)先编译成字">
<meta name="keywords" content="Java,JavaSE,IO,Thread,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础知识点">
<meta property="og:url" content="http://gnbyj.cn/2018/07/16/Java/Java基础/index.html">
<meta property="og:site_name" content="BiuBiu">
<meta property="og:description" content="Linux常用命令：​    pwd：用于显示当前工作目录。    ls：用于查看当前工作目录内容。    cd：用于改变当前工作目录。   相对路径：文件或目录相对于当前工作目录的位置。 ​        “.”表示当前目录，“..”表示上一级目录。 绝对路径：文件或目录相对于根目录的位置，绝对路径都从“/”开始。  先编译、后执行的原则通过javac命令将JAVA源程序(.java)先编译成字">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-25T04:02:47.187Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 基础知识点">
<meta name="twitter:description" content="Linux常用命令：​    pwd：用于显示当前工作目录。    ls：用于查看当前工作目录内容。    cd：用于改变当前工作目录。   相对路径：文件或目录相对于当前工作目录的位置。 ​        “.”表示当前目录，“..”表示上一级目录。 绝对路径：文件或目录相对于根目录的位置，绝对路径都从“/”开始。  先编译、后执行的原则通过javac命令将JAVA源程序(.java)先编译成字">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gnbyj.cn/2018/07/16/Java/Java基础/"/>





  <title>Java 基础知识点 | BiuBiu</title>
  








  <style>
    .forkme{
      display: none;
    }
    @media (min-width: 768px) {
      .forkme{
        display: inline;
      }
    }
  </style>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    
    <div class="forkme">
      <a href="https://github.com/imacoderchina">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub">
      </a>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BiuBiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">GOOD IS GOOD, BUT BETTER CARRIES IT.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gnbyj.cn/2018/07/16/Java/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Gao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BiuBiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 基础知识点</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-16T18:00:00+08:00">
                2018-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="Linux常用命令："><a href="#Linux常用命令：" class="headerlink" title="Linux常用命令："></a><strong>Linux常用命令</strong>：</h4><p>​    pwd：用于显示当前工作目录。<br>    ls：用于查看当前工作目录内容。<br>    cd：用于改变当前工作目录。 </p>
<hr>
<p><strong>相对路径</strong>：文件或目录相对于当前工作目录的位置。</p>
<p>​        “.”表示当前目录，“..”表示上一级目录。</p>
<p><strong>绝对路径</strong>：文件或目录相对于根目录的位置，绝对路径都从“/”开始。</p>
<hr>
<h4 id="先编译、后执行的原则"><a href="#先编译、后执行的原则" class="headerlink" title="先编译、后执行的原则"></a>先编译、后执行的原则</h4><p>通过javac命令将JAVA源程序(.java)先编译成字节码文件(.class)，</p>
<p>​    编译错误即为javac过程出现的错误，主要是由于语法问题导致的</p>
<p>通过java命令启动JVM，由JVM来加载.class文件并运行.class文件。</p>
<hr>
<p><strong>JDK</strong>（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。</p>
<p><strong>JRE</strong>（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。</p>
<p><strong>JVM</strong>（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。</p>
<hr>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>内存中数据的代词，指代在内存中开辟的存储空间。</p>
<p>变量的声明：用特定语法声明一个变量，让运行环境为其分配空间。 </p>
<p>变量的命名：需要有个见名知意的名字，而且要符合Java语言规范：</p>
<ul>
<li>可以在一条语句中声明多个同类型变量，中间使用逗号分隔。</li>
<li>可以由字母、数字、“_”或“$”符组成，但是不能以数字开头。 </li>
<li>中文可以作为变量名，但不提倡使用。 </li>
<li>Java大小写敏感，即：严格区分大小写，在给命名变量时需要注意。 </li>
<li>不能使用Java保留字（一些Java语言规定好的，有特殊含义的字符），如：int、if、else、for、break等。 </li>
<li>“见名知意”，采用“驼峰命名法”。</li>
</ul>
<p>变量的初始化：变量声明后，要为其赋一个确定的初值后再使用。 </p>
<ul>
<li>变量在使用之前必须初始化，即必须给该变量赋予特定的值。</li>
<li>在声明变量时初始化；</li>
<li>在第一次使用变量前初始化；</li>
</ul>
<p>变量的访问：可以对变量中的数据进行存取、操作，但必须和其类型匹配。</p>
<hr>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>主要分为4大类 （整数类型、浮点类型、char、boolean）： </p>
<ul>
<li>整数类型又分为了4小类（byte、short、int（默认类型）、long）, </li>
<li>浮点类型也分了2小类（float、double（默认类型）），</li>
<li>char，</li>
<li>boolean</li>
</ul>
<p>double类型的精度值是float类型的两倍，因此而得名双精度。double运算时会出现舍入误差。</p>
<p>字符类型char一个16位无符号整数，对应字符的编码，Unicode是世界通用的定长字符集，所有的字符都是16位来表示。</p>
<p>对char型变量赋值：</p>
<ul>
<li>字符直接量</li>
<li>整型直接量</li>
<li>Unicode形式</li>
</ul>
<hr>
<p>自动类型转换（隐式类型转换）</p>
<ul>
<li>int直接量可以直接赋值给byte、char和short，只要不超过其表示范围。</li>
<li>byte、char、short三种类型参与运算时，先一律转换成int类型再进行运算。</li>
</ul>
<p>强制类型转换（显式类型转换）</p>
<hr>
<p>switch-case-break</p>
<p>在很多情况下,switch-case可以代替else if结构，而switch-case实现分支功能的效率要高于else if结构，并且结构更清晰，所以推荐使用。从JDK 7.0开始，switch-case可以支持字符串表达式，将更加方便程序的操作。</p>
<p>break用在循环体中用于退出循环结构</p>
<p>return结束方法</p>
<p>continue结束本次循环</p>
<p>固定次数的循环，这种情况，优先考虑使用for语句来实现。</p>
<p>“当”循环——while(){…}</p>
<p>“直到”循环——do{…}while()</p>
<p>固定次数循环——for(;;){…}</p>
<hr>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组为相同数据类型的元素组成的集合，</p>
<p>数组元素按线性顺序排列，</p>
<p>所谓线性顺序是指除第一个元素外，每一个元素都有唯一的前驱元素；除最后一个元素外，每一个元素都有唯一的后继元素（“一个跟一个”），</p>
<p>可以通过元素所在位置的顺序号（下标）做标识访问每一个元素（下标从0开始，最大到元素个数-1），</p>
<p>定义基本类型数组的要点包括：</p>
<ul>
<li>确切的数据类型：用于开辟空间大小 </li>
<li>整体的数组名字：用于对数据的引用 </li>
<li>不能缺少的“[]”</li>
</ul>
<p>基本类型的数组创建后，默认为其数组元素设置了初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 初始化后有默认值0</span></span><br></pre></td></tr></table></figure>
<p>手动设置初始值，可以在数组声明的同时进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">10</span>,<span class="number">23</span>,<span class="number">30</span>,-<span class="number">10</span>,<span class="number">21</span> &#125;; <span class="comment">// 只能用于声明时的初始化，不能用于先声明后赋值的情况</span></span><br></pre></td></tr></table></figure>
<p>对于已声明的数组，数组类型变量进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">10</span>,<span class="number">23</span>,<span class="number">30</span>,-<span class="number">10</span>,<span class="number">21</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>数组有length属性</p>
<p>通过下标访问数组元素</p>
<p>for循环遍历数组元素</p>
<h4 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">10</span> ,<span class="number">20</span> ,<span class="number">30</span> ,<span class="number">40</span> ,<span class="number">50</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>] ;</span><br><span class="line">System.arraycopy( a , <span class="number">1</span> , a1 , <span class="number">0</span> , <span class="number">4</span> ); </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * src：源数组 </span></span><br><span class="line"><span class="comment"> * srcPos：源数组中的起始位置 </span></span><br><span class="line"><span class="comment"> * dest：目标数组 </span></span><br><span class="line"><span class="comment"> * destPos : 目标数组中的起始位置 </span></span><br><span class="line"><span class="comment"> * length：要复制的数组元素的数量 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Arrays.copyOf()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] a1 = Arrays.copyOf(a, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>生成的新数组是原始数组的副本； </p>
<p>newLength小于源数组，则进行截取；（自己通过代码演示效果）； </p>
<p>newLength大于源数组，则用0或 null进行填充； </p>
<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>所谓的扩容实际上是指创建一个更大的新数组并将原有数组的内容复制到其中。</p>
<h4 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h4><p>一般情况下，通过排序过程中数组元素的交换次数来衡量排序算法的优劣。</p>
<p>常用排序算法有：插入排序、冒泡排序、快速排序等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">89</span>,<span class="number">50</span>,<span class="number">84</span>,<span class="number">57</span>,<span class="number">61</span>,<span class="number">20</span>,<span class="number">86</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                   &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arrays.sort方法用于数组排序</p>
<p>int[] arr = new int[3]</p>
<p>在堆内存中分配了数组对象，分配三个int型空间，并将每个元素赋初始值为0，栈中存储对堆中数据的引用，即堆中int数组的首地址。</p>
<p>引用类型数组，即数组元素的类型不是基本类型，而是引用类型。初始值为null。</p>
<hr>
<p>方法用于封装一个特定的功能，</p>
<p>定义时需要考虑五个要素：</p>
<p>修饰词、public/protected/private static final</p>
<p>返回值类型、void/…</p>
<p>方法名、xxx</p>
<p>参数列表、(args)</p>
<p>方法体 {…}</p>
<hr>
<h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>以对象为中心来构建软件系统</p>
<p>面向对象的第一步就是抽象数据类型——将不同类型的数据的集合组成一个整体用来描述一种新的事物。</p>
<p>类定义了一种抽象数据类型，包括抽象数据类型的组成（成员变量/属性）和该类型可以干的事（方法）。</p>
<p>类是一种引用数据类型。类为对象的模板。</p>
<p>类的定义包括“成员变量”的定义和“方法”的定义，</p>
<p>“成员变量”用于描述一类对象共同的数据结构;</p>
<p>定义方法，用于描述对象的形为，封装对象的功能。</p>
<p>实例化——使用new关键字来创建对象</p>
<p>引用——对实例化的对象进行访问控制，特殊的变量</p>
<p>引用类型变量可以存储该类对象的地址信息，通常称为“指向该类的对象”，</p>
<p>当一个引用类型变量指向该类的对象，就可以通过这个变量对对象实施访问。 </p>
<p>除8种基本类型之外，用类、接口、数组等声明的变量都称为引用类型变量，简称“引用”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point  p       =  <span class="keyword">new</span> Point();</span><br><span class="line">类       引用       对象</span><br></pre></td></tr></table></figure>
<p>引用类型变量之间的赋值不会创建新的对象，但有可能会使两个以上的引用指向同一个对象。</p>
<p>当一个引用的值为null的时候，通过引用访问对象成员变量或者调用方法会产生NullPointerException（空指针异常）。</p>
<hr>
<p>方法的签名：方法名和参数列表。</p>
<p>一个类中不可以有两个方法签名完全相同的方法！</p>
<p>在Java语言中，允许多个方法的名称相同，但参数列表不同，此种方式称为方法的重载(overload)。</p>
<p>编译时根据签名绑定调用方法，编译器会在编译时根据签名的不同来绑定调用不同的方法，编译期多态！</p>
<hr>
<p>构造方法</p>
<p>构造方法的名称必须与类名相同。 </p>
<p>构造方法没有返回值，但也不能写void。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【访问修饰符】类名()&#123;</span><br><span class="line">         // 构造方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言中的构造方法常常<strong>用于实现对对象成员变量的初始化！</strong></p>
<p>在创建对象时，构造方法写在new关键字之后，可以理解为：</p>
<p>“new”创建了对象，而构造方法对该对象进行了初始化。</p>
<p>this关键字用在方法体中，用于指代<u>调用该方法</u>的当前对象。在没有歧义的情况下可以省略this。</p>
<p>在构造方法中，用来初始化成员变量的参数一般和成员变量取相同的名字，这样会有利于代码的可读性，但此处就必须通过this关键字来区分成员变量和参数。</p>
<p>JAVA语法规定，任何一个类都必须含有构造方法，假如源程序中没有定义，则编译器在编译时将为其添加一个无参的空构造方法（此方法称之为“默认的构造方法”）。</p>
<p>构造方法的重载</p>
<p>在构造方法中可以通过this关键字来调用另外的一个重载的构造方法。</p>
<hr>
<p>java程序所需内存均由JVM进行管理分配，开发者只需关心JVM是如何管理内存的</p>
<p>JVM会将申请的内存从逻辑上划分为三个区域：堆、栈、方法区。</p>
<p>对象存储在堆中——存储使用new关键字所创建的对象。</p>
<p>引用类型变量在栈内存中——方法中的变量即为局部变量，是在栈内存中分配，若变量为值类型，则在栈中存储的就是该变量的值。若变量为引用类型，则在栈中存储的是堆中对象的地址。</p>
<p>方法区用于存放类的信息——Java程序运行时，首先会通过类装载器载入类文件的字节码信息，经过解析后将其装入方法区。</p>
<p>类在实例化对象时，多个对象会拥有各自在堆中的空间，但所有实例对象是共用在方法区中的一份方法定义的。意味着，方法只有一份。</p>
<p>static成员变量和类的信息一起存储在方法区。</p>
<hr>
<p><strong>成员变量的生命周期</strong></p>
<p>从对象在堆中创建开始到对象从堆中被回收结束。</p>
<p>当一个对象没有任何引用时，该对象被视为废弃的对象，属于被回收的范围，同时该对象中的所有成员变量也随之被回收。</p>
<p><strong>局部变量的生命周期</strong></p>
<p>一个运行的Java程序从开始到结束会有多次方法的调用。</p>
<p>JVM会为每一个方法的调用在栈中分配一个对应的空间，这个空间称为该方法的栈帧。</p>
<p>一个栈帧对应一个正在调用中的方法，栈帧中存储了该方法的参数、局部变量等数据。</p>
<p>当某一个方法调用完成后，其对应的栈帧将被清除，局部变量即失效。</p>
<p><strong>成员变量：</strong></p>
<p>1)定义在类中，方法外；</p>
<p>2)由系统设定默认初始值，可以不显式初始化；</p>
<p>3)所在类被实例化后，存在堆中，对象被回收时，成员变量失效；</p>
<p><strong>局部变量：</strong></p>
<p>1)定义在方法中；</p>
<p>2)没有默认值，必须自行设定初始值；</p>
<p>3)方法被调用时，存在栈中，方法调用结束时局部变量从栈中清除；</p>
<hr>
<p>垃圾回收器（Garbage Collection，GC）是JVM自带的一个线程（自动运行着的程序），用于回收没有任何引用所指向的对象。</p>
<p>内存泄露是指，不再被使用的内存没有被及时的回收。</p>
<p>当确定该对象不再使用时，应该及时的将其引用设置为null，该对象即不再被引用，属于可回收的范围。</p>
<p>当我们需要GC线程即刻回收无用对象时，可以调用System.gc()方法。此方法用于建议JVM马上调度GC线程回收资源。</p>
<hr>
<h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><p>将公共的信息存放在父类中，子类继承父类，子类即可以共享父类的数据。这个过程就是泛化的过程。</p>
<p>Java语言不支持多重继承，即：一个类只能继承一个父类，但一个父类可以有多个子类。</p>
<p>在java语言中，需要通过<strong>extends</strong>关键字实现类的继承。</p>
<p>使用继承可以实现代码的复用。</p>
<hr>
<p>java规定，子类在构造之前必须先构造父类。</p>
<p>子类的构造方法中是必须要通过super关键字来调用父类的构造方法的。</p>
<p>super();为编译器自动加入的，并且super关键字必须位于子类构造方法的第一行，否则会有编译错误。</p>
<p>若父类没有提供无参的构造方法，则会出现编译错误。</p>
<p>方案一：在父类中添加无参的构造方法，</p>
<p>方案二：在子类构造方法中显式调用父类的有参构造方法（常常使用）。</p>
<hr>
<p>一个子类的对象可以向上造型为父类的类型。即，</p>
<p>定义父类型Foo的引用obj可以指向子类的对象new Goo()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;...&#125;</span><br><span class="line">class Goo extends Foo &#123;...&#125;</span><br><span class="line">Foo obj = new Goo(100,3);</span><br></pre></td></tr></table></figure>
<p><strong>通过父类的引用只能访问父类所定义的<u>成员</u>，而不能访问子类所扩展的部分。</strong></p>
<p>在java语言中，子类可以重写（覆盖）继承自父类的方法，即方法名和参数列表与父类的方法相同，但是方法的实现不同。</p>
<p>当子类重写了父类的方法后，该重写方法被调用时（无论是通过子类的引用调用还是通过父类的引用调用），<strong>运行的都是子类重写后的版本</strong>。</p>
<hr>
<p>o 重载： 是指在一个类中定义多个方法名相同但参数列表不同的方法，在编译时，根据参数的个数和类型来决定绑定哪个方法。 </p>
<p>o 重写： 是指在子类中定义和父类完全相同的方法，在程序运行时，根据对象的类型（而不是引用类型）而调用不同的方法。</p>
<p>重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。</p>
<p>重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法。</p>
<hr>
<p>在Java语言中，命名冲突问题是用包（package）的概念来解决的。</p>
<p>类的全称应该是“包名.类名”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.lang.StringUtil</span><br><span class="line"><span class="comment">// org.apache表示公司或组织的信息（是这个公司或组织域名的反写）；</span></span><br><span class="line"><span class="comment">// commons表示项目的名称信息；</span></span><br><span class="line"><span class="comment">// lang表示模块的名称信息。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h4><p>降低代码出错的可能性，更便于维护。 </p>
<p>当内部实现细节改变时，只要保证对外的功能定义不变，其他的模块不需要更改。</p>
<p>在软件系统中，封装常常需要依靠一些访问控制修饰符来实现。</p>
<p>访问控制符修饰类：</p>
<ul>
<li>对于类的修饰可以使用public和默认方式。其中，public修饰的类可以被任何一个类使用，而默认访问控制的类只可以被同一个包中的类使用。</li>
<li>而protected和private访问修饰符是不可以修饰类的，但其可以修饰内部类。</li>
</ul>
<p>访问控制符修饰成员：</p>
<ul>
<li>public 修饰符，在任何地方都可以访问；</li>
<li>protected可以在本类、同一包中的类、子类中访问，除此之外的其它类不可以访问；</li>
<li>默认方式为可以本类及同一包中的类访问，除此之外其它类不可以访问；</li>
<li>private只可以在本类中访问，其它任何类都不可以。</li>
</ul>
<hr>
<p>static修饰成员变量，属于类的变量，通常通过类名来引用static成员。</p>
<p>static成员变量和类的信息一起存储在方法区, 而不是在堆中。</p>
<p>一个类的static成员变量只有“一份”（存储在方法区），无论该类创建了多少对象。</p>
<p>static修饰方法，在static方法中是不可以使用this关键字的。</p>
<p>static方法的作用在于提供一些“工具方法”和“工厂方法”。</p>
<p>由于static在调用时没有具体的对象，因此在static方法中不能对非static成员（对象成员）进行访问。</p>
<p>static块为属于类的代码块，在类加载期间执行的代码块，只执行一次，可以用来在软件中加载静态资源（图像、音频等等）。</p>
<p>在类加载时，先运行了静态块，而后执行了构造方法，即，static块是在创建对象之前执行的。</p>
<hr>
<p>final修饰变量，意为不可改变。</p>
<p>final修饰成员变量时，有两种初始化方式：</p>
<ul>
<li>声明同时初始化；</li>
<li>构造函数中初始化；</li>
</ul>
<p>final关键字修饰局部变量，在使用之前初始化即可。</p>
<p>final关键字修饰的方法不可以被重写。防止子类在定义新方法时造成的“不经意”重写。</p>
<p>final关键字修饰的类不可以被继承。使一个类不能被继承的意义在于：可以保护类不被继承修改，可以控制滥用继承对系统造成的危害。</p>
<p>static final 修饰的成员变量称为常量，必须声明同时初始化，并且不可被改变。常量建议所有字母大写。常量在编译期被替换的。节约开支。</p>
<hr>
<p>由abstract修饰的方法为抽象方法，抽象方法即只有方法的定义，没有方法体实现，用一个分号结尾。不完整的方法。</p>
<p>若将抽象方法包含在类中，则该类也应该为抽象的，该类也不完整。</p>
<p>抽象类由abstract关键字声明。</p>
<p><strong>抽象类是不能实例化对象的</strong>，需要定义类来继承抽象类，重写其抽象方法。</p>
<p>即使一个类中没有抽象方法，也可以将其定义为抽象类，该类也不可以实例化。</p>
<p><u>abstract和final关键字不可以同时用于修饰一个类，因为final关键字使得类不可继承，而abstract修饰的类如果不可以继承将没有任何意义。两者放在一起，会起冲突。</u></p>
<p>抽象类的意义：</p>
<ul>
<li>为其子类提供一个公共的类型（父类引用指向子类对象）； </li>
<li>封装子类中的重复内容（成员变量和方法）; </li>
<li>定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的。(子类需要实现此抽象方法)。</li>
</ul>
<hr>
<p>接口可以看成是特殊的抽象类。</p>
<p>即只包含抽象方法和常量的抽象类。</p>
<p>可以通过interface关键字来定义接口。</p>
<p>一个类可以实现多个接口，实现的接口直接用逗号分隔。</p>
<p>该类需要实现这些接口中定义的所有方法；</p>
<p>接口可以作为一种类型声明变量，一个接口类型的变量可以引用实现了该接口的类的对象；通过该变量可以调用该接口中定义的方法。</p>
<p>class AmericanCurl implements Runner , … {}</p>
<p>Runner runner = new AmericanCurl(); </p>
<p>一个接口类型变量，引用了子类的对象。调用时，调用的是子类对象的具体的实现。</p>
<p>接口间可以存在继承关系，一个接口可以通过extends关键字继承另外一个接口。</p>
<p>子接口继承了父接口中定义的所有方法。</p>
<p>一个类只能继承一个抽象类，但可以实现多个接口。 </p>
<p>抽象类中可以包含抽象方法和非抽象方法，而接口中的所有方法均为抽象的。 </p>
<p>子类继承抽象类必须实现抽象类中所有抽象方法，否则子类也必须是抽象类。而子类实现接口则必须实现接口中的所有抽象方法。 </p>
<hr>
<p>多态即多种形态</p>
<p>同样类型，当指向不同的对象时，可以有不同的表现。</p>
<p>同样一个对象，造型成不同的类型时，会有不同的功能。</p>
<p>向上造型：父类的引用指向子类的对象</p>
<p>一个类的对象可以向上造型的类型有：父类的类型及其实现的接口类型。</p>
<p>强制转换将父类型变量转换为子类型变量，前提是该变量指向的对象确实是该子类类型。</p>
<p>也可通过强制转换将变量转换为某种接口类型，前提是该变量指向的对象确实实现了该接口。</p>
<p>在强制转型中，为了避免出现ClassCastException，可以通过instanceof关键字判断某个引用指向的对象是否为指定类型。先通过instanceof关键字判断，而后再转型。这样则可以避免发生ClassCastException，因为只要instanceof为true，则强制转换一定成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> Object</span><br></pre></td></tr></table></figure>
<p>一个类可以定义在另外一个类的内部，定义在类内部的类称之为Inner，其所在的类称之为Outer；Inter定义在Outer的内部，通常只服务于Outer，对外不具备可见性，Inter可以直接调用Outer的成员及方法（包括私有的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeInc</span><span class="params">()</span></span>&#123;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类可以不必命名，称之为匿名内部类。</p>
<hr>
<p>常用的文档注释规范</p>
<p>@author</p>
<p>@deprecated</p>
<p>@since</p>
<p>@param</p>
<p>@return</p>
<hr>
<p>String对象为不可变对象，这样做的目的是可以最大程度的重用相同内容的字符串以减小系统资源的开销。</p>
<p>字符串常量池(一个JVM内部维护的内存区域，用来保存已经创建过的字符串对象)</p>
<p>当我们通过字面量，常量来初始化一个字符串时，JVM首先会从常量池中查询用来保存该字符串的对象是否存在，若存在则直接引用，若不存在则创建该字符串对象并存入常量池，然后引用它。</p>
<hr>
<p>java存储每一个字符均使用2个字节保存；</p>
<p>任何一个字符(无论是英文还是汉字)每个字符的长度都是1；</p>
<p>字符串的长度就是该字符串所有的字符个数。</p>
<p>返int</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.length())； //返回当前字符串的长度。这是一个方法。</span><br><span class="line">str.indexOf(&apos;W&apos;)); //第一次出现的下标位置，无则返-1。</span><br></pre></td></tr></table></figure>
<p>返String</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.substring(0,5);  //从哪里开始，截取到哪里。含头不含尾的。</span><br><span class="line">str.trim(); //将字符串两边的空白去除</span><br><span class="line">str.toLowerCase(); //变小写</span><br><span class="line">str.toUpperCase(); //变大写</span><br><span class="line">String valueOf(); //将其他基本类型的值以字符串的形式描述</span><br></pre></td></tr></table></figure>
<p>返char</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(5); //获取这个位置的字符</span><br></pre></td></tr></table></figure>
<p>返boolean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startsWith(String suffix) //是否是以给定的字符串开始</span><br><span class="line">str.endsWith(&quot;.jpg&quot;) //是否是以给定的字符串结束</span><br></pre></td></tr></table></figure>
<p>StringBuilder是可变字符串。</p>
<p>专门用于修改字符串内容的类:StringBuilder/StringBuffer</p>
<p>封装了可变的字符串</p>
<p>StringBuilder类的常用方法有：</p>
<p>append(String str)：追加字符串； </p>
<p>insert (int dstOffset，String s)：将给定的字符串插入到指定的位置； </p>
<p>delete(int start，int end)：删除字符串，含头不含尾； </p>
<p>replace(int start，int end，String str): 替换字符串； </p>
<p>reverse()：字符串反转。</p>
<p>将StringBuilder转换为String：sb.toString();</p>
<p>StringBuffer 和StringBuilder的区别：</p>
<p>StringBuffer是线程安全的，同步处理的，性能稍慢； </p>
<p>StringBuilder是非线程安全的，并发处理的，性能稍快。 </p>
<hr>
<p>正则表达式</p>
<blockquote>
<p>“.”点儿，在正则表达式中表示任意一个字符。</p>
<p>“\”在正则表达式中是转意字符，当我们需要描述一个已经被正则表达式使用的特殊字符时，我们就可以通过使用”\”将其转变为原本的意思。</p>
<p>\d：表示任意一个数字 </p>
<p>\w：表示任意一个单词字符（只能是 数字，字母，下划线） </p>
<p>\s：表示任意一个空白字符(\t \r \n \f \x0B) </p>
<p>\D：表示任意一个非数字字符 </p>
<p>\W：表示任意一个非单词字符 </p>
<p>\S：表示任意一个非空白字符 </p>
<p>“[]”用来描述单一字符</p>
<p>[abc]: 表示该字符只能是a或者b或者c；</p>
<p>[123]: 表示该字符只能是1或者2或者3；</p>
<p>[a-z]，表示该字符可以是任意一个小写字母；</p>
<p>[0-9] 来表示该字符可以是任意一个数字；</p>
<p>[a-zA-Z0-9_] 表示该字符可以是任意字母，数字以及”下划线”。</p>
<p>“+”：表示内容可以连续出现至少1次以上 </p>
<p>“*”：表示内容出现0-若干次 </p>
<p>“?”：表示内容出现0-1次 </p>
<p>{n}：表示内容必须出现n次 </p>
<p>{n,m}：表示内容出现n-m次 </p>
<p>{n,}：表示内容出现至少n次 </p>
<p>分组”()”</p>
<p>() 可以将内容看做一个整体，()中可以使用”|”来表示或关系。</p>
<p>例如，(+86|0086) 表示这里可以是+86或者0086。</p>
<p>开始添加”^”以及末尾添加”$”来表示一个整体</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str.matches(regEx)</span><br><span class="line"></span><br><span class="line">String[] split(String regex)</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex,String replacement)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String emailRegEx </span>= <span class="string">"^[a-zA-Z0-9_.-]+@([a-zA-Z0-9-]+\\.)+[a-zA-Z0-9]&#123;2,4&#125;$"</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>Object类是java中所有类的顶级父类。</p>
<p>String toString():该方法java希望我们重写时返回一个字符串，这个字符串的原则为:用一个字符串来描述当前对象。</p>
<p>Object实现了toString()方法，返回的是当前对象的“句柄”。</p>
<p>格式为:类的完全限定名@hashcode。</p>
<hr>
<h4 id="如何重写equals方法？"><a href="#如何重写equals方法？" class="headerlink" title="如何重写equals方法？"></a>如何重写equals方法？</h4><p>重写equals方法应遵循几个规则:</p>
<p>任何对象与null比较都应返回false </p>
<p>两个对象不属于同一个类时应返回false </p>
<p>同一个对象equals比较应当恒等为true</p>
<h4 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与 == 的区别"></a>equals与 == 的区别</h4><p>“==”是值比较，对于引用类型变量而言，该变量保存的是对象的地址，所以使用”==”比较时，意思为两个变量的地址是否相等，换句话说就是看两个变量引用的是否为同一个对象</p>
<p>equals是内容比较，对于两个引用变量而言，是比较两个变量所引用的对象内容是否相同。</p>
<p>“==”是判断是否为同一个，而”equals”是判断像不像。</p>
<hr>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>java.lang.Byte</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
</tr>
</tbody>
</table>
<p>除了Character与Boolean的父类是Object之外，其余的都是继承自:java.lang.Number</p>
<p>Number是一个抽象类。本身不能实例化。Number 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法</p>
<p>Integer有一个静态方法static int parseInt(String s)。</p>
<p>该方法的作用是将一个描述整数的字符串解析为该整数，并用int形式返回。该方法可能会抛出NumberFormatException异常:当给定的字符串里边含有非整数字符时。</p>
<p>Double有一个静态方法static double parseDouble(String s)。</p>
<p>该方法的作用是将一个描述小数的字符串解析为该小数，并用double形式返回。该方法可能会抛出NumberFormatException异常: 如果字符串不包含可解析的 double 值。</p>
<hr>
<p>装箱：</p>
<p>静态方法valueOf()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">Double d = Double.valueOf(<span class="number">1.1</span>);</span><br></pre></td></tr></table></figure>
<p>拆箱：</p>
<p>包装类的方法xxxValue()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> n = i.intValue();</span><br><span class="line">Double d = <span class="keyword">new</span> Double(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">double</span> dn = d.doubleValue();</span><br></pre></td></tr></table></figure>
<p>自动拆装箱</p>
<p>JVM不支持该特性，自动拆装箱只是编译器在编译过程中的”预处理”操作。编译器在看到需要在包装类与基本类型之间转换时，会在编译为字节码时进行改变。</p>
<hr>
<p>java.util.Date 类封装日期及时间信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();             <span class="comment">// 系统当前的日期及时间信息   </span></span><br><span class="line">System.out.println(date);           <span class="comment">// Sun Jan 06 11:52:55 CST 2013   </span></span><br><span class="line"><span class="keyword">long</span> time = date.getTime();       <span class="comment">//1970年1月1日至今的毫秒数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span> <span class="comment">//毫秒差</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> <span class="comment">//毫秒差</span></span></span><br></pre></td></tr></table></figure>
<p>SimpleDateFormat就是根据一个特定的日期格式在字符串与Date之间相互转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Date格式化为String</span></span><br><span class="line">Date now = <span class="keyword">new</span> Date();<span class="comment">//默认实例化的Date表示当前系统时间</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String str = sdf.format(now);</span><br><span class="line">System.out.println(str);<span class="comment">//2014-01-06 13:21:12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将String解析为Date</span></span><br><span class="line">String str = <span class="string">"2008年08月08日 12:22:46"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">Date date = sdf.parse(str);</span><br><span class="line">System.out.println(date);<span class="comment">// Fri Aug 08 12:22:46 CST 2008</span></span><br></pre></td></tr></table></figure>
<p>java.util.Calendar 类用于封装日历信息，其主要作用在于其方法可以对时间分量进行运算。</p>
<p>Calendar是抽象类，其提供了一个工厂方法:Calendar getInstance()。</p>
<p>该方法可以根据当前系统所在地区获取一个适当的Calendar的子类实现。在实际开发中，也推荐使用该方法来实例化Calendar的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置日期及时间分量</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();<span class="comment">//创建出的Calendar表示当前系统时间</span></span><br><span class="line"><span class="comment">//设置年为2008年</span></span><br><span class="line">calendar.set(Calendar.YEAR,<span class="number">2008</span>);</span><br><span class="line"><span class="comment">//设置月为5月</span></span><br><span class="line">calendar.set(Calendar.Month,<span class="number">4</span>);<span class="comment">//月份从0开始</span></span><br><span class="line">calendar.set(Calendar.Month,Calendar.MAY);<span class="comment">//也可以使用常量来设置</span></span><br><span class="line"><span class="comment">//设置日为30日</span></span><br><span class="line">caneldar.set(Calendar.DAY_OF_MONTH,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//获取时间分量对应的值</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> year = calendar.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = calednar.get(Calendar.Month);</span><br><span class="line"><span class="keyword">int</span> date = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"><span class="comment">//需要注意，月份要加1，因为月份是从0开始的</span></span><br><span class="line">System.out.println(year+<span class="string">"-"</span>+(month+<span class="number">1</span>)+<span class="string">"-"</span>+date);<span class="comment">//2014-1-4</span></span><br></pre></td></tr></table></figure>
<p>获取给定时间分量所允许的最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> max = calendar. getActualMaximum(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(<span class="string">"当前月的最后一天为:"</span>+max+<span class="string">"日"</span>);<span class="comment">//当前月的最后一天为31日</span></span><br></pre></td></tr></table></figure>
<p>对某个时间分量的值进行计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();<span class="comment">//计算明天(在日的基础上加一天)</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_YEAR,<span class="number">1</span>);<span class="comment">//当前Calendar表示的为2014-02-01，月进位了</span></span><br></pre></td></tr></table></figure>
<p>Calendar的void setTime(Date date),允许我们为Calendar设置Date对象所表示的时间。</p>
<p>Calendar的 Date getTime(),允许我们获取一个使用Date对象描述的Calendar所表示的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure>
<hr>
<p>集合框架</p>
<p>Collection是一个接口，其定义了集合的相关功能方法。</p>
<p>Collection派生出了两个子接口，一个是List另一个则是Set。</p>
<p>List:称为可重复集，该集合中是允许存放重复元素的；</p>
<p>Set:称为不可重复集，该集合中是不能将相同的元素存入集合两次。</p>
<p>集合只存储了元素对象在堆中的地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>boolean contains(Object o)</p>
<p>该方法会用于判断给定的元素是否被包含在集合中。</p>
<p>List集合contains方法和对象的equals方法相关</p>
<p>size方法用于获取当前集合中的元素总数。该方法定义为:int size()</p>
<p>clear方法用于清空集合。该方法定义为:void clear()</p>
<p>isEmpty方法用于判断当前集合中是否不 包含元素。该方法定义为:boolean isEmpty()</p>
<p>addAll方法用于将给定集合中的所有元素添加到当前集合中</p>
<p>boolean addAll(Collection c)</p>
<p>containsAll方法用于判断当前集合是否包含给定集合中的所有元素，若包含则返回true。boolean containsAll(Collection c)</p>
<hr>
<p>Iterator 迭代器</p>
<p>遍历集合应遵循“先问后取”的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">c.add(<span class="string">"java"</span>);</span><br><span class="line">c.add(<span class="string">"cpp"</span>);</span><br><span class="line">c.add(<span class="string">"php"</span>);</span><br><span class="line">c.add(<span class="string">"c#"</span>);</span><br><span class="line">c.add(<span class="string">"objective-c"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123; <span class="comment">//判断集合是否还有元素可以遍历</span></span><br><span class="line">    String str = it.next(); <span class="comment">//返回迭代的下一个元素</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器还提供了一个方法:void remove()。在使用迭代器遍历集合时是不能通过集合自身提供的remove方法删除元素的，否则迭代器在迭代时会抛出异常。</p>
<hr>
<p>增强for循环,也称为新循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 e : 集合或数组)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>泛型的本质是参数化类型</p>
<p>所操作的数据类型被传入的参数指定。</p>
<p>Java编译器可以据此进行类型检查，这样可以减少代码在运行时出现错误的可能性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//泛型E在这里被指定为String类型</span></span><br></pre></td></tr></table></figure>
<hr>
<p>线性表</p>
<p>将List理解为存放对象的数组，元素个数可以动态的增加或减少，并且List是可重复集。</p>
<p>List接口的两个常见实现类为ArrayList和LinkedList，分别用动态数组和链表的方式实现了List接口。</p>
<p>ArrayList更适合于随机访问而LinkedList更适合于插入和删除。</p>
<p>E get(int index):获取集合中指定下标对应的元素，下标从0开始。 </p>
<p>E set(int index, E elment):将给定的元素存入给定位置，并将原位置的元素返回。</p>
<p>void add(int index,E element):将给定的元素插入到指定位置，原位置及后续元素都顺序向后移动。</p>
<p>E remove(int index):删除给定位置的元素，并将被删除的元素返回。</p>
<p>List<e> subList(int fromIndex, int toIndex):subList获取的子List与原List占有相同的存储空间，对子List的操作会影响的原List。下标含头不含尾。</e></p>
<h4 id="List与数组互转"><a href="#List与数组互转" class="headerlink" title="List与数组互转"></a>List与数组互转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = list.toArray(<span class="keyword">new</span> String[] &#123;&#125;); </span><br><span class="line"></span><br><span class="line">String[] strArr = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;; </span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArr);</span><br></pre></td></tr></table></figure>
<p>返回的集合我们不能对其增删元素，否则会抛出异常。</p>
<p>解决方法：新建一个list1，将数组转化的list中元素添加list1中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list1.addAll(Arrays.asList(strArr));</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="List排序"><a href="#List排序" class="headerlink" title="List排序"></a>List排序</h4><p>Collections.sort(list); //自然排序(按照元素的由小至大的顺序)</p>
<hr>
<p>Comparable是一个接口，用于定义其子类是可以比较的。因为该接口有一个抽象方法:int compareTo(T t)</p>
<p>所有子类都需要重写该方法来定义对象间的比较规则。</p>
<p>该方法要求返回一个整数，这个整数不关心具体的值，而是关注取值范围。</p>
<p>当返回值&gt;0时，表示当前对象比参数给定的对象大。 </p>
<p>当返回值&lt;0时，表示当前对象比参数给定的对象小。 </p>
<p>当返回值=0时，表示当前对象和参数给定的对象相等。 </p>
<p>一旦Java类实现了Comparable，其比较逻辑就已经确定；如果希望在排序的操作中临时指定比较规则，可以采用Comparator接口回调的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照col值的大小排序</span></span><br><span class="line">Collections.sort(cells, <span class="keyword">new</span> Comparator&lt;Cell&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cell o1, Cell o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.col - o2.col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>队列（Queue）：只能从线性表的一端添加（offer）元素，从另一端取出（poll）元素。队列遵循先进先出（FIFO First Input First Output ）的原则。</p>
<p>LinkedList实现Queue接口：Queue经常要进行插入和删除的操作，而LinkedList在这方面效率较高。</p>
<p>boolean offer(E e):将元素追加到队列末尾,若添加成功则返回true。 </p>
<p>E poll():从队首删除并返回该元素。 </p>
<p>E peek():返回队首元素，但是不删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue.offer(<span class="string">"a"</span>);</span><br><span class="line">queue.peek();</span><br><span class="line">queue.poll();</span><br><span class="line">queue.size();</span><br></pre></td></tr></table></figure>
<p>双端队列Deque，从队列的两端分别可以入队（offer）和出队（poll），LinkedList实现了该接口。</p>
<p>void push(E e):将给定元素”压入”栈中。存入的元素会在栈首。即:栈的第一个元素 </p>
<p>E pop():将栈首元素删除并返回。</p>
<p>E peek():返回队首元素，但是不删除。 </p>
<p>栈——将Deque限制为只能从一端入队和出队，入栈称之为push，出栈称之为pop。栈遵循先进后出（FILO First Input Last Output）的原则。</p>
<hr>
<p>查询表Map</p>
<p>以键值对(key-value)的形式存储数据的数据结构。</p>
<p>Map对存入的元素有一个要求，就是key不能重复，不能包含两个equals为true的key。</p>
<p>Map对于key,value的类型没有严格要求，只要是引用类型均可。使用泛型去约束key与value的类型。</p>
<p>V put(K k,V v)</p>
<p>若当次存入的key已经在Map中存在，则是替换value操作，而返回值则为被替换的元素。若此key不存在，那么返回值为null。</p>
<p>V get(Object key)</p>
<p>boolean containsKey(Object key)</p>
<p>HashMap是Map的一个常用的子类实现。其实使用散列算法实现的。</p>
<p>key–hashcode()–返回值 散列算法–数字即散列数组下标–存入对应位置链表节点</p>
<p>HashMap会将每组键值对封装为一个Entry的实例，然后将该实例存入链表。</p>
<blockquote>
<p>重写一个类的hashcode()方法有以下注意事项:</p>
<p>1、若一个类重写了equals()方法，那么就应当重写hashcode()方法。</p>
<p>2、若两个对象的equals()方法比较为true,那么它们应当具有相同的hashcode值。</p>
<p>3、对于同一个对象而言，在内容没有发生改变的情况下，多次调用hashCode()方法应当总是返回相同的值。</p>
<p>4、对于两个对象equals比较为false的，并不要求其hashcode值一定不同，但是应尽量保证不同，这样可以提高散列表性能。</p>
</blockquote>
<p>LinkedHashMap实现有序的Map</p>
<p>LinkedHashMap维护着一个双向循环链表。此链表定义了迭代顺序，该迭代顺序通常就是存放元素的顺序。</p>
<hr>
<h4 id="文件操作——File"><a href="#文件操作——File" class="headerlink" title="文件操作——File"></a>文件操作——File</h4><p>通过java.io.File类在程序中操作硬盘上的文件和目录，只能访问文件或目录的相关属性，不能对文件的内容进行访问。</p>
<p>File(String pathname)</p>
<p>提示:抽象路径应尽量使用相对路径，并且目录的层级分隔符不要直接写”/”或”\”,应使用File.separator这个常量表示，以避免不同系统带来的差异。</p>
<p>File(File parent,String child)</p>
<p>根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</p>
<p>boolean isFile()</p>
<p>该方法若返回true,这表示File表示的是一个文件。</p>
<p>long length() </p>
<p>该方法返回的long值表示该文件所占用的字节量。</p>
<p>boolean exists() </p>
<p>若该File表示的文件或目录存在则返回true,否则返回false。</p>
<p>boolean createNewFile()</p>
<p>返回值:如果指定的文件不存在并成功地创建，则返回 true；如果指定的文件已经存在，则返回 false 。</p>
<p>boolean delete()</p>
<p>返回值:当且仅当成功删除文件或目录时，返回 true；否则返回 false。</p>
<p>需要注意的是，若此File对象所表示的是一个目录时，在删除时需要保证此为空目录才可以成功删除(目录中不能含有任何子项)。</p>
<p>boolean isDirectory()</p>
<p>返回值:若File对象表示的是一个目录，则返回true</p>
<p>boolean mkdir()</p>
<p>返回值：当且仅当已创建目录时，返回 true；否则返回 false</p>
<p>boolean mkdirs()</p>
<p>返回值：当且仅当已创建目录以及所有必需的父目录时，返回 true；否则返回 false</p>
<p>File[] listFiles() </p>
<p>返回值：抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件和目录。如果目录为空，那么数组也将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 null。</p>
<p>File[] listFiles(FileFilter  filter)</p>
<p>FileFilter是用于抽象路径名的过滤器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File[] list = dir.listFiles(<span class="keyword">new</span> FileFilter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathname.getName().startsWith(<span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="文件操作——RandomAccessFile"><a href="#文件操作——RandomAccessFile" class="headerlink" title="文件操作——RandomAccessFile"></a>文件操作——RandomAccessFile</h4><p>RandomAccessFile——对文件随机访问的操作，访问包括读和写操作。该类的读写是基于指针的操作。</p>
<p>只读模式(只读取文件数据)</p>
<p>RandomAccessFile(File file,String mode)    </p>
<p>RandomAccessFile(String filename,String mode)</p>
<p>读写模式(对文件数据进行读写)。</p>
<p>RandomAccessFile raf = new RandomAccessFile(file,”rw”);</p>
<hr>
<h4 id="字节数据读写操作"><a href="#字节数据读写操作" class="headerlink" title="字节数据读写操作"></a>字节数据读写操作</h4><p>void write(int d)</p>
<p>该方法会根据当前指针所在位置处写入一个字节，是将参数int的”低8位”写出。</p>
<p>int read()</p>
<p>该方法会从RandomAccessFile当前指针位置读取一个byte(8位) 填充到int的低八位, 高24位为0, 返回值范围正数: 0~255,</p>
<p>如果返回-1表示读取到了文件末尾EOF(EOF:End Of File)! </p>
<p>每次读取后自动移动文件指针, 准备下次读取。</p>
<p>向文件中写出一组字节：</p>
<p>void write(byte[] d)</p>
<p>void write(byte[] d,int offset,int len)</p>
<p>从文件中批量读取字节：</p>
<p>int read(byte[] b)</p>
<p>该方法会从文件中尝试最多读取给定数组的总长度的字节量，并从给定的字节数组第一个位置开始，将读取到的字节顺序存放至数组中，返回值为实际读取到的字节量 。</p>
<p>void close()</p>
<p>RandomAccessFile在对文件访问的操作全部结束后，要调用close()方法来释放与其关联的所有系统资源。</p>
<p>long getFilePointer()</p>
<p>获取当前指针位置</p>
<p>void seek(long pos)</p>
<p>使用该方法可以移动指针到指定位置</p>
<p>int skipBytes(int n)</p>
<p>跳过输入的 n 个字节以丢弃跳过的字节</p>
<hr>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>我们编写的程序除了自身会定义一些数据信息外，经常还会引用外界的数据，或是将自身的数据发送到外界。</p>
<p>相对程序来讲：</p>
<p>输入是用来读取数据的；</p>
<p>输出是用来写出数据的；</p>
<p>按照流是否直接与特定的地方(如磁盘、内存、设备等)相连，分为节点流和处理流两类。</p>
<p>节点流：可以从或向一个特定的地方（节点）读写数据。</p>
<p>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。</p>
<p>处理流的构造方法总是要带一个其他的流对象做参数。</p>
<p>一个流对象经过其他流的多次包装，称为流的链接。</p>
<p>InputStream是所有字节输入流的父类</p>
<p>int read()</p>
<p>int read(byte[] d)</p>
<p>OutputStream是所有字节输出流的父类</p>
<p>void write(int d)</p>
<p>void write(byte[] d)</p>
<p>FileOutputStream是文件的字节输出流，继承自OutputStream</p>
<p>创建FOS对象(重写模式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIle file = <span class="keyword">new</span> File(<span class="string">"demo.dat"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br></pre></td></tr></table></figure>
<p>若指定的文件已经包含内容，那么当使用FOS对其写入数据时，会将该文件中原有数据全部清除。</p>
<p>创建FOS对象(追加模式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"demo.dat"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>第二个参数若为true,那么通过该FOS写出的数据都是在文件末尾追加的。</p>
<p>FileInputStream是文件的字节输入流，继承自InputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"demo.dat"</span>);</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);<span class="comment">//创建一个用于读取demo.dat文件的输入流</span></span><br></pre></td></tr></table></figure>
<h4 id="批量读写字节到文件"><a href="#批量读写字节到文件" class="headerlink" title="批量读写字节到文件"></a>批量读写字节到文件</h4><p>int read(byte[] b)</p>
<p>void write(byte[] d)</p>
<p>void write(byte[] d,int offset,int len)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="string">"HelloWorld"</span>.getBytes();</span><br><span class="line">fos.write(data);<span class="comment">//会将HelloWorld的所有字节写入文件。</span></span><br></pre></td></tr></table></figure>
<h4 id="BOS缓冲输出流"><a href="#BOS缓冲输出流" class="headerlink" title="BOS缓冲输出流"></a>BOS缓冲输出流</h4><p>一次性批量写出若干数据减少写出次数来提高写出效率。</p>
<p>BufferedOutputStream缓冲输出流内部维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(&quot;demo.dat&quot;);</span><br><span class="line">//创建缓冲字节输出流</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br><span class="line">//所有字节被存入缓冲区，等待一次性写出    </span><br><span class="line">bos.write(&quot;helloworld&quot;.getBytes());    </span><br><span class="line">//关闭流之前，缓冲输出流会将缓冲区内容一次性写出    </span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure>
<p>void flush()</p>
<p>清空缓冲区，将缓冲区中的数据强制写出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bos.flush();</span><br></pre></td></tr></table></figure>
<h4 id="BIS缓冲字节输入流"><a href="#BIS缓冲字节输入流" class="headerlink" title="BIS缓冲字节输入流"></a>BIS缓冲字节输入流</h4><p>BufferedInputStream——其内部维护着一个缓冲区(字节数组)，使用该流在读取一个字节时，该流会尽可能多的一次性读取若干字节并存入缓冲区，然后逐一的将字节返回，直到缓冲区中的数据被全部读取完毕，会再次读取若干字节从而反复。这样就减少了读取的次数，从而提高了读取效率。</p>
<p>BIS是一个处理流，该流为我们提供了缓冲功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"java.zip"</span>);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy_java.zip"</span>);</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"><span class="keyword">int</span> d = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((d = bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    bos.write(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bis.close();//读写完毕后要关闭流，只需要关闭最外层的流即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bos.close();</span><br></pre></td></tr></table></figure>
<p>对象序列化：将对象转换为一个字节序列</p>
<p>对象的反序列化</p>
<p>作用：将对象保存在硬盘上或传输到另一台计算机上</p>
<p>ObjectOutputStream是用来对对象进行序列化的输出流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Emp emp = <span class="keyword">new</span> Emp(<span class="string">"张三"</span>,<span class="number">12</span>，<span class="string">"男"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"Emp.obj"</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(emp);<span class="comment">//将emp对象序列化后写入文件</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>
<p>ObjectInputStream是用来对对象进行反序列化的输入流。</p>
<p>从流中读取字节并转换为对应的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"Emp.obj"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Emp emp = (Emp)ois.readObject();<span class="comment">//将Emp对象从文件中读取并反序列</span></span><br><span class="line">....</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>
<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>ObjectOutputStream在对对象进行序列化时有一个要求，就是需要序列化的对象所属的类必须实现Serializable接口。</p>
<p>只是作为可序列化的标志。</p>
<p>通常实现该接口的类需要提供一个常量serialVersionUID，表明该类的版本。</p>
<p>若向跨平台，都应显示的声明版本号。</p>
<p>关键字 transient——被该关键字修饰的属性在序列化时其值将被忽略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;<span class="comment">//该属性在序列化时会被忽略</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="comment">//getter and setter and other</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>Reader是所有字符输入流的父类，</p>
<p>Writer是所有字符输出流的父类。</p>
<p>字符流是以字符(char)为单位读写数据的，一次处理一个unicode。</p>
<p>字符流都是高级流</p>
<p>底层是依靠字节流进行读写数据的，所以底层仍然是基于字节读写数据的。</p>
<p>Reader</p>
<p>int read()——读取一个字符，返回的int值”低16”位有效。</p>
<p>int read(char[] chs)——存入该数组，返回值为实际读取到的字符量</p>
<p>Writer</p>
<p>void write(int c)——写出给定int值”低16”位表示的字符</p>
<p>void write(char[] chs)——将给定字符数组中所有字符写出</p>
<p>void write(String str)——将给定的字符串写出</p>
<p>void write(char[] chs,int offset,int len)——将给定的字符数组中从offset处开始连续的len个字符写出</p>
<h4 id="字符转换流"><a href="#字符转换流" class="headerlink" title="字符转换流"></a>字符转换流</h4><p>InputStreamReader：字符输入流， 使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。</p>
<p>OutputStreamWriter:字符输出流，使用该流可以设置字符集，并按照指定的字符集将字符转换为对应字节后通过该流写出。</p>
<p>ISR</p>
<p>InputStreamReader(InputStream in,String charsetName)</p>
<p>OSW</p>
<p>OutputStreamWriter(OutputStream out,String charsetName)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"demo.txt"</span>);    </span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"UTF-8"</span>);<span class="comment">//这里使用的字符编码为UTF-8</span></span><br><span class="line">String str = <span class="string">"大家好!"</span>;<span class="comment">//UTF-8中文为3个字节，英文符号占1个字节</span></span><br><span class="line">writer.write(str);<span class="comment">//写出后该文件大小应该为10字节</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  这里设置了字符编码为GBK    </span></span><br><span class="line"><span class="comment">*  之后再通过ISR读取demo.txt文件时    </span></span><br><span class="line"><span class="comment">*  就使用GBK编码读取字符了    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">"GBK"</span>);</span><br><span class="line"><span class="keyword">int</span> c = -<span class="number">1</span>;    </span><br><span class="line"><span class="keyword">while</span>((c = reader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>
<h4 id="PrintWriter-BufferedReader"><a href="#PrintWriter-BufferedReader" class="headerlink" title="PrintWriter/BufferedReader"></a>PrintWriter/BufferedReader</h4><p>PrintWriter是具有自动行刷新的缓冲该字符输出流。</p>
<p>PrintWriter(File file)</p>
<p>PrintWriter(String fileName)</p>
<p>PrintWriter(OutputStream out)</p>
<p>PrintWriter(OutputStream out,boolean autoFlush)</p>
<p>PrintWriter(Writer writer)</p>
<p>PrintWriter(Writer writer,boolean autoFlush)</p>
<p>boolean autoFlush该参数用于表示PrintWriter是否具有自动行刷新</p>
<p>使用PrintWriter写出字符串时使用print和println等方法</p>
<p>使用PW输出字符数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"UTF-8"</span>);<span class="comment">//创建带有自动行刷新的</span></span><br><span class="line">PWPrintWriter pw = <span class="keyword">new</span> PrintWriter(osw,<span class="keyword">true</span>);</span><br><span class="line">pw.println(<span class="string">"大家好!"</span>);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure>
<p>BufferedReader是缓冲字符输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br></pre></td></tr></table></figure>
<p>当我们想基于一个字节流进行读取时，要先将字节流转换为字符流后方可创建缓冲字符输入流BufferedReader。</p>
<p>String readLine()——读取一行字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>Java异常结构中定义有Throwable类，</p>
<p>Exceotion和Error是其派生的两个子类。</p>
<p>Exception表示由于网络故障、文件损坏、设备错误、用户输入非法等情况导致的异常，这类异常是可以通过Java异常捕获机制处理的。</p>
<p>Error表示Java运行时环境出现的错误，例如:JVM内存溢出等。</p>
<p>每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常。</p>
<p>catch捕获的异常类型由上至下的捕获异常类型的顺序应是子类到父类的。</p>
<p>finally语句块只能定义在try语句块之后，或者最后一个catch语句块之后，且只能定义一次。</p>
<p>若想要自行抛出异常，可以使用“throw”关键词，并生成指定的异常对象。</p>
<p>throw new ArithmeticException();</p>
<p>使用“throws”关键词来声明这个方法将会抛出异常，让调用它的方法来统一处理。</p>
<p>public static void stringToDate(String str) throws  ParseException{…}</p>
<p><strong>重写方法时的throws</strong></p>
<p>当使用继承时，在父类的某个方法上声明了throws抛出某些异常，而在子类中重写该方法时，我们可以做以下的操作:</p>
<p>不处理异常（重写方法时不声明throws） </p>
<p>可仅在throws中声明父类中声明的部分异常 </p>
<p>可在throws中声明父类方法中抛出的异常的子类异常</p>
<p>但是不能做以下操作：</p>
<p>重写方法时在throws中声明抛出额外的异常 </p>
<p>重写方法时在throws中声明父类方法中声明的抛出异常的父类异常 </p>
<p>Java异常可以分为可检测异常，非检测异常：</p>
<p>可检测异常：可检测异常经编译器验证，对于声明抛出异常的任何方法，编译器将强制执行处理或声明规则，不捕捉这个异常，编译器就通不过，不允许编译</p>
<p>非检测异常：非检测异常不遵循处理或者声明规则。在产生此类异常时，不一定非要采取任何适当操作，编译器不会检查是否已经解决了这样一个异常</p>
<p>RuntimeException 类属于非检测异常，常见RuntimeException：</p>
<blockquote>
<p>IllegalArgumentException</p>
<p>抛出的异常表明向方法传递了一个不合法或不正确的参数</p>
<p>NullPointerException</p>
<p>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p>
<p>ArrayIndexOutOfBoundsException</p>
<p>当使用的数组下标超出数组允许范围时，抛出该异常</p>
<p>ClassCastException</p>
<p>当试图将对象强制转换为不是实例的子类时，抛出该异常</p>
<p>NumberFormatException</p>
<p>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</p>
</blockquote>
<p>e.printStackTrace();//输出执行堆栈信息</p>
<p>System.out.println(e.getMessage());//有关异常事件的信息</p>
<p>Throwable getCause() 获取该异常出现的原因</p>
<p><strong>自定义异常</strong></p>
<p>1.声明一个类并继承自Exception </p>
<p>2.右键点击Source </p>
<p>3.选择Generate Constructors from Superclass </p>
<p>4.选中父类中所有构造方法后确认生成 </p>
<hr>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>进程（process）就是一块包含了某些资源的内存区域，一个进程是一个应用程序。</p>
<p>进程中所包含的一个或多个执行单元称为线程（thread）。</p>
<p>线程只能归属于一个进程并且它只能访问该进程所拥有的资源。</p>
<p>一个线程是进程的一个顺序执行流</p>
<p>线程也被称为轻负荷进程（切换负荷小）。</p>
<p>一个进程中可以包含多个线程。</p>
<p>线程通常用于在一个程序中需要同时完成多个任务的情况。</p>
<p>进程和线程是并发运行的，OS的线程调度机制将时间划分为很多时间片段（时间片），尽可能均匀分配给正在运行的程序，获取CPU时间片的线程或进程得以被执行，其他则等待。而CPU则在这些进程或线程上来回切换运行。微观上所有进程和线程是走走停停的，宏观上都在运行，这种都运行的现象叫并发。</p>
<p><strong>线程生命周期</strong></p>
<p>New：当我们创建一个线程时，该线程并没有纳入线程调度，其处于一个new状态。</p>
<p>Runnable:当调用线程的start方法后，该线程纳入线程调度的控制，其处于一个可运行状态，等待分配时间片段以并发运行。</p>
<p>Running:当该线程被分配到了时间片段后其被CPU运行，这是该线程处于running状态。</p>
<p>Blocked:当线程在运行过程中可能会出现阻塞现象，比如等待用户输入信息等。但阻塞状态不是百分百出现的，具体要看代码中是否有相关需求。</p>
<p>Dead:当线程的任务全部运行完毕，或在运行过程中抛出了一个未捕获的异常，那么线程结束，等待GC回收</p>
<p><strong>使用Thread创建线并启动线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread thread = <span class="keyword">new</span> TestThread();<span class="comment">//实例化线程</span></span><br><span class="line">thread.start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>
<p><strong>使用Runnable创建并启动线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> TestRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);<span class="comment">//实例化线程并传入线程体</span></span><br><span class="line">thread.start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>
<p><strong>使用内部类创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p><strong>获取运行当前代码片段的线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread current = Thread.currentThread();</span><br></pre></td></tr></table></figure>
<p><strong>获取线程信息</strong></p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>long</td>
<td>getId()</td>
<td>返回该线程的标识符</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>返回该线程的名称</td>
</tr>
<tr>
<td>int</td>
<td>getPriority()</td>
<td>返回线程的优先级</td>
</tr>
<tr>
<td>Thread.state</td>
<td>getState()</td>
<td>获取线程的状态</td>
</tr>
<tr>
<td>boolean</td>
<td>isAlive()</td>
<td>测试线程是否处于活动状态</td>
</tr>
<tr>
<td>boolean</td>
<td>isDaemon()</td>
<td>测试线程是否为守护线程</td>
</tr>
<tr>
<td>boolean</td>
<td>isInterrupted()</td>
<td>测试线程是否已经中断</td>
</tr>
</tbody>
</table>
<p><strong>线程优先级</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> priority)</span> <span class="comment">//1-10，1最低，10最高</span></span></span><br><span class="line"><span class="function">Thread.MIN_PRIORITY</span></span><br><span class="line"><span class="function">Thread.MAX_PRIORITY</span></span><br><span class="line"><span class="function">Thread.NORM_PRIORITY</span></span><br></pre></td></tr></table></figure>
<p><strong>守护线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>当参数为true时该线程为守护线程。</p>
<p>守护线程的特点是，当进程中只剩下守护线程时，所有守护线程强制终止。</p>
<p>GC就是运行在一个守护线程上的。</p>
<p>需要注意的是，设置线程为后台线程要在该线程启动前设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemonThread = <span class="keyword">new</span> Thread();</span><br><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure>
<p>Thread的静态方法sleep用于使当前线程进入阻塞状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> ms)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法会使当前线程进入阻塞状态指定毫秒，当指定毫秒阻塞后，当前线程会重新进入Runnable状态，等待分配时间片。</p>
<p>该方法声明抛出一个InterruptException，所以在使用该方法时需要捕获这个异常。</p>
<p>Thread的静态方法yield：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>该方法用于使当前线程主动让出当次CPU时间片回到Runnable状态，等待分配时间片。</p>
<p>join()用于等待当前线程结束。此方法是一个阻塞方法。</p>
<p>该方法声明抛出InterruptException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//一些耗时的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();<span class="comment">//这里t2线程会开始阻塞，直到t1线程的run方法执行完毕</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以下是当前线程的任务代码,只有t1线程运行完毕才会运行。            </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果条件不满足，则等待。当条件满足时，等待该条件的线程将被唤醒。</p>
<p>在Java中，这个机制的实现依赖于wait/notify。</p>
<p>等待机制与锁机制是密切关联的。</p>
<p>常见的临界资源:</p>
<ul>
<li><p>多线程共享实例变量 </p>
</li>
<li><p>多线程共享静态公共变量</p>
</li>
<li><p>多个线程并发读写同一个临界资源时候会发生”线程并发安全问题”</p>
</li>
</ul>
<p>所谓异步操作是指多线程并发的操作，相当于各干各的。</p>
<p>所谓同步操作是指有先后顺序的操作，相当于你干完我再干。</p>
<p>java中有一个关键字名为:synchronized，</p>
<p>该关键字是同步锁，用于将某段代码变为同步操作，</p>
<p>从而解决线程并发安全问题。</p>
<p>若方法所有代码都需要同步也可以给方法直接加锁。</p>
<p>获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。</p>
<p>多个需要同步的线程在访问该同步块时，看到的应该是同一个锁对象引用。</p>
<p>静态方法锁，该方法锁的对象是类对象</p>
<p>获取类对象的方式:类名.class</p>
<p>静态方法与非静态方法同时声明了synchronized，他们之间是非互斥关系的。原因在于，静态方法锁的是类对象而非静态方法锁的是当前方法所属对象。</p>
<p>StringBuffer 是同步的 synchronized append();</p>
<p>StringBuilder 不是同步的 append();</p>
<p>Vector 和 Hashtable 是线程安全的，ArrayList 和 HashMap则不是线程安全的。</p>
<p>将集合或Map转换为线程安全的：</p>
<p>Collections.synchronizedList():获取线程安全的List集合</p>
<p>Collections.synchronizedMap():获取线程安全的Map</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>首先创建一些线程，它们的集合称为线程池，</p>
<p>当服务器收到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，</p>
<p>服务完后不关闭该线程，而是将该线程还回到线程池中。</p>
<p>使用线程池来解决问题：</p>
<p>创建大量线程，并在任务结束后销毁，给系统带来过度消耗资源；</p>
<p>过度切换线程的危险，可能导致系统崩溃。</p>
<p>线程池的作用：</p>
<ul>
<li>控制线程数量；</li>
<li>重用线程；</li>
</ul>
<p>在线程池的编程模式下，任务是提交给整个线程池，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务</p>
<p>ExecutorService是java提供的用于管理线程池的类。</p>
<p>实现策略：</p>
<p>Executors.newCachedThreadPool()</p>
<p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</p>
<p>Executors.newFixedThreadPool(int nThreads)</p>
<p>创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程。</p>
<p>Excutors.newScheduledThreadPool(int corePoolSize)</p>
<p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<p>Executors.newSingleThreadExecutor()</p>
<p>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">30</span>);<span class="comment">//创建具有30个线程的线程池</span></span><br><span class="line">Runnable r1 = <span class="keyword">new</span> Runable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//线程体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">threadPool.execute(r1);<span class="comment">//将任务交给线程池，其会分配空闲线程来运行这个任务。</span></span><br></pre></td></tr></table></figure>
<p>BlockingQueue是双缓冲队列</p>
<p>BlockingQueue内部使用两条队列，可允许两个线程同时向队列一个做存储，一个做取出操作。在保证并发安全的同时提高了队列的存取效率。</p>
<p>ArrayBlockingDeque</p>
<p>规定大小的BlockingDeque,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。</p>
<p>LinkedBlockingDeque</p>
<p>大小不定的BlockingDeque,若其构造函数带一个规定大小的参数,生成的BlockingDeque有大小限制,若不带大小参数,所生成的BlockingDeque的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。</p>
<p>PriorityBlockingDeque</p>
<p>类似于LinkedBlockDeque,但其所含对象的排序不是FIFO,而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序。</p>
<p>SynchronousQueue</p>
<p>特殊的BlockingQueue,对其的操作必须是放和取交替完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//queue.offer("A");//立即向队列末尾追加元素                       </span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 向队列末尾追加元素，指定可延迟5秒。</span></span><br><span class="line"><span class="comment">         * 若5秒钟内成功将元素加入队列返回true</span></span><br><span class="line"><span class="comment">         * 若超时后元素仍然没有加入队列则返回flase</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue.offer(<span class="string">"A"</span>,<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>socket通常称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。</p>
<p>每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。</p>
<p>ServerSocket用于服务端，Socket是建立网络连接时使用的。</p>
<p>在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。</p>
<p>获取本地地址和端口号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSocket</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8088</span>);</span><br><span class="line">    InetAddress add = socket.getLocalAddress();<span class="comment">//获取本地地址信息</span></span><br><span class="line">    System.out.println(add.getCanonicalHostName());<span class="comment">//获取此 IP 地址的完全限定域名</span></span><br><span class="line">    System.out.println(add.getHostAddress());<span class="comment">//返回 IP 地址字符串（以文本表现形式）</span></span><br><span class="line">    System.out.println(socket.getLocalPort());<span class="comment">//获取本地使用的端口号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取远端地址和端口号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSocket</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8088</span>);</span><br><span class="line">    InetAddress inetAdd = socket.getInetAddress();<span class="comment">//获取套接字绑定的远端地址</span></span><br><span class="line">    System.out.println(inetAdd.getCanonicalHostName());</span><br><span class="line">    System.out.println(inetAdd.getHostAddress());</span><br><span class="line">    System.out.println(socket.getPort());<span class="comment">//获取远端使用的端口号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取网络输入流和网络输出流</p>
<p>封装了TCP协议的Socket是基于流进行通讯的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSocket</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8088</span>);</span><br><span class="line">    InputStream in = socket.getInputStream();<span class="comment">//返回此套接字的输入流</span></span><br><span class="line">    OutputStream out = socket.getOutputStream();<span class="comment">//返回此套接字的输出流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用Socket进行通讯完毕后，要关闭Socket以释放系统资源</p>
<p>void close()</p>
<p>当关闭了该套接字后也会同时关闭由此获取的输入流与输出流。</p>
<p><strong>Server端ServerSocket监听</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ServerSocket并申请服务端口8088</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8088</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*方法会产生阻塞，直到某个Socket连接,并返回请求连接的Socket*/</span></span><br><span class="line">Socket socket = server.accept();</span><br></pre></td></tr></table></figure>
<p>该方法是一个阻塞方法，直到一个客户端通过Socket连接后，accept会封装一个Socket，该Socket封装与表示该客户端的有关的信息。通过这个Socket与该客户端进行通信。</p>
<p><strong>Client端Socket连接</strong></p>
<p>创建Socket的同时就发起连接，若连接异常会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1：服务端的IP地址，参数2:服务端的服务端口</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(“localhost”,<span class="number">8088</span>);</span><br></pre></td></tr></table></figure>
<p><strong>C-S端通信模型</strong></p>
<blockquote>
<p>1.服务端创建ServerSocket </p>
<p>2.通过调用ServerSocket的accept方法监听客户端的连接 </p>
<p>3.客户端创建Socket并指定服务端的地址以及端口来建立与服务端的连接 </p>
<p>4.当服务端accept发现客户端连接后，获取对应该客户端的Socket </p>
<p>5.双方通过Socket分别获取对应的输入与输出流进行数据通讯 </p>
<p>6.通讯结束后关闭连接。</p>
</blockquote>
<p>Server端多线程模型</p>
<p>一个服务端可以同时支持多个客户端</p>
<p>创建一个线程类ClientHandler</p>
<h4 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h4><p>DatagramPacket：UDP数据报基于IP建立的,每台主机有65536个端口号可以使用。数据报中字节数限制为65536-8 。包含8字节的头信息。</p>
<p><strong>创建接收包</strong></p>
<p>DatagramPacket(byte[] buf, int length)</p>
<p>将数据包中Length长的数据装进Buf数组。</p>
<p>DatagramPacket(byte[] buf, int offset, int length) </p>
<p>将数据包中从Offset开始、Length长的数据装进Buf数组。</p>
<p><strong>创建发送包</strong></p>
<p>DatagramPacket(byte[] buf, int length, InetAddress clientAddress, int clientPort)</p>
<p>从Buf数组中，取出Length长的数据创建数据包对象，目标是clientAddress地址，clientPort端口,通常用来发送数据给客户端。</p>
<p>DatagramPacket(byte[] buf, int offset, int length, InetAddress clientAddress, int clientPort)</p>
<p>从Buf数组中，取出Offset开始的、Length长的数据创建数据包对象，目标是clientAddress地址，clientPort端口，通常用来发送数据给客户端。</p>
<p>DatagramSocket 用于接收和发送UDP的Socket实例 。</p>
<p><strong>服务端接收</strong></p>
<p>DatagramSocket(int port)</p>
<p>创建实例，并固定监听Port端口的报文。通常用于服务端。</p>
<p>receive(DatagramPacket d)</p>
<p>接收数据报文到d中。receive方法产生 “阻塞”。会一直等待知道有数据被读取到。</p>
<p><strong>客户端发送</strong></p>
<p>无参的构造方法DatagramSocket()通常用于客户端编程，它并没有特定监听的端口，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。</p>
<p>send(DatagramPacket dp)</p>
<p>该方法用于发送报文dp到目的地。</p>
<hr>
<h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>XPath 是一门在 XML 文档中查找信息的语言。</p>
<p>斜杠（/）作为路径内部的分割符。</p>
<p>同一个节点有绝对路径和相对路径两种写法: </p>
<p>​    绝对路径（absolute path）必须用”/“起首，后面紧跟根节点，比如/step/step/…。 </p>
<p>​    相对路径（relative path）则是除了绝对路径以外的其他写法，比如 step/step， 也就是不使用”/“起首。 </p>
<blockquote>
<p>“.”表示当前节点。 </p>
<p>“..”表示当前节点的父节点 </p>
<p>nodename（节点名称）：表示选择该节点的所有子节点 </p>
<p>“/“：表示选择根节点 </p>
<p>“//“：表示选择任意位置的某个节点 </p>
<p>“@”： 表示选择某个属性 </p>
</blockquote>
<p>“谓语条件”，就是对路径表达式的附加条件。所有的条件，都写在方括号”[]”中，表示对节点进行进一步的筛选。</p>
<blockquote>
<p>/book[1]</p>
<p>/book[last]</p>
<p>//title[@lang=’eng’]</p>
<p>/book[price]</p>
</blockquote>
<p>通配符:</p>
<blockquote>
<p>“*”表示匹配任何元素节点。 </p>
<p>“@*”表示匹配任何属性值。 </p>
<p>node()表示匹配任何类型的节点。</p>
</blockquote>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/kev168.jpg" alt="Gavin Gao wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的二维码添加好友，一起探讨&进步！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持好文分享，您的支持将鼓励我继续进步！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Gavin Gao 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Gavin Gao 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/JavaSE/" rel="tag"># JavaSE</a>
          
            <a href="/tags/IO/" rel="tag"># IO</a>
          
            <a href="/tags/Thread/" rel="tag"># Thread</a>
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/12/Spring Boot/SpringBoot 整合MyBatis/" rel="next" title="SpringBoot 整合 MyBatis">
                <i class="fa fa-chevron-left"></i> SpringBoot 整合 MyBatis
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/18/产品运营/产品思维30讲/" rel="prev" title="产品思维30讲">
                产品思维30讲 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Gavin Gao" />
            
              <p class="site-author-name" itemprop="name">Gavin Gao</p>
              <p class="site-description motion-element" itemprop="description">也许就在这一瞬间 你的笑容一人如晚霞般 在川流不息的时光中 神采飞扬</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/imacoderchina" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:gnkevin@126.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux常用命令："><span class="nav-number">1.</span> <span class="nav-text">Linux常用命令：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先编译、后执行的原则"><span class="nav-number">2.</span> <span class="nav-text">先编译、后执行的原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量"><span class="nav-number">3.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本数据类型"><span class="nav-number">4.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">5.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的复制"><span class="nav-number">6.</span> <span class="nav-text">数组的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组扩容"><span class="nav-number">7.</span> <span class="nav-text">数组扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的排序"><span class="nav-number">8.</span> <span class="nav-text">数组的排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象编程"><span class="nav-number">9.</span> <span class="nav-text">面向对象编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛化"><span class="nav-number">10.</span> <span class="nav-text">泛化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装的意义"><span class="nav-number">11.</span> <span class="nav-text">封装的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何重写equals方法？"><span class="nav-number">12.</span> <span class="nav-text">如何重写equals方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals与-的区别"><span class="nav-number">13.</span> <span class="nav-text">equals与 == 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List与数组互转"><span class="nav-number">14.</span> <span class="nav-text">List与数组互转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List排序"><span class="nav-number">15.</span> <span class="nav-text">List排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件操作——File"><span class="nav-number">16.</span> <span class="nav-text">文件操作——File</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件操作——RandomAccessFile"><span class="nav-number">17.</span> <span class="nav-text">文件操作——RandomAccessFile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节数据读写操作"><span class="nav-number">18.</span> <span class="nav-text">字节数据读写操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO"><span class="nav-number">19.</span> <span class="nav-text">IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#批量读写字节到文件"><span class="nav-number">20.</span> <span class="nav-text">批量读写字节到文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BOS缓冲输出流"><span class="nav-number">21.</span> <span class="nav-text">BOS缓冲输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIS缓冲字节输入流"><span class="nav-number">22.</span> <span class="nav-text">BIS缓冲字节输入流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Serializable"><span class="nav-number">23.</span> <span class="nav-text">Serializable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符流"><span class="nav-number">24.</span> <span class="nav-text">字符流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符转换流"><span class="nav-number">25.</span> <span class="nav-text">字符转换流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PrintWriter-BufferedReader"><span class="nav-number">26.</span> <span class="nav-text">PrintWriter/BufferedReader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异常"><span class="nav-number">27.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程"><span class="nav-number">28.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池"><span class="nav-number">29.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP"><span class="nav-number">30.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP通信"><span class="nav-number">31.</span> <span class="nav-text">UDP通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XPath"><span class="nav-number">32.</span> <span class="nav-text">XPath</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Gao</span>

  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
