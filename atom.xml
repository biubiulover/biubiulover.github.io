<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BiuBiu</title>
  
  <subtitle>GOOD IS GOOD, BUT BETTER CARRIES IT.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gnbyj.cn/"/>
  <updated>2019-02-28T09:59:39.140Z</updated>
  <id>http://gnbyj.cn/</id>
  
  <author>
    <name>Gavin Gao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack</title>
    <link href="http://gnbyj.cn/2019/02/28/%5B2019-02-28%5Dwebpack/"/>
    <id>http://gnbyj.cn/2019/02/28/[2019-02-28]webpack/</id>
    <published>2019-02-28T04:10:00.000Z</published>
    <updated>2019-02-28T09:59:39.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>FED - webpack流程 <a href="http://taobaofed.org/blog/2016/09/09/webpack-flow/" target="_blank" rel="noopener">http://taobaofed.org/blog/2016/09/09/webpack-flow/</a></p></blockquote><ol><li>读取文件分析模块依赖</li><li>对模块进行解析执行(深度遍历)</li><li>针对不同的模块使用相应的loader</li><li>编译模块，生成抽象语法树AST</li><li>循环遍历AST树，拼接输出js</li></ol><hr><blockquote><p><a href="https://blog.csdn.net/qq_26708777/article/details/79210549" target="_blank" rel="noopener">https://blog.csdn.net/qq_26708777/article/details/79210549</a></p></blockquote><p>webpack-parallel-uglify-plugin</p><p>会开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，但是每个子进程还是通过UglifyJS去压缩代码。无非就是变成了并行处理该压缩了，并行处理多个子任务，效率会更加的提高。</p><blockquote><p>压缩慢：因为压缩JS代码需要先把代码解析成用Object抽象表示的AST语法树，再去应用各种规则分析和处理AST，导致这个过程耗时非常大。</p></blockquote><p>compression-webpack-plugin </p><p>该插件能够将资源文件压缩为.gz文件，并且根据客户端的需求按需加载。 </p><p>extract-text-webpack-plugin</p><p>剥离css文件，单独打包</p><p>html-webpack-plugin </p><p>开启html压缩，自动添加上面生成的静态资源</p><p>CommonsChunkPlugin</p><p>这个插件用来提取公共的module到独立的chunk文件里。</p><p>webpack-bundle-analyzer</p><p>将打包后的内容束展示为方便交互的直观树状图，让你明白你所构建包中真正引入的内容</p><p>copy-webpack-plugin</p><p>在webpack中拷贝文件和文件夹 </p><hr><p>模块化拆分打包</p><ol><li>利用glob库匹配出所有模块的入口文件，得到一个数组；</li><li>遍历数组拿到路径，提取路径中模块名，将二者维护进对象中；</li><li>遍历这个对象的key(即模块名)，如果与命令相同，则赋值给入口变量；</li></ol><hr><p>整体打包</p><ol><li>利用glob库匹配出所有模块的入口文件，得到一个数组；</li><li>将数组切分为4个一组；</li><li>开启子进程，遍历数组拿到模块名，使用<code>child_process.spawn(command)</code>运行打包命令</li></ol><hr><p><a href="https://segmentfault.com/a/1190000012113011" target="_blank" rel="noopener">webpack externals 深入理解</a></p><p>按照官方文档的解释，如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals。</p><p>这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用。 </p><blockquote><p>如果你写的库要支持各种环境，你需要设置output中的libraryTarget为umd，也就是将打包的文件，生成为umd规范，适用于各种环境。libraryTarget和externals有藕断丝连的关系 </p></blockquote><p><code>externals</code>和<code>libraryTarget</code>的关系</p><ul><li>libraryTarget 配置如何暴露 library。如果不设置library，那这个library就不暴露。就相当于一个自执行函数</li><li>externals是决定的是以哪种模式去加载所引入的额外的包</li><li>libraryTarget决定了你的library运行在哪个环境，哪个环境也就决定了你哪种模式去加载所引入的额外的包。也就是说，externals应该和libraryTarget保持一致。library运行在浏览器中的，你设置externals的模式为commonjs，那代码肯定就运行不了了。</li><li>如果是应用程序开发，一般是运行在浏览器环境libraryTarget可以不设置，externals默认的模式是global，也就是以全局变量的模式加载所引入外部的库。</li></ul><hr><blockquote><p>webpack devtool类型对比</p><p><a href="https://www.cnblogs.com/hhhyaaon/p/5657469.html" target="_blank" rel="noopener">https://www.cnblogs.com/hhhyaaon/p/5657469.html</a></p></blockquote><p>开发环境推荐： <code>cheap-module-eval-source-map</code> </p><p>生产环境推荐： <code>cheap-module-source-map</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;FED - webpack流程 &lt;a href=&quot;http://taobaofed.org/blog/2016/09/09/webpack-flow/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://taobaofed
      
    
    </summary>
    
      <category term="web" scheme="http://gnbyj.cn/categories/web/"/>
    
    
      <category term="webpack" scheme="http://gnbyj.cn/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="http://gnbyj.cn/2019/02/27/%5B2019-02-27%5DES6/"/>
    <id>http://gnbyj.cn/2019/02/27/[2019-02-27]ES6/</id>
    <published>2019-02-27T01:10:00.000Z</published>
    <updated>2019-02-28T14:31:37.490Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://es6.ruanyifeng.com" target="_blank" rel="noopener">http://es6.ruanyifeng.com</a></p></blockquote><ol><li><h5 id="新的变量声明方式-let-const"><a href="#新的变量声明方式-let-const" class="headerlink" title="新的变量声明方式 let/const"></a>新的变量声明方式 let/const</h5><p>使用let来声明一个【值会被改变】的变量</p><p>使用const来声明一个【值不会被改变】的变量，也可以称之为常量</p><blockquote><p>ES6 声明变量的六种方法</p><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。</p><p>ES6 除了添加<code>let</code>和<code>const</code>命令，</p><p>另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。</p><p>所以，ES6 一共有 6 种声明变量的方法。</p></blockquote></li></ol><ol start="2"><li><h5 id="箭头函数的使用"><a href="#箭头函数的使用" class="headerlink" title="箭头函数的使用"></a>箭头函数的使用</h5><p>箭头函数中，没有自己的this。如果你在箭头函数中使用了this，那么该this一定是最近外层的this。 </p><p>不能用call/apply/bind来改变this指向。 </p><blockquote><p>ES6 默认采用严格模式，this不会自动指向window对象</p></blockquote></li></ol><ol start="3"><li><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>使用 <code></code> 将整个字符串包裹起来，而在其中使用 ${} 来包裹一个变量或者一个表达式。 </p><p>支持换行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`<span class="subst">$&#123;a&#125;</span>+<span class="subst">$&#123;b&#125;</span>=<span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line">str <span class="comment">// "20+30=50"</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>解构赋值</p><p>数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [a, b] = arr;</span><br><span class="line">a; <span class="comment">// 1</span></span><br><span class="line">b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">k1</span>: <span class="string">'china'</span>, <span class="attr">k2</span>: <span class="string">'usa'</span>, <span class="attr">k3</span>: <span class="string">'japan'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;k1, k2, k3&#125; = obj;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>默认参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = x || <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> y = y || <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x=<span class="number">20</span>, y=<span class="number">30</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>数组的扩展</p><p>展开运算符（spread）是三个点（<code>...</code>） </p><p>将一个数组转为用逗号分隔的参数序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>, </span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  ...obj1,</span><br><span class="line">  d: <span class="number">4</span>,</span><br><span class="line">  e: <span class="number">5</span>,</span><br><span class="line">  f: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有木有觉得很像什么？Vuex里的...mapState  ...mapGetters  ...mapActions</span></span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>every() / some()</p><blockquote><p>every() 一假即假</p><p>some() 一真即真</p></blockquote></li></ol><ol start="8"><li><p>class/extends</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function() / .prototype</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><p>Promise</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 解决回调嵌套</span><br><span class="line">new Promise(function(resolve, reject)&#123;</span><br><span class="line">    if (true) &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function()&#123;</span><br><span class="line">    // resolve</span><br><span class="line">&#125;, function()&#123;</span><br><span class="line">    // reject</span><br><span class="line">&#125;)</span><br><span class="line">.then(//同上)</span><br><span class="line">.catch(function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="web" scheme="http://gnbyj.cn/categories/web/"/>
    
    
      <category term="es6" scheme="http://gnbyj.cn/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>axios</title>
    <link href="http://gnbyj.cn/2019/02/27/%5B2019-02-27%5Daxios/"/>
    <id>http://gnbyj.cn/2019/02/27/[2019-02-27]axios/</id>
    <published>2019-02-27T01:10:00.000Z</published>
    <updated>2019-02-27T08:04:06.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>基于Promise的HTTP库，<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a> </p><p>axios中文文档：<a href="http://www.axios-js.com/zh-cn/docs/" target="_blank" rel="noopener">http://www.axios-js.com/zh-cn/docs/</a></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 <a href="http://baike.baidu.com/link?url=iUceAfgyfJOacUtjPgT4ifaSOxDULAc_MzcLEOTySflAn5iLlHfMGsZMtthBm5sK4y6skrSvJ1HOO2qKtV1ej_" target="_blank" rel="noopener">CSRF/XSRF</a></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"><span class="comment">// post</span></span><br><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// get 1</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line"><span class="comment">// get 2</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">      <span class="comment">// The request was made and the server responded with a status code</span></span><br><span class="line">      <span class="comment">// that falls out of the range of 2xx</span></span><br><span class="line">      <span class="comment">// 请求已发出，但服务器使用状态代码进行响应，落在2xx的范围之外</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.response.data);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.status);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.headers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.request) &#123;</span><br><span class="line">      <span class="comment">// The request was made but no response was received</span></span><br><span class="line">      <span class="comment">// `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span></span><br><span class="line">      <span class="comment">// http.ClientRequest in node.js</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Something happened in setting up the request that triggered an Error</span></span><br><span class="line">      <span class="comment">// 在设置触发错误的请求时发生了错误</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error'</span>, error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>使用【validateStatus配置选项】定义自定义HTTP状态码错误范围：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get（<span class="string">'/ user / 12345'</span>，&#123;</span><br><span class="line">   validateStatus：<span class="function"><span class="keyword">function</span>（<span class="title">status</span>）</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">//仅当状态代码大于或等于500时拒绝</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.all(iterable)</span><br><span class="line">axios.spread(callback)</span><br></pre></td></tr></table></figure><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="requests-response-拦截器"><a href="#requests-response-拦截器" class="headerlink" title="requests/response 拦截器"></a>requests/response 拦截器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在发送请求之前做某事</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//请求错误时做些事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//对响应数据做些事</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//请求错误时做些事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="删除拦截器"><a href="#删除拦截器" class="headerlink" title="删除拦截器"></a>删除拦截器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure><h3 id="将拦截器添加到axios的自定义实例"><a href="#将拦截器添加到axios的自定义实例" class="headerlink" title="将拦截器添加到axios的自定义实例"></a>将拦截器添加到axios的自定义实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="默认全局配置"><a href="#默认全局配置" class="headerlink" title="默认全局配置"></a>默认全局配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>; <span class="comment">// 配置接口地址</span></span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>; <span class="comment">// 配置请求头</span></span><br></pre></td></tr></table></figure><h2 id="配置优先级顺序"><a href="#配置优先级顺序" class="headerlink" title="配置优先级顺序"></a>配置优先级顺序</h2><p>【请求的config参数】 &gt; 【实例的defaults属性】 &gt; 【lib / defaults.js中的库默认值】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用库提供的配置默认值创建实例</span></span><br><span class="line"><span class="comment">//此时，超时配置值为`0`，这是库的默认值</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create（）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖库的超时默认值</span></span><br><span class="line"><span class="comment">//现在所有请求将在超时前等待2.5秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//为已知需要花费很长时间的请求覆写超时设置</span></span><br><span class="line">instance.get（<span class="string">'/ longRequest'</span>，&#123;</span><br><span class="line">   timeout：<span class="number">5000</span></span><br><span class="line">&#125;）;</span><br></pre></td></tr></table></figure><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><blockquote><p>axios cancel token API基于可取消的promise提议</p></blockquote><p>使用CancelToken.source工厂创建一个取消令牌 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消请求（消息参数是可选的）</span></span><br><span class="line">source.cancel（<span class="string">'操作被用户取消。'</span>）;</span><br></pre></td></tr></table></figure><p>将【执行器函数】传递给CancelToken构造函数来创建取消令牌：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> cancel;</span><br><span class="line"> </span><br><span class="line">axios.get（<span class="string">'/ user / 12345'</span>，&#123;</span><br><span class="line">   cancelToken：<span class="keyword">new</span> CancelToken（<span class="function"><span class="keyword">function</span> <span class="title">executor</span>（<span class="title">c</span>）</span>&#123;</span><br><span class="line">     <span class="comment">//一个执行器函数接收一个取消函数作为参数</span></span><br><span class="line">     cancel = c;</span><br><span class="line">   &#125;）</span><br><span class="line">&#125;）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">clear();</span><br></pre></td></tr></table></figure><h2 id="使用application-x-www-form-urlencoded格式"><a href="#使用application-x-www-form-urlencoded格式" class="headerlink" title="使用application / x-www-form-urlencoded格式"></a>使用application / x-www-form-urlencoded格式</h2><p>默认情况下，axios发送数据的形式为<code>application/json;charset=UTF-8</code>，如若想以<code>application/x-www-form-urlencoded</code>的形式发送数据，可以使用如下方法：</p><h3 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是所有浏览器都支持</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入qs模块</span></span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;));</span><br></pre></td></tr></table></figure><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以使用qs模块</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;));</span><br></pre></td></tr></table></figure><h2 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// `url`是将用于请求的服务器URL</span></span><br><span class="line">    url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `method`是发出请求时使用的请求方法</span></span><br><span class="line">    method: <span class="string">'get'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `baseURL`将被添加到`url`前面，除非`url`是绝对的。</span></span><br><span class="line">    <span class="comment">// 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。</span></span><br><span class="line">    baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `transformRequest`允许在请求数据发送到服务器之前对其进行更改</span></span><br><span class="line">    <span class="comment">// 这只适用于请求方法'PUT'，'POST'和'PATCH'</span></span><br><span class="line">    <span class="comment">// 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream</span></span><br><span class="line">    transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 做任何你想要的数据转换</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `transformResponse`允许在 then / catch之前对响应数据进行更改</span></span><br><span class="line">    transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Do whatever you want to transform the data</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `headers`是要发送的自定义 headers</span></span><br><span class="line">    headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `params`是要与请求一起发送的URL参数</span></span><br><span class="line">    <span class="comment">// 必须是纯对象或URLSearchParams对象</span></span><br><span class="line">    params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `paramsSerializer`是一个可选的函数，负责序列化`params`</span></span><br><span class="line">    <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">    paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `data`是要作为请求主体发送的数据</span></span><br><span class="line">    <span class="comment">// 仅适用于请求方法“PUT”，“POST”和“PATCH”</span></span><br><span class="line">    <span class="comment">// 当没有设置`transformRequest`时，必须是以下类型之一：</span></span><br><span class="line">    <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">    <span class="comment">// - Browser only: FormData, File, Blob</span></span><br><span class="line">    <span class="comment">// - Node only: Stream</span></span><br><span class="line">    data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `timeout`指定请求超时之前的毫秒数。</span></span><br><span class="line">    <span class="comment">// 如果请求的时间超过'timeout'，请求将被中止。</span></span><br><span class="line">    timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `withCredentials`指示是否跨站点访问控制请求</span></span><br><span class="line">    <span class="comment">// should be made using credentials</span></span><br><span class="line">    withCredentials: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `adapter'允许自定义处理请求，这使得测试更容易。</span></span><br><span class="line">    <span class="comment">// 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api））</span></span><br><span class="line">    adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `auth'表示应该使用 HTTP 基本认证，并提供凭据。</span></span><br><span class="line">    <span class="comment">// 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。</span></span><br><span class="line">    auth: &#123;</span><br><span class="line">        username: <span class="string">'janedoe'</span>,</span><br><span class="line">        password: <span class="string">'s00pers3cret'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “responseType”表示服务器将响应的数据类型</span></span><br><span class="line">    <span class="comment">// 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span></span><br><span class="line">    responseType: <span class="string">'json'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称</span></span><br><span class="line">    xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `xsrfHeaderName`是携带xsrf令牌值的http头的名称</span></span><br><span class="line">    xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `onUploadProgress`允许处理上传的进度事件</span></span><br><span class="line">    onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用本地 progress 事件做任何你想要做的</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `onDownloadProgress`允许处理下载的进度事件</span></span><br><span class="line">    onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `maxContentLength`定义允许的http响应内容的最大大小</span></span><br><span class="line">    maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `validateStatus`定义是否解析或拒绝给定的promise</span></span><br><span class="line">    <span class="comment">// HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被</span></span><br><span class="line">    <span class="comment">// 拒绝。</span></span><br><span class="line">    validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `maxRedirects`定义在node.js中要遵循的重定向的最大数量。</span></span><br><span class="line">    <span class="comment">// 如果设置为0，则不会遵循重定向。</span></span><br><span class="line">    maxRedirects: <span class="number">5</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。</span></span><br><span class="line">    <span class="comment">// 允许配置类似`keepAlive`的选项，</span></span><br><span class="line">    <span class="comment">// 默认情况下不启用。</span></span><br><span class="line">    httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 'proxy'定义代理服务器的主机名和端口</span></span><br><span class="line">    <span class="comment">// `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。</span></span><br><span class="line">    <span class="comment">// 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">        host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        port: <span class="number">9000</span>,</span><br><span class="line">        auth: : &#123;</span><br><span class="line">            username: <span class="string">'mikeymike'</span>,</span><br><span class="line">            password: <span class="string">'rapunz3l'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “cancelToken”指定可用于取消请求的取消令牌</span></span><br><span class="line">    <span class="comment">// (see Cancellation section below for details)</span></span><br><span class="line">    cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `config` 是为请求提供的配置信息</span></span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line"> <span class="comment">// 'request'</span></span><br><span class="line">  <span class="comment">// `request` is the request that generated this response</span></span><br><span class="line">  <span class="comment">// It is the last ClientRequest instance in node.js (in redirects)</span></span><br><span class="line">  <span class="comment">// and an XMLHttpRequest instance the browser</span></span><br><span class="line">  request: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="comment">//引入cookie操作依赖</span></span><br><span class="line"><span class="keyword">import</span> Cookies <span class="keyword">from</span> <span class="string">'js-cookie'</span></span><br><span class="line"><span class="comment">//引入路由对象</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'@/router/index'</span></span><br><span class="line"></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span>;</span><br><span class="line">axios.defaults.baseURL = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">config =&gt; &#123;</span><br><span class="line"><span class="keyword">var</span> token;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> Cookies.get(<span class="string">'user'</span>) === <span class="string">'undefined'</span>)&#123;</span><br><span class="line"><span class="comment">// 空</span></span><br><span class="line">token = <span class="string">''</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 登录用户，从cookie中取出token</span></span><br><span class="line">token = <span class="built_in">JSON</span>.parse(Cookies.get(<span class="string">'user'</span>).token)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加配置项</span></span><br><span class="line">config.data = <span class="built_in">JSON</span>.stringify(config.data);</span><br><span class="line">config.headers = &#123;</span><br><span class="line"><span class="string">'Content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(token != <span class="string">''</span>)&#123;</span><br><span class="line">config.headers.token = token;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line">&#125;,</span><br><span class="line">error =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">response =&gt; &#123;</span><br><span class="line"><span class="comment">// 当返回信息为未登录或者登录失效的时候重定向为登录页</span></span><br><span class="line"><span class="keyword">if</span>(response.data.code === <span class="string">'ERR_001'</span> || response.data.message === <span class="string">'用户未登录或登录超时，请登录！'</span>)&#123;</span><br><span class="line"><span class="comment">//从哪个页面跳转</span></span><br><span class="line">router.push(&#123;<span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">query</span>: &#123;<span class="attr">redirect</span>: router.currentRoute.fullPath&#125;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;,</span><br><span class="line">error =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装get方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, params=&#123;&#125;</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">axios.get(url, &#123;</span><br><span class="line"><span class="comment">// 上送参数</span></span><br><span class="line">paramKey: paramVal</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">resolve(response.data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装post请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">url, data=&#123;&#125;</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">axios.post(url, data)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">resolve(response.data);</span><br><span class="line">&#125;,err =&gt; &#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装导出excel文件请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">exportExcel</span>(<span class="params">url, data=&#123;&#125;</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">axios(&#123;</span><br><span class="line">method: <span class="string">'post'</span>,</span><br><span class="line">url: url,</span><br><span class="line">data: data,</span><br><span class="line">responseType: <span class="string">'blob'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">resolve(response.data);</span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([response.data], &#123;<span class="attr">type</span>: <span class="string">"application/vnd.ms-excel"</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> fileName = <span class="string">'订单列表_'</span> + <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">'.xls'</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.navigator.msSaveOrOpenBlob)&#123;</span><br><span class="line">navigator.msSaveBlob(blob, fileName);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">link.href = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">link.download = fileName;</span><br><span class="line">link.click();</span><br><span class="line"><span class="built_in">window</span>.URL.revokeObjectURL(link.href);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装patch请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">url,data = &#123;&#125;</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">axios.patch(url,data)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">resolve(response.data);</span><br><span class="line">&#125;,err =&gt; &#123;</span><br><span class="line">reject(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装put请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">url,data = &#123;&#125;</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">axios.put(url,data)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">resolve(response.data);</span><br><span class="line">&#125;,err =&gt; &#123;</span><br><span class="line">reject(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由拦截"><a href="#路由拦截" class="headerlink" title="路由拦截"></a>路由拦截</h2><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">"element-ui"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局前置守卫 —— 路由拦截</span></span><br><span class="line"><span class="comment">// 在路由meta添加添加一个字段requireLogin,设置为true的时候</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// to.matched 的数组，如果在mate中有requireLogin，那么就返回true</span></span><br><span class="line">    <span class="comment">// 包含当前路由的所有嵌套路径片段的路由记录</span></span><br><span class="line">    <span class="comment">// ES6语法：some一真即真，every一假即假</span></span><br><span class="line">    <span class="comment">// 箭头函数：`var f = v =&gt; v` === `var f = function(v)&#123;return v;&#125;`</span></span><br><span class="line">    <span class="keyword">if</span>(to.matched.some(<span class="function"><span class="params">res</span> =&gt;</span> res.meta.requireLogin))&#123;</span><br><span class="line">        <span class="comment">// 判断是否需要登录权限</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.localStorage.getItem(<span class="string">"loginUserBaseInfo"</span>)) &#123;</span><br><span class="line">          <span class="comment">// 判断是否登录</span></span><br><span class="line">          <span class="keyword">let</span> lifeTime =</span><br><span class="line">            <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">"loginUserBaseInfo"</span>)).lifeTime *</span><br><span class="line">            <span class="number">1000</span>;</span><br><span class="line">          <span class="keyword">let</span> nowTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime(); <span class="comment">// 当前时间的时间戳</span></span><br><span class="line">          <span class="keyword">if</span> (nowTime &lt; lifeTime) &#123;</span><br><span class="line">            next();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message(&#123;</span><br><span class="line">              showClose: <span class="literal">true</span>,</span><br><span class="line">              message: <span class="string">"登录状态信息过期,请重新登录"</span>,</span><br><span class="line">              type: <span class="string">"error"</span></span><br><span class="line">            &#125;);</span><br><span class="line">            next(&#123;</span><br><span class="line">              path: <span class="string">"/login"</span></span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 没登录则跳转到登录界面</span></span><br><span class="line">          next(&#123;</span><br><span class="line">            path: <span class="string">"/login"</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;axios&quot;&gt;&lt;a href=&quot;#axios&quot; class=&quot;headerlink&quot; title=&quot;axios&quot;&gt;&lt;/a&gt;axios&lt;/h1&gt;&lt;p&gt;基于Promise的HTTP库，&lt;a href=&quot;https://github.com/axios/axios&quot; t
      
    
    </summary>
    
      <category term="web" scheme="http://gnbyj.cn/categories/web/"/>
    
    
      <category term="axios" scheme="http://gnbyj.cn/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://gnbyj.cn/2019/02/26/%5B2019-02-26%5DVuex/"/>
    <id>http://gnbyj.cn/2019/02/26/[2019-02-26]Vuex/</id>
    <published>2019-02-26T12:00:00.000Z</published>
    <updated>2019-02-27T12:24:42.580Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex</p><p>专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>；</p><p>管理应用的所有组件的状态；</p><blockquote><p>集中式存储；</p><p>以一个全局单例模式管理；</p></blockquote><p>Vuex单向数据流</p><blockquote><p><code>Vue Components</code>  –&gt; Dispatch() –&gt; <code>Actions</code>  –&gt; Commit() –&gt; <code>Mutations</code> –&gt;  Mutate() –&gt; <code>State</code> –&gt; Render() –&gt; <code>Vue Components</code></p></blockquote><p>简单的理解就是你在state中定义了一个数据之后，你可以在所在项目中的任何一个组件里进行获取、进行修改，并且你的修改可以得到全局的响应变更。 </p><p>Vuex 和单纯的全局对象有以下两点不同： </p><ol><li>Vuex 的状态存储是响应式的。 store中的状态发生变化，相应的租金啊也会相应地更新。</li><li>改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。 方便地跟踪每一个状态的变化。 </li></ol><blockquote><p>由于 store 中的状态是响应式的，</p><p>在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。</p><p>触发变化也仅仅是在组件的 methods 中提交 mutation。 </p></blockquote><p>通过在根实例中注册 <code>store</code> 选项，所有子组件都能通过 <code>this.$store</code> 访问到。</p><hr><p>在mutations中，向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>，在大多数情况下，载荷应该是一个对象。</p><p><strong>使用常量替代 Mutation 事件类型</strong></p><blockquote><p>这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">  [SOME_MUTATION] (state) &#123;</span><br><span class="line">    <span class="comment">// mutate state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一条重要的原则就是要记住 <strong>mutation 必须是同步函数</strong>。 </p><p>因为任何在回调函数中进行的状态的改变都是不可追踪的。 </p></blockquote><hr><p>不理想的获取方式：</p><p><code>this.$store.state.showFooter</code> </p><p>理想的取值方式：</p><p><code>const getters</code></p><p>在computed里：<code>return this.$store.getters.isShow;</code></p><blockquote><p>vuex官方API提供了一个getters，和vue计算属性computed一样，来实时监听state值的变化(最新状态) </p></blockquote><p>不理想的改变值的方式：</p><p><code>this.$store.commit(&#39;show&#39;)</code></p><p>理想的改变值方式：</p><p><code>this.$store.dispatch(&#39;hideFooter&#39;，arg)</code></p><blockquote><p>在 Vuex 中，mutations里面的方法 都是同步事务</p><p>Action 里面的方法是用来异步触发mutations里面的方法，我们可以在 action 内部执行<strong>异步</strong>操作，Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象和要变化的形参</p><p><code>context.state</code> / <code>context.getters</code>  / <code>context.commit</code></p></blockquote><hr><p><strong>modules 模块化 以及 组件中引入 mapGetters、mapActions 和 mapStates的使用</strong> </p><p>单独文件夹，独立的<code>state/getters/mutations/actions</code></p><p><code>namespaced:true</code>——用于在全局引用此文件里的方法时标识这个文件名</p><p>在需要用的 组件里面先导入 <code>import {mapState,mapGetters,mapActions} from &#39;vuex&#39;;</code> </p><p>辅助函数</p><blockquote><p>使用 <code>mapState</code> 辅助函数帮助我们生成计算属性 </p><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性</p><p>使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用 </p></blockquote><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对象展开运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;span @click=<span class="string">"invokePushItems(item)"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">  ...mapActions(<span class="string">'collection'</span>,[ <span class="comment">//collection是指modules文件夹下的collection.js</span></span><br><span class="line">    <span class="string">'invokePushItems'</span>  <span class="comment">//collection.js文件中的actions里的方法，在上面的@click中执行并传入实参</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  <span class="comment">// 用mapState来获取collection.js里面的state的属性值</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    arrList:<span class="function"><span class="params">state</span>=&gt;</span>state.collection.collects</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 用mapGetters来获取collection.js里面的getters</span></span><br><span class="line">  ...mapGetters(<span class="string">'collection'</span>,&#123;</span><br><span class="line">    arrList:<span class="string">'renderCollects'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vuex&lt;/p&gt;
&lt;p&gt;专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;管理应用的所有组件的状态；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集中式存储；&lt;/p&gt;
&lt;p&gt;以一个全局单例模式管理；&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="web" scheme="http://gnbyj.cn/categories/web/"/>
    
    
      <category term="Vue" scheme="http://gnbyj.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>利用ajax上传文件</title>
    <link href="http://gnbyj.cn/2019/02/26/%5B2019-02-26%5D%E5%88%A9%E7%94%A8Ajax%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://gnbyj.cn/2019/02/26/[2019-02-26]利用Ajax上传文件/</id>
    <published>2019-02-26T11:10:00.000Z</published>
    <updated>2019-02-27T07:09:58.978Z</updated>
    
    <content type="html"><![CDATA[<p>利用ajax上传文件，借助FormData对象</p><p>ajax异步上传页面不用重新刷新，体验更好</p><p><code>formData.append(&quot;myfile&quot;, document.getElementById(&quot;file1&quot;).files[0]);</code></p><p>之后通过XHR对象 send() 出去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;file upload&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">    &lt;p&gt;上传文件：&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input id="cont" type="file" placeholder="请选择文件"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onclick="UploadFile()"&gt;上传&lt;/</span>button&gt;</span><br><span class="line">    &lt;button onclick=<span class="string">"cancleUploadFile()"</span>&gt;取消&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">UploadFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cont = <span class="built_in">document</span>.getElementById(<span class="string">"cont"</span>).files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// FormData对象</span></span><br><span class="line">    <span class="keyword">var</span> form = <span class="keyword">new</span> FormData();</span><br><span class="line">    form.append(<span class="string">"file"</span>, cont);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xhr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.onload = uploadComplete; <span class="comment">//请求完成</span></span><br><span class="line">    xhr.onerror =  uploadFailed; <span class="comment">//请求失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> url =  <span class="string">"http://localhost:8080"</span> + <span class="string">"/api/attachment/upload"</span>;</span><br><span class="line">    xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded; charset=utf-8");</span></span><br><span class="line">    <span class="comment">// xhr.setRequestHeader("Content-type","application/json; charset=utf-8");</span></span><br><span class="line">    xhr.send(form);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//xhr.onreadystatechange = function()&#123;</span></span><br><span class="line">    <span class="comment">//if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span></span><br><span class="line">    <span class="comment">//console.log(xhr.responseText);</span></span><br><span class="line">    <span class="comment">//console.log(xhr.responseXML);</span></span><br><span class="line">    <span class="comment">//console.log(xhr.statusText);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传成功响应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadComplete</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//服务断接收完文件返回的结果</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(evt.target.responseText);</span><br><span class="line">    <span class="keyword">if</span>(data.success) &#123;</span><br><span class="line">        alert(<span class="string">"上传成功！"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">"上传失败！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上传失败</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadFailed</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"上传失败！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消上传</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancleUploadFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    xhr.abort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用ajax上传文件，借助FormData对象&lt;/p&gt;
&lt;p&gt;ajax异步上传页面不用重新刷新，体验更好&lt;/p&gt;
&lt;p&gt;&lt;code&gt;formData.append(&amp;quot;myfile&amp;quot;, document.getElementById(&amp;quot;file1
      
    
    </summary>
    
      <category term="web" scheme="http://gnbyj.cn/categories/web/"/>
    
    
      <category term="javascript" scheme="http://gnbyj.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://gnbyj.cn/2019/02/26/%5B2019-02-26%5DAjax/"/>
    <id>http://gnbyj.cn/2019/02/26/[2019-02-26]Ajax/</id>
    <published>2019-02-26T09:43:00.000Z</published>
    <updated>2019-02-27T07:19:01.309Z</updated>
    
    <content type="html"><![CDATA[<p>AJAX——Asynchronous JavaScript and XML</p><p>一种<strong>创建交互式网页应用的网页开发技术</strong></p><p>客户端与服务器，可以在【不刷新整个浏览器】的情况下，与服务器进行异步通讯</p><p>传统Web应用——<strong>Servlet通过转发把数据发送给浏览器</strong>，直发服务器</p><p>AJAX——<strong>服务器并不是以转发的方式响应，而是以流的方式把数据返回给浏览器</strong>，经过XHR封装</p><blockquote><p>XMLHttpRequest异步对象会不停监听服务器状态的变化，得到服务器返回的数据，就写到浏览器上。</p></blockquote><p>XMLHttpRequest使用JavaScript向服务器发送请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，可以在页面加载以后进行页面的局部更新。</p><p>流程：</p><ol><li>创建XMLHttpRequest对象，也就是创建一个异步调用对象.</li><li>创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息.</li><li>设置响应HTTP请求状态变化的函数.</li><li>发送HTTP请求.</li><li>获取异步调用返回的数据.</li><li>使用JavaScript和DOM实现局部刷新.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="comment">// 利用所有现代浏览器内部的对象-XMLHttpRequest-来实现发送和接收HTTP请求与响应信息。</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">  <span class="comment">//IE7+,...</span></span><br><span class="line">  xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//IE6,IE5</span></span><br><span class="line">  xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用open(method,url,async) 方法准备好一个请求，async表示同步还是异步，默认为true(异步)；</span></span><br><span class="line">xhr.open(<span class="string">"POST"</span>,<span class="string">"/bank/rich.do"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用open()方法后，XMLHttpRequest对象把它的readyState属性设置为1(打开)并且把responseText、responseXML、status和statusText属性复位到它们的初始值。另外，它还复位请求头部。</span></span><br><span class="line"><span class="comment">// 注意，如果你调用open()方法并且此时readyState为4，则XMLHttpRequest对象将复位这些值。</span></span><br><span class="line"><span class="comment">// 设置请求的头部信息，必须写在open和send中间</span></span><br><span class="line"><span class="comment">// 使用post方式才会使用到，get方法并不需要调用该方法</span></span><br><span class="line"><span class="comment">// 如果在send(data)方法中的data参数的类型为DOMString，那么，数据将被编码为UTF-8。</span></span><br><span class="line"><span class="comment">// 如果数据是Document类型，那么将使用由data.xmlEncoding指定的编码串行化该数据。</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当readyState值为1时，才可以调用send()方法；否则的话，XMLHttpRequest对象将引发一个异常。</span></span><br><span class="line"><span class="comment">// XMLHttpRequest对象的send()方法可以立即返回，从而让Web页面上的其它HTML/JavaScript继续其浏览器端处理而由服务器处理HTTP请求并发送响应。即Async</span></span><br><span class="line"><span class="comment">// 如果是get方式，并不需要填写参数，或填写null</span></span><br><span class="line"><span class="comment">// 如果是post方式，把要提交的参数写上去</span></span><br><span class="line">xhr.send(<span class="string">"name=王大锤&amp;sex=男"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用send()方法后，XMLHttpRequest对象把readyState的值设置为2(发送)。</span></span><br><span class="line"><span class="comment">// 当服务器响应时，在接收消息体之前，如果存在任何消息体的话，XMLHttpRequest对象将把readyState设置为3(正在接收中)。</span></span><br><span class="line"><span class="comment">// 当请求完成加载时，它把readyState设置为4(已加载)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xhr激发一个readystatechange事件，设置状态监听，指定回调函数</span></span><br><span class="line"><span class="comment">// getAllResponseHeader()：获取所有的响应报头。</span></span><br><span class="line"><span class="comment">// getResponseHeader()：查询响应中的某个字段的值。readyState==3|4时调用才有意义。</span></span><br><span class="line"><span class="comment">// abort()：暂停异步HTTP请求，复位到未初始化状态。</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// readyState属性：0/1/2/3/4, 描述对象的当前状态</span></span><br><span class="line">  <span class="comment">// 0："未初始化"状态，已经创建一个XMLHttpRequest对象，但是还没有初始化。</span></span><br><span class="line">  <span class="comment">// 1："发送"状态，open()已经调用，也准备好发送请求。</span></span><br><span class="line">  <span class="comment">// 2："发送"状态，已通过send()发送请求，但还没有收到一个响应。</span></span><br><span class="line">  <span class="comment">// 3："正在接收"状态，已经接收到HTTP响应头部信息，但是消息体部分还没有完全接收。</span></span><br><span class="line">  <span class="comment">// 4："已加载"状态，响应已经被完全接收。</span></span><br><span class="line">  <span class="comment">// status：以数字返回http状态码。</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="comment">// statusText文本形式返回http状态码</span></span><br><span class="line">    xhr.statusText</span><br><span class="line">    <span class="comment">// responseText:获得字符串形式的相应数据(Content-Type)，完整的响应信息。</span></span><br><span class="line">    xhr.responseText</span><br><span class="line">    <span class="comment">// responseXML:获得XML形式的相应数据，否则为null。</span></span><br><span class="line">    xhr.responseXML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何解决跨域问题?</p><p>同源策略</p><p>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。 所谓同源指的是：协议，域名，端口相同，<strong>同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性</strong>。 </p><p><strong>协议、域名、端口都相同才同域，否则都是跨域</strong></p><p>出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容。</p><ul><li>可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据<strong>【JSONP】</strong></li><li>在后端上配置可跨域<strong>【CORS方式】</strong></li><li>前端ajax请求的是本地接口，本地接口接收到请求后向实际的接口请求数据，然后再将信息返回给前端<strong>【代理方式】</strong></li></ul><p>异步加载JS</p><ol><li>动态插入 script 标签</li><li>通过 ajax 去获取 js 代码，然后通过 eval 执行</li><li>script 标签上添加 defer 或者 async 属性</li><li>创建并插入 iframe，让它异步执行 js</li></ol><p>解决浏览器缓存</p><ul><li>在ajax发送请求前加上 <code>xhr.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)</code></li><li>在ajax发送请求前加上 <code>xhr.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)</code></li><li>在URL后面加上一个随机数： <code>&quot;fresh=&quot; + Math.random()</code></li><li>在URL后面加上时间戳：<code>&quot;nowtime=&quot; + new Date().getTime();</code></li><li>如果是使用jQuery，直接这样就可以了 <code>$.ajaxSetup({cache:false})</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">    beforeSend:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//每次ajax请求前执行的操作;</span></span><br><span class="line">&#125;,</span><br><span class="line">    complete:<span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest,textStatus</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//判断cookie中存储cookie的时间是否临近超时时刻了</span></span><br><span class="line">        <span class="comment">//如果临近的话  发送刷新token的请求; 存储新的token并且记录当前时刻</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AJAX——Asynchronous JavaScript and XML&lt;/p&gt;
&lt;p&gt;一种&lt;strong&gt;创建交互式网页应用的网页开发技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端与服务器，可以在【不刷新整个浏览器】的情况下，与服务器进行异步通讯&lt;/p&gt;
&lt;p&gt;传统Web
      
    
    </summary>
    
      <category term="frontend" scheme="http://gnbyj.cn/categories/frontend/"/>
    
      <category term="web" scheme="http://gnbyj.cn/categories/frontend/web/"/>
    
    
      <category term="Ajax" scheme="http://gnbyj.cn/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://gnbyj.cn/2019/02/26/%5B2019-02-26%5DVue/"/>
    <id>http://gnbyj.cn/2019/02/26/[2019-02-26]Vue/</id>
    <published>2019-02-26T09:00:00.000Z</published>
    <updated>2019-02-28T10:00:05.310Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/59fa9257f265da43062a1b0e" target="_blank" rel="noopener">Vue 高频问题汇总</a></p><hr><h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><blockquote><p>从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程。  </p></blockquote><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><p>【创建】</p><ul><li>创建Vue空实例</li></ul><p>【初始化】</p><ul><li><code>init</code>过程中调用【<code>beforeCreate</code>】钩子函数；</li><li><p><code>init</code>完成之后，Vue实例被正式创建。【以上是默认操作】</p></li><li><p>调用【<code>created</code>】钩子函数，经行【自定义】的初始化操作；</p></li></ul><p>【编译模板】</p><ul><li><code>Has el option</code>/<code>Has template option</code></li><li>将data中的数据和模板编译生成render function</li><li>调用【<code>beforeMount</code>】钩子函数</li></ul><p>【挂载DOM】</p><ul><li>用 Virtual DOM 的<code>$el</code>替换掉<code>el</code>属性</li><li>调用【<code>mounted</code>】钩子函数，此时可以操作DOM</li></ul><p>【双向数据绑定】</p><ul><li>数据变化，此时会调用【<code>beforeUpdate</code>】钩子函数</li><li>Virtual DOM重新渲染并打补丁</li><li>页面更新后，调用【<code>updated</code>】钩子函数</li></ul><p>【销毁】</p><ul><li>触发vm.$destroy()后，调用【<code>beforeDestroy】</code>钩子函数</li><li>卸载watchers/子组件/事件监听</li><li>调用【<code>destroyed</code>】钩子函数</li><li>销毁Vue实例</li></ul><h4 id="白话复述："><a href="#白话复述：" class="headerlink" title="白话复述："></a>白话复述：</h4><blockquote><p>创建的对象一般都需要进行一系列初始化动作之后才可被使用；<br>自定义的初始化动作可以在<code>created</code>里定义，会被Vue调用执行；<br>初始化完成，将模板和数据结合在一起，编译成render函数，渲染出虚拟DOM；<br>将虚拟DOM挂载到el上，之后DOM操作可被使用，通过<code>mounted</code>钩子函数；<br>监听数据变化，重渲染页面（之前之后有两个钩子函数可供使用）；<br>销毁实例，卸载监听及子组件（之前之后有两个钩子函数可供使用）；</p></blockquote><h4 id="8个-4对-钩子函数："><a href="#8个-4对-钩子函数：" class="headerlink" title="8个/4对 钩子函数："></a>8个/4对 钩子函数：</h4><ul><li>实例创建阶段：【beforeCreate】/【created】</li><li>DOM挂载阶段：【beforeMount】/【mounted】</li><li>页面更新阶段：【beforeUpdate】/【updated】</li><li>实例销毁阶段：【beforeDestroy】/【destroyed】</li></ul><h4 id="虚拟DOM节点树"><a href="#虚拟DOM节点树" class="headerlink" title="虚拟DOM节点树"></a>虚拟DOM节点树</h4><p>Template –&gt; <code>compile</code> –&gt; render function –&gt; <code>render</code>  –&gt; 虚拟DOM Tree  –&gt; <code>create</code>  –&gt; 真实DOM</p><p><code>vdom</code>很好的将<code>dom</code>做了一层映射关系，将我们本需要直接操作<code>dom</code>的动作映射到了操作<code>vdom</code>，</p><p><code>vdom</code>上定义了关于真实<code>dom</code>的一些关键的信息，</p><p><code>vdom</code>完全是用<code>js</code>去实现，和宿主浏览器没有任何联系，</p><p><code>js</code>的执行速度快，操作<code>vdom</code>的效率和性能要比直接操作<code>dom</code>好很多。</p><hr><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 隐藏未编译的Mustache标签直到准备完毕</span><br><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/59fa9257f265da43062a1b0e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue 高频问题汇总&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Vue的生命周期&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="web" scheme="http://gnbyj.cn/categories/web/"/>
    
    
      <category term="Vue" scheme="http://gnbyj.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://gnbyj.cn/2019/02/26/%5B2019-02-26%5DHTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://gnbyj.cn/2019/02/26/[2019-02-26]HTTP协议/</id>
    <published>2019-02-26T06:00:00.000Z</published>
    <updated>2019-02-26T09:41:20.312Z</updated>
    
    <content type="html"><![CDATA[<p>HyperText Transfer Protocol，超文本传输协议</p><p>基于TCP/IP通信协议  应用层协议 </p><p>C/S架构模型，支持B/S及C/S模式 </p><p>客户端发起<u>请求</u>，服务端作出<u>响应</u></p><p>http：80，https：443</p><blockquote><p>是无连接的——限制每次连接只处理一个请求，应答后即断开连接。</p><p>是媒体独立的——客户端以及服务器指定使用适合的MIME-type内容类型。 </p><p>是无状态的——对于事务处理没有记忆能力，服务器应答就快，信息重传。</p></blockquote><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, <strong>URI</strong>）来传输数据和建立连接。 </p><p>协议部分(http:) + // +  域名部分 + “:” + 端口部分 + 虚拟目录部分(^\/*\/$) + 文件名部分(^\/*\?$) + 锚部分(#) + 参数部分(?params)</p><p>请求：</p><blockquote><p>请求行（request line）：请求方法+URL+协议版本</p><p>请求头部（header）：头部字段名：值</p><p>空行</p><p>请求数据 </p></blockquote><p>响应：</p><blockquote><p>状态行：协议版本+状态码+状态信息</p><p>消息报头</p><p>空行</p><p>响应正文</p></blockquote><p>GET——请求指定的页面信息，并返回实体主体<br>POST——向指定资源提交数据进行处理请求</p><p>GET和POST的区别</p><ol><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456；POST方法是把提交的数据放在HTTP包的Body中。</p></li><li><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码</p></li></ol><p>HTTP响应头信息：</p><p>Allow——服务器支持哪些请求方法</p><p>Content-Encoding——文档的编码（Encode）方法 </p><p>Accept-Encoding —— 是否支持gzip </p><p>Content-Type——内容类型，MIME类型</p><p>Last-Modified —— 文档的最后改动时间</p><p>Expires —— 应该在什么时候认为文档已经过期 </p><p>HTTP状态码：</p><table><thead><tr><th>状态码</th><th>en</th><th>cn</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动， 浏览器会自动定向到新URI</td></tr><tr><td>302</td><td>Found</td><td>临时移动， 客户端应继续使用原有URI</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改， 不会返回任何资源</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向， 使用GET请求重定向</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr></tbody></table><p>Content-Type</p><p>内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码</p><p>数据发送出去后，需要接收的服务端解析成功，一般服务端会根据content-type字段来获取参数是怎么编码的，然后对应去解码。 </p><p>参数都是通过浏览器的url传递，形式如<code>key=&amp;value=</code> , <code>Content-Type:application/x-www-form-urlencoded</code>；</p><p>1995年content-type扩充了<code>multipart/form-data，</code>，用以支持向服务器发送<strong>二进制</strong>数据，即<strong>文件上传</strong>；</p><p>后来随着web应用的增多，增加了诸如<code>application/json</code>的类型，告诉服务端消息主体是序列化的json字符串。 </p><p>请求头：</p><blockquote><p>Accept: text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, <em>/</em>; q=0.01</p><p>Accept-Encoding: gzip, deflate, br</p><p>Accept-Language: zh-CN,zh;q=0.9</p><p>Connection: keep-alive</p><p>Cookie: BAIDUID=5E9C0A30BBD69B19823410F5F7D19CEB:FG=1; PSTM=1551056481; BIDUPSID=52D1C39C7B361613E19FB74BB6B54004; BD_UPN=12314753; ispeed_lsm=2; delPer=0; BD_HOME=0; H_PS_PSSID=1468_21117_28558_28415; BD_CK_SAM=1; PSINO=1; H_PS_645EC=895fkvxFXCrFRlZU9gh5ILQFSoJDjo5htE2G%2F2kKJ6PYRdCbRoUoY6TCHCc</p><p>Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>Referer: <a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=content-type&amp;rsv_pq=e82fd81000073bed&amp;rsv_t=febcRU%2BTelFRV0MEnnta3HFttJFHqv1gWiqY2TM6SVR0oblSxSTdzQ5zvgc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=13&amp;rsv_sug2=0&amp;inputT=3835&amp;rsv_sug4=5320" target="_blank" rel="noopener">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=content-type&amp;rsv_pq=e82fd81000073bed&amp;rsv_t=febcRU%2BTelFRV0MEnnta3HFttJFHqv1gWiqY2TM6SVR0oblSxSTdzQ5zvgc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=13&amp;rsv_sug2=0&amp;inputT=3835&amp;rsv_sug4=5320</a></p><p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36</p><p>X-Requested-With: XMLHttpRequest</p></blockquote><p>响应头：</p><blockquote><p>Cache-Control: private</p><p>Content-Encoding: gzip</p><p>Content-Length: 361</p><p>Content-Type: baiduApp/json; v6.27.2.14; charset=UTF-8</p><p>Date: Tue, 26 Feb 2019 07:19:45 GMT</p><p>Expires: Tue, 26 Feb 2019 08:19:45 GMT</p><p>Server: suggestion.baidu.zbb.df</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HyperText Transfer Protocol，超文本传输协议&lt;/p&gt;
&lt;p&gt;基于TCP/IP通信协议  应用层协议 &lt;/p&gt;
&lt;p&gt;C/S架构模型，支持B/S及C/S模式 &lt;/p&gt;
&lt;p&gt;客户端发起&lt;u&gt;请求&lt;/u&gt;，服务端作出&lt;u&gt;响应&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;h
      
    
    </summary>
    
      <category term="frontend" scheme="http://gnbyj.cn/categories/frontend/"/>
    
      <category term="web" scheme="http://gnbyj.cn/categories/frontend/web/"/>
    
    
      <category term="HTTP" scheme="http://gnbyj.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Router</title>
    <link href="http://gnbyj.cn/2019/02/26/%5B2019-02-26%5DVue-Router/"/>
    <id>http://gnbyj.cn/2019/02/26/[2019-02-26]Vue-Router/</id>
    <published>2019-02-26T01:27:00.000Z</published>
    <updated>2019-02-27T01:10:54.353Z</updated>
    
    <content type="html"><![CDATA[<p>Vue + Vue-Router步骤：</p><ol><li><p>如果使用模块化机制编程，导入Vue和VueRouter，调用 Vue.use(VueRouter)；</p></li><li><p>定义 (路由) 组件，可以从其他文件import进来；</p></li><li><p>定义路由，每个路由映射一个组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Routers = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/index'</span>, <span class="comment">// 匹配路径</span></span><br><span class="line">        component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./views/index.vue'</span>], resolve) <span class="comment">// 映射组件</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/about'</span>,</span><br><span class="line">        component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./views/about.vue'</span>], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>require.ensure()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Province = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'@/components/Province.vue'</span>)), <span class="string">'chunkname1'</span>)</span><br><span class="line"><span class="keyword">const</span> Segment = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'@/components/Segment.vue'</span>)), <span class="string">'chunkname2'</span>)</span><br><span class="line"><span class="keyword">const</span> Loading = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'@/components/Loading.vue'</span>)), <span class="string">'chunkname3'</span>)</span><br><span class="line"><span class="keyword">const</span> User = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'@/components/User.vue'</span>)), <span class="string">'chunkname3'</span>)</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://blog.csdn.net/qq_27626333/article/details/76228578" target="_blank" rel="noopener">https://blog.csdn.net/qq_27626333/article/details/76228578</a></p></li></ol><ol start="4"><li><p>创建router实例，传入routes配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RouterConfig = &#123;</span><br><span class="line">    mode: <span class="string">'history'</span>, <span class="comment">// 不配置mode，用 # 来设置路径</span></span><br><span class="line">    routes: Routes</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(RouterConfig)</span><br></pre></td></tr></table></figure><p>开启History路由，需将所有路由指向同一个html，webpack修改package.json文件，添加<code>--history-api-fallback</code></p></li></ol><ol start="5"><li><p>创建和挂载根实例，注入路由router</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">'#app'</span>,</span><br><span class="line">router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><code>&lt;router-view/&gt;</code> 路由视图，用于挂载路由组件</p><p>跳转（2种方法）</p><p><code>&lt;router-link to=&quot;/index&quot;&gt;go to index&lt;/router-link&gt;</code>，被渲染未\&lt;a>标签</p><p>prop：tag/replace/active-class</p><p><code>this.$router.push()/replace()/go()</code></p><p>通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由</p><blockquote><p><strong>Vue 路由中 $route 和 $router 的区别</strong><br>$route是“路由信息“对象，包括path，params，hash，query，fullPath，matched，name等路由信息参数。<br>$router是“路由实例”对象，包括路由的跳转方法，钩子函数等。</p></blockquote><p>编程式导航</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名路由，在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称name。</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果提供了 path，params 会被忽略</span></span><br></pre></td></tr></table></figure><p>导航守卫</p><p>全局前置守卫 <code>router.beforeEach((to, from, next)=&gt;{ //... })</code></p><p>全局解析守卫 <code>router.beforeResolve</code></p><p>全局后置守卫 <code>router.afterEach((to, from)=&gt;{ //... })</code></p><p><strong>路由</strong>独享的守卫 <code>beforeEnter: (to, from, next)=&gt;{ //... }</code></p><p><strong>组件</strong>内守卫 <code>beforeRouteEnter(to, from, next){ //... }</code>不能访问this，可<code>next(vm =&gt; { //vm访问组件实例 })</code></p><p><code>beforeRouteUpdate(to, from, next){ //... }</code></p><p><code>beforeRouteLeave(to, from, next){ //... }</code></p><blockquote><p>to: 即将进入的目标路由对象</p><p>from: 当前导航即将要离开的路由对象</p><p>next: 调用后才会进入下一个钩子</p></blockquote><p>改变标题，用到<code>router.beforeEach((to, from, next) =&gt; {var title = to.meta.title; next();})</code></p><p>设置滚动条位置，<code>window.scrollTo(0,0)</code></p><p>校验是否登录，已登录调用<code>next()</code>，未登录<code>next(&#39;\login&#39;)</code>或<code>next(false)</code></p><p>完整的导航解析流程</p><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue + Vue-Router步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果使用模块化机制编程，导入Vue和VueRouter，调用 Vue.use(VueRouter)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义 (路由) 组件，可以从其他文件import进来；&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="frontend" scheme="http://gnbyj.cn/categories/frontend/"/>
    
      <category term="web" scheme="http://gnbyj.cn/categories/frontend/web/"/>
    
    
      <category term="Vue" scheme="http://gnbyj.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Windows解决端口占用问题</title>
    <link href="http://gnbyj.cn/2019/02/26/%5B2019-02-26%5DWindows%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/"/>
    <id>http://gnbyj.cn/2019/02/26/[2019-02-26]Windows系统解决端口被占用/</id>
    <published>2019-02-26T01:10:00.000Z</published>
    <updated>2019-02-26T01:12:27.247Z</updated>
    
    <content type="html"><![CDATA[<ol><li>在dos下，输入<code>netstat -ano|findstr [port]</code>,查看端口使用情况</li><li>输入 <code>taskkill /pid [pid] /f</code> 停止端口占用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;在dos下，输入&lt;code&gt;netstat -ano|findstr [port]&lt;/code&gt;,查看端口使用情况&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;taskkill /pid [pid] /f&lt;/code&gt; 停止端口占用&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="common" scheme="http://gnbyj.cn/categories/common/"/>
    
    
      <category term="web" scheme="http://gnbyj.cn/tags/web/"/>
    
      <category term="system" scheme="http://gnbyj.cn/tags/system/"/>
    
      <category term="port" scheme="http://gnbyj.cn/tags/port/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件</title>
    <link href="http://gnbyj.cn/2019/02/26/%5B2019-02-26%5DVue%E7%BB%84%E4%BB%B6/"/>
    <id>http://gnbyj.cn/2019/02/26/[2019-02-26]Vue组件/</id>
    <published>2019-02-26T01:10:00.000Z</published>
    <updated>2019-02-26T16:06:43.357Z</updated>
    
    <content type="html"><![CDATA[<p>……</p><p>Vue组件传值形式：</p><ul><li>父子组件通信</li><li>兄弟组件通信</li><li>跨级组件通信</li></ul><ol><li><p>params</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// params传值 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>query</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query传值 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>props 父级 -&gt; 子级</p><p><code>v-bind:data</code></p><p>props：字符串数组形式/对象形式</p><p>对象形式，可对传入数据验证类型type，默认值default，是否必输required</p></li></ol><ol start="4"><li><p>$emit 父级监听子级触发的自定义事件</p><p>子组件<code>$emit()</code> 父组件<code>v-on:事件</code></p></li></ol><ol start="5"><li><p>bus中央总线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'m-com'</span>,&#123;</span><br><span class="line">    method: &#123;</span><br><span class="line">        xxx: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        bus.$emit(<span class="string">'msg'</span>,<span class="string">''</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        bus.$on(<span class="string">'msg'</span>,cb())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>$refs 子组件索引</p><p>在子组件上设置属性<code>ref=&quot;comA&quot;</code></p><p>在实例方法属性中：通过 <code>$refs</code> 来访问指定的实例</p><blockquote><p><code>$refs</code> 只在组件渲染完成后才填充，应当避免在模板或计算属性中使用</p></blockquote></li></ol><ol start="7"><li><p>父链 (不推荐使用)</p><p><code>this.$parent</code>: 可以直接访问该组件的父实例或组件</p><p><code>this.$children</code>: 父组件访问它所有的子组件</p></li></ol><ol start="8"><li>vuex</li></ol><hr><p>slot 内容分发</p><p>作用域：</p><p>父组件模板的内容是在父组件作用域内编译；</p><p>子组件模板的内容是在子组件作用域内编译。</p><blockquote><p>slot分发的内容，作用域是在父组件上。</p></blockquote><p>用法：</p><p>在子组件内使用特殊的\&lt;slot>元素为子组件开启一个slot插槽，</p><p>在父组件模板里的内容将替代子组件slot标签及其内容。</p><p>具名slot</p><p>在父组件内容中添加类似属性<code>slot=&quot;header&quot;</code></p><p>在子组件<code>template</code>中定义<code>&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</code></p><p>作用域插槽</p><p>父组件定义 <code>scope=&quot;props&quot;</code>，通过临时变量props访问子组件数据<code>props.bookName</code></p><p>子组件slot上对外暴露变量<code>&lt;slot :book-name=&quot;book.name&quot;&gt;</code></p><blockquote><p>$slot 访问某个具名slot</p></blockquote><blockquote><p>$nextTick(callback()) 就是用来知道什么时候DOM更新完成的</p></blockquote><p><code>Vue.extend({ // 组件选项 })</code> 基础Vue构造器，创造一个“子类”。</p><p><code>$mount()</code>手动挂载一个未挂载的实例</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;……&lt;/p&gt;
&lt;p&gt;Vue组件传值形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父子组件通信&lt;/li&gt;
&lt;li&gt;兄弟组件通信&lt;/li&gt;
&lt;li&gt;跨级组件通信&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;params&lt;/p&gt;
&lt;figure class=&quot;highlight javas
      
    
    </summary>
    
      <category term="web" scheme="http://gnbyj.cn/categories/web/"/>
    
    
      <category term="Vue，web" scheme="http://gnbyj.cn/tags/Vue%EF%BC%8Cweb/"/>
    
  </entry>
  
  <entry>
    <title>响应式布局设计</title>
    <link href="http://gnbyj.cn/2019/02/21/%5B2019-02-21%5D%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/"/>
    <id>http://gnbyj.cn/2019/02/21/[2019-02-21]响应式布局设计/</id>
    <published>2019-02-21T04:30:00.000Z</published>
    <updated>2019-02-22T01:25:58.886Z</updated>
    
    <content type="html"><![CDATA[<p>响应式布局设计步骤：</p><ol><li><p>设置meta标签，禁止页面缩放</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过媒介查询设置样式</p><p>根据条件告诉浏览器如何渲染页面</p><p>在link中使用@media</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"1.css"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width:1000px)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在样式表中内嵌@media</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width:<span class="number">980px</span>) &#123;</span><br><span class="line">    <span class="selector-id">#head</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span> &#125;</span><br><span class="line"><span class="selector-id">#content</span> &#123; <span class="attribute">width</span>: <span class="number">50%</span>; &#125;</span><br><span class="line"><span class="comment">/* 图片超过了，就缩小。假如图片小了，就原尺寸输出。 */</span></span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">width</span>: auto; <span class="attribute">max-width</span>: <span class="number">100%</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置多种视图宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* iPad */</span></span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">768px</span>) and (max-width: <span class="number">1024px</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* iPhone */</span></span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">320px</span>) and (max-width: <span class="number">767px</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;响应式布局设计步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设置meta标签，禁止页面缩放&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
      <category term="frontend" scheme="http://gnbyj.cn/categories/frontend/"/>
    
    
      <category term="web" scheme="http://gnbyj.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>web前端开发知识汇总</title>
    <link href="http://gnbyj.cn/2019/02/19/%5B2019-02-19%5Dweb%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>http://gnbyj.cn/2019/02/19/[2019-02-19]web前端知识汇总/</id>
    <published>2019-02-19T04:30:00.000Z</published>
    <updated>2019-02-26T08:35:42.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精通浏览器兼容性调优"><a href="#精通浏览器兼容性调优" class="headerlink" title="精通浏览器兼容性调优"></a>精通浏览器兼容性调优</h1><p>(参考：<a href="https://blog.csdn.net/garvisjack/article/details/69939203" target="_blank" rel="noopener">https://blog.csdn.net/garvisjack/article/details/69939203</a>)</p><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p>品牌Chrome FireFox IE等/运行平台windows MAC Android IOS/内核webkit gecko/屏幕分辨率/版本等；</p><h3 id="内核："><a href="#内核：" class="headerlink" title="内核："></a>内核：</h3><p>Trident(IE系)/Gecko(Firefox)/<del>Presto</del>/Webkit(Safari android原生)/Blink(Chrome Opera)/edge(&gt;IE11)</p><p>根据浏览器份额等数据，我们在针对PC Web开发时需要重点关注Chrome、IE浏览器，开发Mobile项目时要重点关注Chrome浏览器与Safari。 </p><h3 id="兼容性一般标准"><a href="#兼容性一般标准" class="headerlink" title="兼容性一般标准"></a>兼容性一般标准</h3><ol><li>在不同的主流的浏览器上表现效果一致</li><li>能适应不同的屏幕大小</li><li>能适应不同的分辨率与色彩深度</li></ol><h3 id="兼容性主要考虑"><a href="#兼容性主要考虑" class="headerlink" title="兼容性主要考虑"></a>兼容性主要考虑</h3><ol><li>CSS兼容</li><li>JavaScript兼容</li><li>Html兼容</li></ol><hr><h3 id="CSS兼容"><a href="#CSS兼容" class="headerlink" title="CSS兼容"></a>CSS兼容</h3><h4 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h4><p>每种浏览器都有一套默认的样式表，即user agent stylesheet；</p><p>很大可能上这些默认样式是不同的；</p><p>CSS Reset 可以将所有浏览器默认样式设置成一样的，避免很多兼容问题。</p><p><code>https://cssreset.com/</code></p><h4 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h4><p>号称是CSS reset的替代方案，保留了一些内置的样式，并不是清除所有。</p><p><code>http://necolas.github.io/normalize.css/</code></p><h4 id="CSS-Hack"><a href="#CSS-Hack" class="headerlink" title="CSS Hack"></a>CSS Hack</h4><p><a href="http://browserhacks.com/" target="_blank" rel="noopener">http://browserhacks.com/</a></p><p>针对不同的浏览器或不同版本浏览器写<strong>特定的CSS样式</strong>达到让浏览器兼容的过程。</p><h5 id="1-IE条件注释法"><a href="#1-IE条件注释法" class="headerlink" title="1. IE条件注释法"></a>1. IE条件注释法</h5><p>IE条件注释（Conditional comments）是IE浏览器私有的代码，在其它浏览器中被视为注释。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE]&gt;用于 IE &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 6]&gt;用于 IE6 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 7]&gt;用于 IE7 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 8]&gt;用于 IE8 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 9]&gt;用于 IE9 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gt IE 6]&gt; 用于 IE6 以上版本&lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lte IE 7]&gt; 用于 IE7或更低版本 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gte IE 8]&gt;用于 IE8 或更高版本 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;用于 IE9 以下版本&lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if !IE 8]&gt;用于非 IE &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--gt : greater than，选择条件版本以上版本，不包含条件版本 &gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lt : less than，选择条件版本以下版本，不包含条件版本 &lt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--gte : greater than or equal，选择条件版本以上版本，包含条件版本&gt;= --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lte : less than or equal，选择条件版本以下版本，包含条件版本 &lt;= --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--! : 选择条件版本以外所有版本，无论高低 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--*只有IE浏览器认识条件注释、其它浏览器会跳过 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-样式内属性标记法"><a href="#2-样式内属性标记法" class="headerlink" title="2. 样式内属性标记法"></a>2. 样式内属性标记法</h5><p>在CSS样式的属性名前或值后面添加特殊的字符让不同的浏览器解析 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue <span class="meta">!important</span>;<span class="comment">/*all but ie6*/</span></span><br><span class="line">    *background-color: black;/*ie6 ie7*/</span><br><span class="line">    +<span class="selector-tag">background-color</span>: <span class="selector-tag">black</span>;<span class="comment">/*ie6 ie7*/</span></span><br><span class="line">    _<span class="selector-tag">background-color</span>: <span class="selector-tag">black</span>;<span class="comment">/*ie6*/</span></span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">black</span>\9;<span class="comment">/*ie 6 7 8 9 10*/</span></span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">black</span>\0;<span class="comment">/*ie 8 9 10*/</span></span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">black</span>\9\0;<span class="comment">/*ie 9 10*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>http://browserhacks.com/</code></p><h5 id="3-选择器前缀法"><a href="#3-选择器前缀法" class="headerlink" title="3. 选择器前缀法"></a>3. 选择器前缀法</h5><p>@media screen\0{…}</p><h5 id="4-文档模式-（X-UA-Compatible）-–-降级使用"><a href="#4-文档模式-（X-UA-Compatible）-–-降级使用" class="headerlink" title="4. 文档模式 （X-UA-Compatible） – 降级使用"></a>4. 文档模式 （X-UA-Compatible） – 降级使用</h5><p>文档模式的主要作用是影响浏览器显示网页HTML的方式，用于指定IE的页面排版引擎（Trident）以哪个版本的方式来解析并渲染网页代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- x-ua-compatible 头标签大小写不敏感，必须用在 head 中，必须在除 title 外的其他 meta 之前使用。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7,9,10"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7,IE=9"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span> =<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Google Chrome Frame(谷歌内嵌浏览器框架GCF) 插件可以让用户的IE浏览器外观不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核。如果IE浏览器使用了GCF技术我们应该强制使用最新版内核，写入如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame</span><br></pre></td></tr></table></figure><p>现在多数网站这是这种写法如baidu。</p><h4 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h4><ul><li>渐进增强(progressive enhancement):  针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验</li><li>优雅降级(graceful degradation):  一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul><hr><h3 id="JavaScript兼容"><a href="#JavaScript兼容" class="headerlink" title="JavaScript兼容"></a>JavaScript兼容</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javascript判断浏览器类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBrowserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Sys = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> re = <span class="regexp">/(msie|firefox|chrome|opera|version).*?([\d.]+)/</span>;</span><br><span class="line">    <span class="keyword">var</span> m = ua.match(re);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Sys.browser = m[<span class="number">1</span>].replace(<span class="regexp">/version/</span>, <span class="string">"'safari"</span>);</span><br><span class="line">        Sys.ver = m[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"getBrowserInfo fail."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Sys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>先检测，再操作DOM</strong>。可以使用javascript操作样式与标签，强制浏览器兼容，比如先使用javascript判断浏览器类型，再操作样式与标签。</li><li><strong>对象不能使用</strong>，指javascript存在兼容问题，如一个对象在某些浏览器下没有办法使用，可以：<strong>使用兼容性做的好的第三方js库，如jQ，Zepto等</strong>；<strong>浏览器检测、重新封装</strong>。<em>使用ajax时创建XHR对象？</em></li></ol><blockquote><p>使用javascript判断浏览器类型，对一些特点的方法或对象重新封装后使用，屏蔽浏览的不兼容性。可以使用User-Agent、或特定对象。</p><p><code>navigator.userAgent</code>：在user-agent中包含有不少的客户端信息，可以解析出判断浏览器部分的内容。 </p></blockquote><h4 id="Javascript-不同浏览器差异和兼容方法"><a href="#Javascript-不同浏览器差异和兼容方法" class="headerlink" title="Javascript 不同浏览器差异和兼容方法"></a>Javascript 不同浏览器差异和兼容方法</h4><p><a href="https://caniuse.com/" target="_blank" rel="noopener">https://caniuse.com/</a></p><blockquote><p>“能力检测”：检测该浏览器是否支持该方法，若支持则使用，否则使用另一种方法。</p><p>在进行能力检测时，首先检测最常用的特性，保证代码最优化，避免测试多个条件。 </p></blockquote><h5 id="添加事件监听兼容函数"><a href="#添加事件监听兼容函数" class="headerlink" title="添加事件监听兼容函数"></a>添加事件监听兼容函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandler</span>(<span class="params">target, eventType, handler</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(target.addEventListener)&#123;<span class="comment">//主流浏览器  </span></span><br><span class="line">        addHandler = <span class="function"><span class="keyword">function</span>(<span class="params">target, eventType, handler</span>)</span>&#123;  </span><br><span class="line">            target.addEventListener(eventType, handler, <span class="literal">false</span>);  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//IE  </span></span><br><span class="line">        addHandler = <span class="function"><span class="keyword">function</span>(<span class="params">target, eventType, handler</span>)</span>&#123;  </span><br><span class="line">            target.attachEvent(<span class="string">"on"</span>+eventType, handler);  </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//执行新的函数  </span></span><br><span class="line">    addHandler(target, eventType, handler);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除事件监听兼容函数"><a href="#删除事件监听兼容函数" class="headerlink" title="删除事件监听兼容函数"></a>删除事件监听兼容函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHandler</span>(<span class="params">target, eventType, handler</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(target.removeEventListener)&#123;<span class="comment">//主流浏览器  </span></span><br><span class="line">        removeHandler = <span class="function"><span class="keyword">function</span>(<span class="params">target, eventType, handler</span>)</span>&#123;  </span><br><span class="line">            target.removeEventListener(eventType, handler, <span class="literal">false</span>);  </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//IE  </span></span><br><span class="line">        removeHandler = <span class="function"><span class="keyword">function</span>(<span class="params">target, eventType, handler</span>)</span>&#123;  </span><br><span class="line">            target.detachEvent(<span class="string">"on"</span>+eventType, handler);  </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//执行新的函数  </span></span><br><span class="line">    removeHandler(target, eventType, handler);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="event"><a href="#event" class="headerlink" title="event"></a>event</h5><p>IE和其他浏览的event对象是不同的。在其他浏览器中若要使用时，都要传入event对象，而在IE中，event却是window对象的一个属性。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理代码</span></span><br><span class="line">    event = event || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消事件的默认行为</span></span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取消事件的进一步冒泡</span></span><br><span class="line">    <span class="keyword">if</span>(event.stopPropagation)&#123;</span><br><span class="line">        event.stopPropagation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ajax-XHR对象"><a href="#ajax-XHR对象" class="headerlink" title="ajax XHR对象"></a>ajax XHR对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">  <span class="comment">//IE7+,...</span></span><br><span class="line">  xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//IE6,IE5</span></span><br><span class="line">  xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="找子标签的问题"><a href="#找子标签的问题" class="headerlink" title="找子标签的问题"></a>找子标签的问题</h5><p>问题描述:</p><p>​    1). childNodes, firstChild, lastChild会将两个标签之间的换行也当作文本节点</p><p>​    2). firstElementChild/lastElementChild在IE中只支持IE9及以上</p><p>​    3). children只包含所有的标签子节点, 在规范中没有, 但所有的浏览器都支持</p><p>解决办法:</p><p>​    1). 如果找子标签, 使用children</p><p>​    2). 如果找标签体文本, 使用innerHTML</p><h5 id="currentStyle"><a href="#currentStyle" class="headerlink" title="currentStyle"></a>currentStyle</h5><blockquote><p>问题：currentStyle,只兼容IE，在其他浏览器是不能用的。</p><p>解决方案：同时使用getComputedStyle，可以兼容Chrome、FF。</p></blockquote><h5 id="获取鼠标当前坐标"><a href="#获取鼠标当前坐标" class="headerlink" title="获取鼠标当前坐标"></a>获取鼠标当前坐标</h5><blockquote><p>IE：event.x和event.y。  </p><p>FF：event.pageX和event.pageY。  </p><p>通用：两者都有event.clientX和event.clientY属性。 </p><p><strong>鼠标当前坐标(加上滚动条滚过的距离)</strong> </p><p>IE：event.offsetX和event.offsetY。  </p><p>FF：event.layerX和event.layerY。   </p></blockquote><h2 id="H5移动端ios-Android兼容性总结"><a href="#H5移动端ios-Android兼容性总结" class="headerlink" title="H5移动端ios/Android兼容性总结"></a>H5移动端ios/Android兼容性总结</h2><p><strong>移动端点透问题</strong></p><p>touchstart 早于 touchend 早于click。 </p><ol><li>尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。</li><li>用fastclick，<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a></li><li>用preventDefault阻止a标签的click</li></ol><p><strong>input框聚焦，ios出现outline或者阴影，安卓显示正常</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:focus&#123;outline:none&#125;</span><br><span class="line">input:&#123;-webkit-appearance: none;&#125;</span><br></pre></td></tr></table></figure><p><strong>flex布局</strong></p><p>flex布局对于低版本的安卓，不支持flex-wrap:wrap属性，但是ios系统支持换行属性 </p><p><strong>ios系统，会将数字当成电话号码，导致变色</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; </span><br><span class="line">&lt;meta http-equiv=&quot;x-rim-auto-match&quot; content=&quot;none&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>禁止安卓识别email</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>input 的placeholder属性会使文本位置偏上</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line-height: （和input框的高度一样高）---pc端解决方法</span><br><span class="line">line-height：normal; ---移动端解决方法</span><br></pre></td></tr></table></figure><p><strong>input type=number之后，pc端出现上下箭头</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input::-webkit-outer-spin-button,</span><br><span class="line">input::-webkit-inner-spin-button &#123;</span><br><span class="line">    -webkit-appearance: none !important;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="为什么要做性能优化？"><a href="#为什么要做性能优化？" class="headerlink" title="为什么要做性能优化？"></a>为什么要做性能优化？</h3><p>意味着更好的用户体验，同时节约企业成本。</p><p>1、加快页面展示和运行速度；</p><p>2、节约服务器带宽流量；</p><p>3、减少服务器压力；</p><h3 id="依赖因素"><a href="#依赖因素" class="headerlink" title="依赖因素"></a>依赖因素</h3><ol><li>服务器端(代码质量等)</li><li>网络速度</li><li>客户端软硬件配置</li><li>前端资源数量、大小及js时间空间复杂度等</li></ol><h3 id="一个页面从发起请求到展示给用户大概流程："><a href="#一个页面从发起请求到展示给用户大概流程：" class="headerlink" title="一个页面从发起请求到展示给用户大概流程："></a>一个页面从发起请求到展示给用户大概流程：</h3><blockquote><p>1、DNS 查询</p><p>2、发送 HTTP 请求</p><p>3、等待服务器响应</p><p>4、下载服务器响应内容</p><p>5、解析 HTML、CSS、JS</p><p>6、渲染 HTML、CSS、JS 和图片</p><p>7、响应用户事件</p></blockquote><p>1、针对 DNS 查询优化</p><blockquote><p>减少网站所用的域名个数（现代浏览器基本都具备并行下载能），减少 DNS 查询时间；</p><p>建议一个网站使用至少 2 个域，但不多于 4 个域来提供资源；</p></blockquote><p>2、针对发送方面的请求优化</p><blockquote><p>localStorage（本地存储）静态资源打包，</p><p>开启 Gzip 压缩（节省响应流量）</p><p>Cookie 隔离（节省请求流量）</p><p>使用 CDN 加速（访问最近服务器）</p></blockquote><p>3、针对等待服务器响应方面的优化</p><blockquote><p>合理设置 HTTP 缓存：Etag 与 Cache-control</p><p>启用 HTTP/2（多路复用，并行加载）</p><p>优化数据库查询</p><p>部署负载均衡</p></blockquote><p>4、针对下载服务器响应内容优化</p><blockquote><p>用 CSS3 实现图片</p><p>对小图标进行 base64（降低请求数）</p><p>延迟(defer)加载/异步(async)加载依赖</p><p>针对解析 HTML、CSS、JS优化去掉无用的 HTML、CSS 和 JS</p><p>优化首屏时间：脚本后位置、图片压缩、懒加载</p></blockquote><p>5、针对渲染 HTML、CSS、JS 和图片优化</p><blockquote><p>最小化重绘(repaint)和回流(reflow)</p><p>批量修改元素样式</p><p>避免 table 布局等</p><p>尽量不在前端做复杂的运算</p></blockquote><h3 id="优化大方向"><a href="#优化大方向" class="headerlink" title="优化大方向"></a>优化大方向</h3><ol><li><p><strong>尽量减少HTTP请求数量</strong></p><blockquote><p>只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下的80%-90%时间花在为HTML<strong>文档所引用的所有组件</strong>（图片、脚本、样式表等）进行的HTTP请求上。 </p></blockquote><p><strong>图片地图</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"Map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"22,35,149,148"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"return show('鸟')"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"505,88,75"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"return show('奖杯')"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"168,39,392,70"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"return show('文字')"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>CSS Sprite 雪碧图</strong></p><blockquote><p>把多张细小的图片拼成一张大图片，然后通过CSS来控制在什么地方具体显示这整张图片的什么位置，使用CSS裁剪出想要的图片，这样可以减少客户端请求小图片的次数。</p></blockquote><p><strong>Data URI Scheme（内联资源）</strong></p><blockquote><p>内联资源就是将一些<strong>小的资源文件序列化成base64的编码</strong>，放在CSS样式或页面中，在客户端再解析，优点是合并了小的文件，减少请求，把二进制变成了字符串方便存储，但是会出一个没有意义的长字符串影响开发时阅读代码，另外在某些情况下将失去图片的缓存。</p></blockquote><p><strong>样式表的合并</strong></p><blockquote><p>将多个小的离散的css、js文件合并，注意粒度，把多个请求变成1个请求。</p><p>手动合并：复制粘贴</p><p>工具合并：<br>copy a.js+b.js+c.js abc.js /b<br>Jscompres<br>CssGaga</p></blockquote><p><strong>使用Web Font字体图标</strong></p><blockquote><p>使用<strong>@font-face</strong>能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体，可以实现矢量图标，一次加载反复使用多个图标，相当于图标都变成了字体。可以将多个小图标定义在一个字体中，减少图标的请求次数。</p></blockquote></li><li><p><strong>压缩</strong></p><blockquote><p>资源越小请求速度将越快，带宽占用越小，但压缩与解压也有成本。</p></blockquote><p><strong>GZIP，即网页压缩</strong></p><blockquote><p>由WEB服务器和浏览器之间共同遵守的协议，gzip压缩后对SEO不友好</p></blockquote><p><strong>开启Tomcat Gzip压缩</strong></p><blockquote><p>修改conf – server.xml</p></blockquote><p><strong>开启IIS Gzip压缩</strong></p><blockquote><p>压缩对字符很有效，但是图片因为已经是压缩格式效果不明显；</p><p>注释在发布后应该删除。</p></blockquote><p><strong>压缩javascript、css</strong></p><blockquote><p>webpack等工具</p><p>JSCompress</p><p>IDE插件</p></blockquote><p><strong>优化图像</strong></p><blockquote><p>离线工具：jpegmini.exe</p><p>在线工具：<a href="http://img.hust.cc/" target="_blank" rel="noopener">http://img.hust.cc/</a> </p><p><a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p><p><a href="http://zhitu.isux.us/" target="_blank" rel="noopener">http://zhitu.isux.us/</a></p></blockquote><p><strong>压缩HTML</strong></p><blockquote><p>去除html中的多余空格、注释等内容</p></blockquote></li><li><p><strong>缓存</strong></p><p><code>&lt;meta http-equiv=”Expires” content=”Tue, 01 Jan 2019 13:30:26 GMT” /&gt;</code></p><blockquote><p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求新内容，可以使用客户端缓存的内容，但是请求还是会发生，状态为304。浏览器会默认开启缓存功能。</p><p>Expires是HTTP 1.0中的内容，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽视。 </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”Cache-Control”</span> <span class="attr">content</span>=<span class="string">”max-age</span>=<span class="string">7200”</span> /&gt;</span> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">”Expires”</span> <span class="attr">content</span>=<span class="string">”Mon,</span> <span class="attr">20</span> <span class="attr">Jul</span> <span class="attr">2009</span> <span class="attr">23:00:00</span> <span class="attr">GMT</span>” /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>本地存储</strong></p><blockquote><p>LocalStorage、SessionStorage、Web SQL Database </p></blockquote><p><strong>离线缓存</strong></p><blockquote><p>ApplicationCache，在断开服务器时仍然可以使用客户端的缓存文件，继续浏览 </p></blockquote><p><strong>动态页面静态化</strong></p><blockquote><p>将动态内容，需要复杂计算的内容变成静态的如HTML、JavaScript ；不能静态化的部分可以使用ajax </p></blockquote></li><li><p><strong>使用内容发布网络（CDN的使用）</strong></p><blockquote><p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定，它是一个经<strong>策略性部署</strong>的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>网络请求的重定向</strong>和<strong>内容管理</strong>4个要件。</p><p><a href="http://cdn.code.baidu.com/%20" target="_blank" rel="noopener">http://cdn.code.baidu.com/ </a>百度静态资源公共库 </p></blockquote></li><li><p><strong>DNS Prefetch</strong></p><blockquote><p>DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。 </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过 link 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">link</span> <span class="attr">rel</span>=<span class="string">”dns-prefetch”</span> <span class="attr">href</span>=<span class="string">”http://api.twitter.com”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过 meta 标签设置 Http header 的 x-dns-prefetch-control 属性为 on 进行控制。 --&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">meta</span> <span class="attr">http-equiv</span>=<span class="string">”x-dns-prefetch-control”</span> <span class="attr">content</span>=<span class="string">”on”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Firefox: 3.5+ Chrome: Supported Safari 5+ IE: 9 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将CSS样式表放在顶部</strong></p><blockquote><p>CSS文件放在顶部一方面是因为放置顺序决定了下载的优先级，更关键的是浏览器的渲染机制。最理想的情况，我们希望浏览器逐渐的渲染下载好的CSS，将页面逐渐的展现给用户。但是<strong>浏览器为了避免样式变化时重新渲染绘制页面元素，会阻塞内容逐步呈现，浏览器等待所有样式加载完成之后才一次性渲染呈现页面</strong>。如此，CSS文件如果放置底部，浏览器阻止内容逐步呈现，浏览器在等待最后一个css文件下载完成的过程中，就出现了“白屏”（新打开连接时为白屏，尔后先出现文字，图片，样式最后出现）。这点非常严重，因为在网速非常慢的情况下，css下载时间比较长，这样就给用户带来“白屏”的时间自然也就很长了，用户体验非常差。</p></blockquote></li><li><p><strong>将javascript脚本放在底部</strong></p><blockquote><p>参考：<a href="https://www.cnblogs.com/xuzhengguo/p/10004563.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuzhengguo/p/10004563.html</a></p><p>将脚本从页面的顶部移到底部，会使页面既可以逐步呈现，也可以提高下载的并行度。将脚本放在页面越靠下的地方，意味着越多的内容能够逐步呈现。</p><p>脚本会阻塞对其后面内容的呈现；脚本会阻塞对其后面组件的下载。</p><p>HTTP1.1规范：建议浏览器从每个主机名并行的下载两个组件。</p><p>在下载脚本时，浏览器并行下载实际上被禁用的。脚本可能使用document.write来修改页面内容，浏览器等待，以确保页面能恰当的布局。 </p><p>为了确保脚本能够按照正确的顺序执行。（因为脚本之间可能存在依赖关系） </p><p><scripts> defer属性指明本元素所含的脚本不会修改DOM，因此代码能够安全地延迟执行。  </scripts></p></blockquote></li><li><p><strong>使用外部javascript和CSS</strong></p></li><li><p><strong>避免重定向</strong> </p></li></ol><p><strong>更多</strong>：</p><blockquote><p>英文原文：<a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html</a></p><p>中文翻译：<a href="http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html" target="_blank" rel="noopener">http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html</a></p><p><a href="https://www.baidu.com/s?wd=%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97%E3%80%8B&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《高性能网站建设指南》</a>这本书中提出了一些规则：</p><p>规则1——减少HTTP请求<br>规则2——使用内容发布网络CDN<br>规则3——添加Expires头，使用缓存<br>规则4——压缩组件<br>规则5——将样式表放在顶部<br>规则6——将脚本放在底部，避免阻塞html渲染<br>规则7——避免CSS表达式<br>规则8——使用外部JavaScript和CSS<br>规则9——减少DNS查找，使用DNS Prefetch预解析技术<br>规则10——精简JavaScript，代码精简<br>规则11——避免重定向，减少http请求<br>规则12——移除重复脚本，代码精简<br>规则13——配置ETag，缓存相关<br>规则14——使Ajax可缓存</p></blockquote><blockquote><p>Google Web Fundamentals: <a href="https://developers.google.cn/web/fundamentals/?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.cn/web/fundamentals/?hl=zh-cn</a></p></blockquote><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><p>典型的xhr建立ajax的过程：</p><ol><li>new一个xhr对象。</li><li>调用xhr对象的open()方法。</li><li>send()一些数据。 </li><li>对服务器的响应过程进行监听，来知道服务器是否正确得做出了响应，接着就可以做一些事情。比如获取服务器响应的内容，在页面上进行呈现。 </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="comment">// 利用所有现代浏览器内部的对象-XMLHttpRequest-来实现发送和接收HTTP请求与响应信息。</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">  <span class="comment">//IE7+,...</span></span><br><span class="line">  xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//IE6,IE5</span></span><br><span class="line">  xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用open(method,url,async) 方法准备好一个请求，async表示同步还是异步，默认为true(异步)；</span></span><br><span class="line">xhr.open(<span class="string">"POST"</span>,<span class="string">"/bank/rich.do"</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 在调用open()方法后，XMLHttpRequest对象把它的readyState属性设置为1(打开)并且把responseText、responseXML、status和statusText属性复位到它们的初始值。另外，它还复位请求头部。</span></span><br><span class="line"><span class="comment">// 注意，如果你调用open()方法并且此时readyState为4，则XMLHttpRequest对象将复位这些值。</span></span><br><span class="line"><span class="comment">// 设置请求的头部信息，必须写在open和send中间</span></span><br><span class="line"><span class="comment">// 如果在send(data)方法中的data参数的类型为DOMString，那么，数据将被编码为UTF-8。</span></span><br><span class="line"><span class="comment">// 如果数据是Document类型，那么将使用由data.xmlEncoding指定的编码串行化该数据。</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="comment">// 仅当readyState值为1时，才可以调用send()方法；否则的话，XMLHttpRequest对象将引发一个异常。</span></span><br><span class="line"><span class="comment">// XMLHttpRequest对象的send()方法可以立即返回，从而让Web页面上的其它HTML/JavaScript继续其浏览器端处理而由服务器处理HTTP请求并发送响应。即Async</span></span><br><span class="line">xhr.send(<span class="string">"name=王大锤&amp;sex=男"</span>);</span><br><span class="line"><span class="comment">// 在调用send()方法后，XMLHttpRequest对象把readyState的值设置为2(发送)。</span></span><br><span class="line"><span class="comment">// 当服务器响应时，在接收消息体之前，如果存在任何消息体的话，XMLHttpRequest对象将把readyState设置为3(正在接收中)。</span></span><br><span class="line"><span class="comment">// 当请求完成加载时，它把readyState设置为4(已加载)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xhr激发一个readystatechange事件，设置状态监听</span></span><br><span class="line"><span class="comment">// getAllResponseHeader()：获取所有的响应报头。</span></span><br><span class="line"><span class="comment">// getResponseHeader()：查询响应中的某个字段的值。readyState==3|4时调用才有意义。</span></span><br><span class="line"><span class="comment">// abort()：暂停异步HTTP请求，复位到未初始化状态。</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// readyState属性：0/1/2/3/4, 描述对象的当前状态</span></span><br><span class="line">  <span class="comment">// 0："未初始化"状态，已经创建一个XMLHttpRequest对象，但是还没有初始化。</span></span><br><span class="line">  <span class="comment">// 1："发送"状态，open()已经调用，也准备好发送请求。</span></span><br><span class="line">  <span class="comment">// 2："发送"状态，已通过send()发送请求，但还没有收到一个响应。</span></span><br><span class="line">  <span class="comment">// 3："正在接收"状态，已经接收到HTTP响应头部信息，但是消息体部分还没有完全接收。</span></span><br><span class="line">  <span class="comment">// 4："已加载"状态，响应已经被完全接收。</span></span><br><span class="line">  <span class="comment">// status：以数字返回http状态码。</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="comment">// statusText文本形式返回http状态码</span></span><br><span class="line">    xhr.statusText</span><br><span class="line">    <span class="comment">// responseText:获得字符串形式的相应数据(Content-Type)，完整的响应信息。</span></span><br><span class="line">    xhr.responseText</span><br><span class="line">    <span class="comment">// responseXML:获得XML形式的相应数据，否则为null。</span></span><br><span class="line">    xhr.responseXML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jquery-ajax"><a href="#jquery-ajax" class="headerlink" title="jquery ajax"></a>jquery ajax</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type:<span class="string">"GET"</span>,</span><br><span class="line">    url:<span class="string">"service.php?number="</span>+$(<span class="string">"#keyword"</span>).val(),</span><br><span class="line">    dataType:<span class="string">"json"</span>, <span class="comment">// 预期服务器返回数据的类型，可以为xml,html,script,json,jsonp,text</span></span><br><span class="line">    cache:<span class="string">"true"</span>,<span class="comment">//dataType 为 script 和 jsonp 时默认为 false，不缓存页面。</span></span><br><span class="line">    processData:<span class="string">"false"</span>,<span class="comment">//false:不转化对象为查询字符串</span></span><br><span class="line">    ifModified:<span class="string">"true"</span>,<span class="comment">//如果希望判断数据自从上次请求后没有更改过就报告出错的话</span></span><br><span class="line">    <span class="comment">// 如果要处理 $.ajax() 得到的数据，则需要使用回调函数</span></span><br><span class="line">    beforeSend:<span class="function"><span class="keyword">function</span>(<span class="params">jqxhr</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 可修改 XMLHttpRequest 对象,如添加自定义 HTTP 头</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在请求成功之后调用。传入返回的数据以及 "dataType" 参数的值。</span></span><br><span class="line">    dataFilter:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="comment">// 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.success)&#123;</span><br><span class="line">            $(<span class="string">"searchResult"</span>).html(data.msg);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            $(<span class="string">"#searchResult"</span>).html(<span class="string">"出现错误："</span> + data.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在请求出错时调用。传入 XMLHttpRequest 对象，描述错误类型的字符串以及一个异常对象（如果有的话）</span></span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params">jqXHR</span>)</span>&#123;</span><br><span class="line">        aler(<span class="string">"发生错误："</span>+ jqXHR.status);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当请求完成之后调用这个函数，无论成功或失败。传入 XMLHttpRequest 对象，以及一个包含成功或错误代码的字符串。</span></span><br><span class="line">    complete:<span class="function"><span class="keyword">function</span>(<span class="params">jqXHR,TS</span>)</span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用 jsonp 类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的 URL 后面。服务器端应当在 JSON 数据前加上回调函数名，以便完成一个有效的 JSONP 请求。如果要指定回调函数的参数名来取代默认的 callback，可以通过设置 $.ajax() 的 jsonp 参数。 </p></blockquote><p><code>contentType</code>与<code>dataType</code>的区别：</p><blockquote><p><code>contentType</code>: 发送信息至服务器时内容编码类型，告诉服务器，请求数据的类型，默认值: <code>&quot;application/x-www-form-urlencoded&quot;</code></p><p><code>dataType</code>：告诉服务器，我要想什么类型的响应数据，除了常见的json、XML，还可以指定 html、jsonp、script或者text</p></blockquote><h3 id="Ajax解决缓存的5种方法总结"><a href="#Ajax解决缓存的5种方法总结" class="headerlink" title="Ajax解决缓存的5种方法总结"></a>Ajax解决缓存的5种方法总结</h3><ol><li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0″)。</li><li>在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</li><li>在URL后面加上一个随机数： “fresh=” + Math.random();。</li><li>在URL后面加上时间搓：”nowtime=” + new Date().getTime();。</li><li>如果是使用jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</li></ol><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a><strong>fetch</strong></h3><p>号称是AJAX的替代品；</p><p>基于标准 Promise 实现，支持 async/await；</p><p>原生js，没有使用XMLHttpRequest对象；</p><p>但是：fetch只对网络请求报错；默认不带cookie，需添加配置；不支持abort；无法监测请求进度。</p><h1 id="混合开发-Hybrid-App"><a href="#混合开发-Hybrid-App" class="headerlink" title="混合开发 Hybrid App"></a>混合开发 Hybrid App</h1><p>基于Cordova</p><p>H5代码打包存放在客户端本地</p><p>原生负责搭建app基础框架，开发网络层，提供常用组件和插件等功能</p><h1 id="jQuery-bootstrap"><a href="#jQuery-bootstrap" class="headerlink" title="jQuery bootstrap"></a>jQuery bootstrap</h1><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><blockquote><p>参考：<a href="http://jquery.cuishifeng.cn/" target="_blank" rel="noopener">http://jquery.cuishifeng.cn/</a></p></blockquote><p>选择器：基本选择器/层级选择器/基本筛选器/内容/可见性/属性/子元素/表单</p><p>核心：多库共存/插件机制/队列控制/数据缓存/对象访问</p><p>工具：字符串操作/函数操作/数组和对象操作/测试操作/浏览器及特性检测</p><p>ajax：请求/事件/其他</p><p>效果：基本/滑动/淡入淡出/自定义/设置</p><p>事件对象：</p><p>回调函数：</p><p>属性：属性/CSS类/HTML代码、文本、值</p><p>文档处理：内部插入/外部插入/包裹/替换/删除/复制/</p><p>筛选：过滤/查找/串联</p><p>CSS：CSS/位置/尺寸</p><p>事件：页面载入/事件处理/事件委派/事件切换/事件</p><p>延迟对象：</p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><blockquote><p>文档：<a href="https://v3.bootcss.com/getting-started/" target="_blank" rel="noopener">https://v3.bootcss.com/getting-started/</a></p></blockquote><p>在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 <code>user-scalable=no</code> 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。注意，这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将最外面的布局元素 <code>.container</code> 修改为 <code>.container-fluid</code>，就可以将固定宽度的栅格布局转换为 100% 宽度的布局。 </p><p><strong>Bootstrap 栅格系统的工作原理：</strong></p><ul><li>“行（row）”必须包含在 <code>.container</code> （固定宽度）或 <code>.container-fluid</code> （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。</li><li>通过“行（row）”在水平方向创建一组“列（column）”。</li><li>你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。</li><li>类似 <code>.row</code> 和 <code>.col-xs-4</code> 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。</li><li>通过为“列（column）”设置 <code>padding</code> 属性，从而创建列与列之间的间隔（gutter）。通过为 <code>.row</code> 元素设置负值 <code>margin</code> 从而抵消掉为 <code>.container</code> 元素设置的 <code>padding</code>，也就间接为“行（row）”所包含的“列（column）”抵消掉了<code>padding</code>。</li><li>负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。</li><li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 <code>.col-xs-4</code> 来创建。</li><li>如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。</li><li>栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 <code>.col-md-*</code>栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 <code>.col-lg-*</code>不存在， 也影响大屏幕设备。</li></ul><p><strong>使用媒体查询（media query）来创建关键的分界点阈值</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 原生写法，做对比 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">500px</span>) &#123;  </span><br><span class="line">     <span class="selector-tag">body</span> &#123; <span class="attribute">background-color</span>: black;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 超小屏幕（手机，小于 768px） */</span></span><br><span class="line"><span class="comment">/* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 小屏幕（平板，大于等于 768px） */</span></span><br><span class="line">@<span class="keyword">media</span> (min-width: @screen-sm-min) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中等屏幕（桌面显示器，大于等于 992px） */</span></span><br><span class="line">@<span class="keyword">media</span> (min-width: @screen-md-min) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 大屏幕（大桌面显示器，大于等于 1200px） */</span></span><br><span class="line">@<span class="keyword">media</span> (min-width: @screen-lg-min) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>栅格参数</strong></p><p>通过下表可以详细查看 Bootstrap 的栅格系统是如何在多种屏幕设备上工作的。</p><table><thead><tr><th></th><th>超小屏幕 手机 (&lt;768px)</th><th>小屏幕 平板 (≥768px)</th><th>中等屏幕 桌面显示器 (≥992px)</th><th>大屏幕 大桌面显示器 (≥1200px)</th></tr></thead><tbody><tr><td>栅格系统行为</td><td>总是水平排列</td><td>开始是堆叠在一起的，当大于这些阈值时将变为水平排列C</td><td></td><td></td></tr><tr><td><code>.container</code> 最大宽度</td><td>None （自动）</td><td>750px</td><td>970px</td><td>1170px</td></tr><tr><td>类前缀</td><td><code>.col-xs-</code></td><td><code>.col-sm-</code></td><td><code>.col-md-</code></td><td><code>.col-lg-</code></td></tr><tr><td>列（column）数</td><td>12</td><td></td><td></td><td></td></tr><tr><td>最大列（column）宽</td><td>自动</td><td>~62px</td><td>~81px</td><td>~97px</td></tr><tr><td>槽（gutter）宽</td><td>30px （每列左右均有 15px）</td><td></td><td></td><td></td></tr><tr><td>可嵌套</td><td>是</td><td></td><td></td><td></td></tr><tr><td>偏移（Offsets）</td><td>是</td><td></td><td></td><td></td></tr><tr><td>列排序</td><td>是</td><td></td><td></td></tr></tbody></table><h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><ul><li><strong>如果只做pc端，那么静态布局（定宽度）是最好的选择；</strong></li><li><strong>如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份css+一份js调节font-size搞定；</strong></li><li><strong>如果pc，移动要兼容，而且要求很高，那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局。</strong></li></ul><hr><h2 id="静态布局（Static-Layout）"><a href="#静态布局（Static-Layout）" class="headerlink" title="静态布局（Static Layout）"></a>静态布局（Static Layout）</h2><p>固定宽度布局；<br>以<strong>px</strong>为单位，页面布局固定不变；<br>开发简单，无兼容性问题，不能根据用户的屏幕尺寸做出不同的表现。</p><h2 id="流式布局（Liquid-Layout）"><a href="#流式布局（Liquid-Layout）" class="headerlink" title="流式布局（Liquid Layout）"></a>流式布局（Liquid Layout）</h2><p>也叫百分比布局；<br>关键元素高宽和位置都不变，只有容器元素在做伸缩变换；<br>页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变；<br>使用 <strong>%百分比</strong> 定义<strong>宽度</strong>，高度大都是用px来固定；<br>主要的问题是如果屏幕尺度跨度太大，有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样。</p><h2 id="自适应布局（Adaptive-Layout）"><a href="#自适应布局（Adaptive-Layout）" class="headerlink" title="自适应布局（Adaptive Layout）"></a>自适应布局（Adaptive Layout）</h2><p>宽度自适应布局；<br>自适应是为了解决如何才能在不同大小的设备上呈现相同的网页。让同一张网页自动适应不同大小的屏幕，根据屏幕的宽度，自动调节网页的内容大小，但是无论怎样，他们的主体的内容和布局是没有变化的；<br>分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围；<br>自适应布局可看作是静态布局的一个系列；<br>使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。</p><h2 id="响应式布局（Responsive-Layout）"><a href="#响应式布局（Responsive-Layout）" class="headerlink" title="响应式布局（Responsive Layout）"></a>响应式布局（Responsive Layout）</h2><p>通常是糅合了流式布局+自适应布局，再搭配媒体查询技术使用。<br>响应式与自适应的原理是相似的，都是检测设备，根据不同的设备采用不同的css</p><h2 id="弹性布局（rem-em布局）"><a href="#弹性布局（rem-em布局）" class="headerlink" title="弹性布局（rem/em布局）"></a>弹性布局（rem/em布局）</h2><blockquote><p>rem是始终相对于html大小，即页面根元素；<br>em是相对其父元素。</p></blockquote><h2 id="布局比较"><a href="#布局比较" class="headerlink" title="布局比较"></a>布局比较</h2><p><img src="images/screenshot_1548660473340.png" alt=""><br>||静态布局|流式布局|自适应布局|响应式布局|弹性布局|<br>|–|–|–|–|–|–|<br>|单位|px|%|px|%|em/rem|<br>||||多个静态布局，分别对应一个屏幕分辨率范围|多个流式布局，分别对应一个屏幕分辨率范围|em:相对父元素；rem:相对根元素；|<br>|元素大小|不变|变|不变|变||<br>|元素位置|不变|不变|变|变||<br>||整体布局不变|整体布局不变|使用media query|使用media query||<br>||||伸缩窗口，一定范围内页面元素不变化|伸缩窗口都会变化||<br>|||用于解决类似的设备不同分辨率之间的兼容||流式布局+自适应布局；用于解决不同设备之间不同分辨率之间的兼容问题|根据自己的需求在根元素确定一个参考值|<br>||只PC端|||PC&amp;Mobile兼容|只Mobile端|</p><hr><h2 id="媒体查询-media-query"><a href="#媒体查询-media-query" class="headerlink" title="媒体查询 media query"></a>媒体查询 media query</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> 设备类型 and (设备特性-宽度) &#123;</span><br><span class="line">    // 特定样式CSS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h3><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>screen</td><td>显示器</td></tr><tr><td>print</td><td>打印用纸或打印预览视图</td></tr><tr><td>handled</td><td>便携设备</td></tr><tr><td>tv</td><td>电视机类型的设备</td></tr><tr><td>speech</td><td>语音和音频合成器</td></tr><tr><td>braille</td><td>盲人用点字法触觉回馈设备</td></tr><tr><td>embossed</td><td>盲人打印机</td></tr><tr><td>projection</td><td>各种投影设备</td></tr><tr><td>tty</td><td>使用固定密度字母栅格的媒介，比如电传打字机和终端</td></tr></tbody></table><h3 id="设备特性"><a href="#设备特性" class="headerlink" title="设备特性"></a>设备特性</h3><table><thead><tr><th>特性</th><th>可指定的值</th><th>是否允许使用min/max前缀</th><th>特性说明</th></tr></thead><tbody><tr><td>width</td><td>带单位的长度数值</td><td>允许</td><td>浏览器窗口的宽度  css</td></tr><tr><td>height</td><td>带单位的长度数值</td><td>允许</td><td>浏览器窗口的高度</td></tr><tr><td>device-width</td><td>带单位的长度数值</td><td>允许</td><td>设备屏幕分辨率的宽度值</td></tr><tr><td>device-height</td><td>带单位的长度数值</td><td>允许</td><td>设备屏幕分辨率的高度值</td></tr><tr><td>orientation</td><td>只能指定两个值:portrait或landscape</td><td>不允许</td><td>窗口的方向是纵向还是横向</td></tr><tr><td>aspect-ratio</td><td>比例值，例如：16/9</td><td>允许</td><td>窗口的纵横比，比例值为浏览器窗口的宽度值/高度值</td></tr><tr><td>device-aspect-ratio</td><td>比例值，例如：16/9</td><td>允许</td><td>设备屏幕分辨率的纵横比，比例值为设备屏幕分辨率的宽度值/高度值</td></tr><tr><td>color</td><td>整数值</td><td>允许</td><td>设备使用多少位的颜色值，如果不是彩色设备，该值为0</td></tr><tr><td>color-index</td><td>整数值</td><td>允许</td><td>色彩表中的色彩数</td></tr><tr><td>monochrome</td><td>整数值</td><td>允许</td><td>单色帧缓冲器中每像素的字节数</td></tr><tr><td>resolution</td><td>分辨率值，譬如300dpi</td><td>允许</td><td>设备的分辨率</td></tr><tr><td>scan</td><td>只能指定两个值：progressive或interlace</td><td>不允许</td><td>电视机类型设备的扫描方式，progressive表示逐行扫描，interlace表示隔行扫描</td></tr><tr><td>grid</td><td>只能指定两个值:0或1</td><td>不允许</td><td>设备是基于栅格还是基于位图。基于栅格时该值为1，否则该值为0</td></tr></tbody></table><hr><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="一，在标签内引入"><a href="#一，在标签内引入" class="headerlink" title="一，在标签内引入"></a>一，在<head>标签内引入<meta></head></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>width: 控制viewport的大小。如device-width为设备的宽度；<br>initial-scale: 初始缩放比例，页面第一次加载时的缩放比例；<br>maximum-scale 允许用户缩放到的最大比例，范围从0到10.0；<br>minimum-scale: 允许用户缩放到的最小比例，范围从0到10.0；<br>user-scalable： 用户是否可以手动缩放，值可以是：yes/true允许用户缩放；no/false不允许用户缩放。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 代码有类似于电话这样的数字时，不会自动转换成可以拨打电话</span><br><span class="line">&lt;meta content=&quot;telephone=no,email=no&quot; name=&quot;format-detection&quot; /&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="二，dpr-设备像素比"><a href="#二，dpr-设备像素比" class="headerlink" title="二，dpr 设备像素比"></a>二，dpr 设备像素比</h3><blockquote><p>devicePixelRatio = 物理像素/ 独立像素(CSS像素)<br>css中的1像素(px)在设备上占用多少个物理像素；<br><strong>物理像素</strong>可以映射到设备的<strong>分辨率</strong>的宽度；<br><strong>独立像素</strong>可以映射到媒体查询<strong>media定义</strong>的宽度；</p></blockquote><h3 id="三，媒介查询"><a href="#三，媒介查询" class="headerlink" title="三，媒介查询"></a>三，媒介查询</h3><h3 id="四，设置多种视图宽度"><a href="#四，设置多种视图宽度" class="headerlink" title="四，设置多种视图宽度"></a>四，设置多种视图宽度</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** iPad **/</span></span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">768px</span>) and (max-width: <span class="number">1024px</span>) &#123;&#125;</span><br><span class="line"><span class="comment">/** iPhone **/</span></span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">320px</span>) and (max-width: <span class="number">767px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><p>弹性布局 <a href="http://www.runoob.com/w3cnote/flex-grammar.html" target="_blank" rel="noopener">http://www.runoob.com/w3cnote/flex-grammar.html</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;<span class="comment">/*任意容器*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-flex</span>;<span class="comment">/*行内元素*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-flex</span>;<span class="comment">/*safari*/</span></span><br></pre></td></tr></table></figure><blockquote><p>flex container 容器 – flex item 项目</p><p>main axis 主轴 – main start 主轴开始位置 / main end 主轴结束位置</p><p>cross axis 交叉轴 – cross start 交叉轴开始位置 / cross end 交叉轴结束位置</p><p>main size 项目占主轴空间 / cross size 项目占交叉轴空间</p></blockquote><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><ul><li><code>flex-direction: row | row-reverse | column | column-reverse;</code></li><li><code>flex-wrap: nowrap | wrap | wrap-reverse;</code></li><li><code>flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</code></li><li><code>justify-content: flex-start | flex-end | center | space-between项目之间的间隔都相等 | space-around项目两侧的间隔相等 ;</code></li><li><code>align-items: flex-start | flex-end | center | baseline | stretch;</code></li><li><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</code></li></ul><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><ul><li><code>order: &lt;integer&gt;; /*项目的排列顺序。数值越小，排列越靠前，默认为0。*/</code></li><li><code>flex-grow: &lt;number&gt;; /* 放大比例 default 0 */</code></li><li><code>flex-shrink: &lt;number&gt;; /* 缩小比例 default 1 */</code></li><li><code>flex-basis: &lt;length&gt; | auto; /* 在分配多余空间之前，项目占据的主轴空间 default auto */</code></li><li><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] /* 默认值为0 1 auto */</code></li><li><code>align-self: auto | flex-start | flex-end | center | baseline | stretch; /*与众不同的对齐方式*/</code></li></ul><h1 id="MVVM-VUE-js"><a href="#MVVM-VUE-js" class="headerlink" title="MVVM VUE.js"></a>MVVM VUE.js</h1><p><a href="http://doc.liangxinghua.com/vue-family/1.html" target="_blank" rel="noopener">http://doc.liangxinghua.com/vue-family/1.html</a></p><p>渐进式框架，核心库只关注视图层，需要什么就引入什么，自底向上增量开发。</p><blockquote><p>渲染分为：<strong>命令式渲染</strong>和<strong>声明式渲染</strong> </p><p><strong>命令式渲染</strong>：命令我们的程序去做什么，程序就会跟着你的命令去一步一步执行 </p><p><strong>声明式渲染</strong> ：只需要告诉程序想要什么效果，其他的交给程序来做</p></blockquote><p>Vue.js全家桶：Vue + Vue-router + Vuex + axios</p><p>Vue.js由一系列的组件组成应用，组件(components)映射到路由(routes)，然后 vue-router 在相应位置渲染它们。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>new Vue() –&gt; init</p><table><thead><tr><th>周期</th><th>说明</th></tr></thead><tbody><tr><td>beforeCreate</td><td>在实例初始化之后，数据观测和事件配置之前被调用</td></tr><tr><td>created</td><td>在实例创建完成后被立即调用，完成数据观测，属性和方法的运算，初始化事件，$el属性未见</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用，只在虚拟DOM生成HTML</td></tr><tr><td>mounted</td><td>在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互</td></tr><tr><td>beforeUpdate</td><td>在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程</td></tr><tr><td>updated</td><td>在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用</td></tr><tr><td>activated</td><td>keep-alive 组件激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 组件停用时调用</td></tr><tr><td>beforeDestroy</td><td>在实例销毁之前调用。实例仍然完全可用</td></tr><tr><td>destroyed</td><td>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用</td></tr></tbody></table><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>基于Promise的HTTP库，<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"><span class="comment">// post</span></span><br><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// get 1</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line"><span class="comment">// get 2</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">      <span class="comment">// The request was made and the server responded with a status code</span></span><br><span class="line">      <span class="comment">// that falls out of the range of 2xx</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.response.data);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.status);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.headers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.request) &#123;</span><br><span class="line">      <span class="comment">// The request was made but no response was received</span></span><br><span class="line">      <span class="comment">// `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span></span><br><span class="line">      <span class="comment">// http.ClientRequest in node.js</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Something happened in setting up the request that triggered an Error</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error'</span>, error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.all(iterable)</span><br><span class="line">axios.spread(callback)</span><br></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="requests-response-拦截器"><a href="#requests-response-拦截器" class="headerlink" title="requests/response 拦截器"></a>requests/response 拦截器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;<span class="keyword">return</span> config;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);&#125;);</span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;<span class="keyword">return</span> response;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);&#125;);</span><br></pre></td></tr></table></figure><h3 id="默认全局配置"><a href="#默认全局配置" class="headerlink" title="默认全局配置"></a>默认全局配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.timeout = <span class="number">5000</span>; <span class="comment">// 响应时间</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>; <span class="comment">// 配置请求头</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>; <span class="comment">// 配置接口地址</span></span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下，axios发送数据的形式为<code>application/json;charset=UTF-8</code>，如若想以<code>application/x-www-form-urlencoded</code>的形式发送数据，可以使用如下方法：</p><h3 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是所有浏览器都支持</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入qs模块</span></span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;));</span><br></pre></td></tr></table></figure><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以使用qs模块</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;));</span><br></pre></td></tr></table></figure><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><blockquote><p>参考：<a href="https://blog.csdn.net/zhbhun/article/details/47208885" target="_blank" rel="noopener">https://blog.csdn.net/zhbhun/article/details/47208885</a></p><p>webpack详解：<a href="https://juejin.im/post/5aa3d2056fb9a028c36868aa" target="_blank" rel="noopener">https://juejin.im/post/5aa3d2056fb9a028c36868aa</a></p></blockquote><p>CommonJS模块规范</p><blockquote><p>导出模块：module.exports 或 exports</p><p>前者：module是对象，exports是属性；后者：exports变量是指向module.exports</p><p>导入模块：require()</p></blockquote><p>ES6语法</p><blockquote><p>导出模块：export 或 export default</p><p>导入模块：import</p></blockquote><p><strong>require.ensure()</strong></p><p>webpack 在编译时，会静态地解析代码中的 require.ensure()，同时将模块添加到一个分开的 chunk 当中。这个新的 chunk 会被 webpack 通过 jsonp 来按需加载。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies: <span class="built_in">String</span>[], <span class="attr">callback</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require</span>), <span class="title">chunkName</span>: <span class="title">String</span>) </span></span><br><span class="line"><span class="function">// <span class="title">dependencies</span>：字符串数组，空数组作为参数</span></span><br><span class="line"><span class="function">// <span class="title">callback</span>：当所有的依赖都加载完成后，<span class="title">webpack</span>会执行这个回调函数</span></span><br><span class="line"><span class="function">// <span class="title">chunkName</span>：相同<span class="title">chunkName</span>会放入同一个文件束中</span></span><br></pre></td></tr></table></figure><h1 id="node-js-koa-express-npm"><a href="#node-js-koa-express-npm" class="headerlink" title="node.js koa express npm"></a>node.js koa express npm</h1><p><strong>基于JavaScript语言</strong>和<strong>V8高性能引擎</strong>的开源Web服务器。</p><p>node.js是<strong>事件驱动</strong>的，因为JavaScript是事件驱动的。</p><p>node.js是<strong>单线程</strong>的，可实现并发处理，依赖于<strong>事件循环（event loop）</strong>。</p><p>Node.js使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为web server一直接受请求而不等待任何读写操作，即为<strong>非阻塞I/O</strong>。 (想象饭馆排队点餐，取号等待，做好后喊你取餐)。</p><p>对比：传统的web server多为基于线程模型。你启动Apache或者tomcat等，它开始等待接受连接。当收到一个连接，server保持连接连通直到页面或者什么事务请求完成。如果他需要花几微秒时间去读取磁盘或者访问数据库，web server就阻塞了IO操作（这也被称之为阻塞式IO)。想提高这样的web server的性能就只有启动更多的server实例。 </p><h2 id="Node-js-RESTful-API"><a href="#Node-js-RESTful-API" class="headerlink" title="Node.js RESTful API"></a>Node.js RESTful API</h2><p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）</p><p>REST 通常使用 JSON 数据格式。 </p><p> 基本架构方法：GET/PUT/DELETE/POST</p><p>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p><p>基于 REST 架构的 Web Services 即是 RESTful。</p><p>由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。</p><h2 id="Node-js多进程"><a href="#Node-js多进程" class="headerlink" title="Node.js多进程"></a>Node.js多进程</h2><p>利用child_process 模块在多核 cpu 的系统上创建多个子进程，从而提高性能。 </p><ul><li><strong>exec</strong> - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</li><li><strong>spawn</strong> - child_process.spawn 使用指定的命令行参数创建新进程。</li><li><strong>fork</strong> - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>为了让Node.js的文件可以相互调用；</p><p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。 </p><p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 </p><p>可以使用 module.exports = Hello 代替exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 </p><blockquote><p><strong>exports 和 module.exports 的使用</strong></p><p>如果要对外暴露属性或方法，就用 <strong>exports</strong> 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 <strong>module.exports</strong>。</p></blockquote><p>Node.js 中存在 4 类模块（原生模块和3种文件模块） </p><blockquote><p>从文件模块缓存中加载&gt;从原生模块加载&gt;从文件加载</p></blockquote><h2 id="events-模块"><a href="#events-模块" class="headerlink" title="events 模块"></a>events 模块</h2><p>通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件</p><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 </p><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。</p><h2 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h2><p>Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块</p><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><p>OS 模块-提供基本的系统操作函数。</p><p>Path 模块-提供了处理和转换文件路径的工具。</p><p>Net 模块-用于底层的网络通信。提供了服务端和客户端的的操作。</p><p>DNS 模块-用于解析域名。</p><p>Domain 模块-简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。</p><p>fs 模块-Node.js 文件系统，模块中的方法均有异步和同步版本。</p><p>util 是一个Node.js 核心模块，提供常用函数的集合。</p><ul><li>util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法 ；</li><li>util.isArray(object)</li><li>util.isRegExp(object)</li><li>util.isDate(object)</li><li>util.isError(object)</li></ul><p>url模块 &amp; querystring 模块 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url.parse(string).query</span><br><span class="line">                                           |</span><br><span class="line">           url.parse(string).pathname      |</span><br><span class="line">                       |                   |</span><br><span class="line">                     ------ -------------------</span><br><span class="line">http://localhost:8888/start?foo=bar&amp;hello=world</span><br><span class="line">                                ---       -----</span><br><span class="line">                                 |          |</span><br><span class="line">      querystring.parse(queryString)[&quot;foo&quot;] |</span><br><span class="line">                                            |</span><br><span class="line">                         querystring.parse(queryString)[&quot;hello&quot;]</span><br></pre></td></tr></table></figure><h2 id="全局对象global"><a href="#全局对象global" class="headerlink" title="全局对象global"></a>全局对象global</h2><p>__dirname当前执行脚本所在的目录 </p><p>__filename当前正在执行的脚本的文件名</p><p>process 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。</p><h1 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h1><table><thead><tr><th>模型名称</th><th>技术特点</th><th>适用范围</th></tr></thead><tbody><tr><td>瀑布模型</td><td>简单，分阶段，阶段间存在因果关系，各个阶段完成后都有评审，允许反馈，不支持用户参与，要求预先确定需求</td><td>需求易于完善定义且不易变更的软件系统</td></tr><tr><td>快速原型模型</td><td>不要求需求预先完备定义，支持用户参与，支持需求的渐进式完善和确认，能够适应用户需求的变化</td><td>需求复杂、难以确定、动态变化的软件系统</td></tr><tr><td>增量模型</td><td>软件产品是被增量式地一块块开发的，允许开发活动并行和重叠</td><td>技术风险较大、用户需求较为稳定的软件系统</td></tr><tr><td>迭代模型</td><td>不要求一次性地开发出完整的软件系统，将软件开发视为一个逐步获取用广需求、完善软件产品的过程</td><td>需求难以确定、不断变更的软件系统</td></tr><tr><td>螺旋模型</td><td>结合瀑布模型、快速原型模型和迭代模型的思想，并引进了风险分析活动</td><td>需求难以获取和确定、软件开发风险较大的软件系统</td></tr></tbody></table><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 </p><table><thead><tr><th>序号</th><th>模式 &amp; 描述</th><th>包括</th></tr></thead><tbody><tr><td>1</td><td><strong>创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td><td>工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）</td></tr><tr><td>2</td><td><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td>适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）</td></tr><tr><td>3</td><td><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td><td>责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td></tr><tr><td>4</td><td><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td>MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精通浏览器兼容性调优&quot;&gt;&lt;a href=&quot;#精通浏览器兼容性调优&quot; class=&quot;headerlink&quot; title=&quot;精通浏览器兼容性调优&quot;&gt;&lt;/a&gt;精通浏览器兼容性调优&lt;/h1&gt;&lt;p&gt;(参考：&lt;a href=&quot;https://blog.csdn.net/gar
      
    
    </summary>
    
      <category term="frontend" scheme="http://gnbyj.cn/categories/frontend/"/>
    
    
      <category term="web" scheme="http://gnbyj.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>产品思维30讲</title>
    <link href="http://gnbyj.cn/2018/07/18/%5B2018-07-18%5D%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B430%E8%AE%B2/"/>
    <id>http://gnbyj.cn/2018/07/18/[2018-07-18]产品思维30讲/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2018-07-18T01:08:41.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="01-产品能力是每个人的底层能力"><a href="#01-产品能力是每个人的底层能力" class="headerlink" title="01 产品能力是每个人的底层能力"></a>01 产品能力是每个人的底层能力</h3><p>你好，欢迎来到《梁宁·产品思维30讲》。</p><p>我在IT和互联网行业工作了20多年，写过代码，做过销售，当过高管，创过业，卖过公司，也做过投资。如果问我做过这么多的事，最喜欢哪一样？我会说，做一个产品人，做产品。</p><p>为什么呢？</p><p>因为我觉得<strong>产品能力是人生的一个底层能力</strong>。拥有产品能力，能让你有一种踩在地上的自信和踏实感。我们大家都是从一无所有走过来的，我还记得那种茫然无措的感受，因为没有<strong>认知框架</strong>，所以每天面对着各种正面、负面的信息，任其冲击情绪，却不知道如何处置。<strong>这些信息到底什么重要，什么不重要，应该如何识别？</strong>同时，我们害怕自己的才华得不到赏识；自己努力了，却总是被diss；没有得到正面的反馈，得不到回报。还会有人自怨自艾，没有家庭背景，没干爹，没靠山。还好，在今天这个时代，如果让我给一个建议，那就是培养自己的产品能力。以上这些都不重要，<strong>产品能力会给你自信</strong>。</p><p>为什么呢？</p><p><strong>产品能力就是训练一个人：判断信息，抓住要点，整合有限的资源，把自己的价值打包成一个产品向世界交付，并且获得回报。</strong>别怕茫然，别怕被diss，别怕推倒重来。因为从一个普通人，到成为一个产品人的过程，其实就是<strong>一个人学习建立认知框架的过程</strong>，<strong>先建立信息的秩序，再建立自己内心的秩序。</strong>在一片纷杂里，你会知道<strong>自己该放弃哪些点，抓住哪个点，慢慢建立起掌控。</strong>这个过程里，你会碰到数不清的diss，被各种吐槽，被指着脸批评，还有数不清的推倒重来，这就是一个产品人生活的常态。丘吉尔说：<em>如果你到了地狱，那就继续保持前行。</em>产品的人生就是天天被打击。既然这就是生活的常态，放下担心，你会在打击中变得健壮。所以，你就会拥有产品人的一项<strong>基础能力</strong>：<strong>抗挫折、抗打击的能力。</strong></p><p>另外，别怕没有家庭背景，别怕没靠山、没干爹。</p><p>因为做一个产品人，我们只认一条“<strong>用户驱动</strong>”，从第一个用户走向第一桶金。今天，全球市值最高的7家公司，美国有微软、苹果、Google、Facebook，中国有腾讯、阿里、百度……这些企业，在他们刚开始的时候，没有矿产土地资源，没有高官权贵加持，就一帮年轻人，在租来的办公室，靠自己的大脑，靠自己的创造力，在互联网的空间里，“无中生有”地创造了以前没有的空间与体验，改变了我们的生活，也改变了世界的面貌。不到20年的时间，他们生长成当今世界上，拥有最多财富和社会影响力的个体。一无所有的年轻人，从一个用户开始，拿到人生的第一桶金，然后建立自己的世界。马化腾、马云、李彦宏、刘强东、王兴、李学凌、姚劲波等等，几乎都是这样从普通人，变成了行业大佬。</p><p>他们是怎么做到的呢？他们是如何拥有用户？如何建立“用户驱动”的呢？这就是我这套课程要讲的内容。</p><h4 id="产品思维，到底讲什么内容"><a href="#产品思维，到底讲什么内容" class="headerlink" title="产品思维，到底讲什么内容"></a>产品思维，到底讲什么内容</h4><p>我会用5大模块一共25讲：</p><ol><li>教你怎么看到用户、倾听用户、判断用户，怎么能够与用户建立连接，并且在用户的交互反馈中去迭代和优化；</li><li>教你怎么去观察，怎么判断；</li><li>如何建立一种系统能力，以此去向用户交付一种确定性；</li><li>如何建立交互能力，接着在不断的连接与迭代中，深化你和用户的关系。</li></ol><p>你可以说我这套课是讲产品的，你也可以说我这套课是讲人的，或者说，这套课是从产品的专业视角，来看人和人关系的，或者说，基于对人和人关系的感知，来讲怎么做产品的。都对！因为产品只是你用来服务用户的介质。随着科技会进步，产品会迭代，公司的形态、组织的形态都会发生变化。但是你最终要服务的对象，那个人，他未被满足的需求、人的心与人性并没有那么大变化。</p><p>感性一点说，通过这30讲，我希望帮助你拥有三个东西：</p><ol><li>第一是一双眼睛，是发现痛点、找到破局点的敏锐之眼；</li><li>第二是一双手，是动手优化、着手改变的行动之手；</li><li>第三是一颗心，是洞察人性的同理心，懂得自己，懂得用户，懂得一个产品上，每个细微的小点给到人的满足感、确认感和依赖感。</li></ol><h4 id="新年第一课，你能从这门课收获什么？"><a href="#新年第一课，你能从这门课收获什么？" class="headerlink" title="新年第一课，你能从这门课收获什么？"></a>新年第一课，你能从这门课收获什么？</h4><p>作为得到的新年第一课，<strong>我希望这门课能够帮到</strong>以下几类朋友：</p><ul><li>我希望这些课程能够帮到<strong>那些曾经像我一样茫然的年轻人</strong>。产品能力是动手能力、是掌控能力，希望通过这30讲的课程和练习，你能够到找到与现实世界真切连接的踏实感，知道如何分辨要点，找到抓手，建立掌控感，不再茫然和被动。</li><li>我希望这些课程能够帮到<strong>那些希望自己有一技之长，踏实地生活的人</strong>。相信自己的双手，相信自己的动手能力，比什么都踏实。</li><li>我希望这些课程能够帮到<strong>那些在世界上感到孤独的人</strong>。世界是如此的不可知、不确定，但是通过我们的系统能力，我们可以应对和消化这种不确定。为他人的生活中，提供一点小小的确定，一点小小的依赖，通过产品与人对话，与人连接，其实也是一种温暖。</li><li>我希望这些课程能够帮到<strong>那些立志优化这个世界，在这个世界上留下痕迹的人</strong>。</li></ul><p>世界如此精彩，我们当然不能置身局外。</p><p>很高兴在这一年的开始之际与你相遇。</p><p>希望这一年，世界在你眼前展开，希望一切清晰与分明起来。</p><p>愿你能够在这个不确定的世界，建立自己的确定性，并与人彼此依赖。</p><p>愿你向这个世界交付你的价值，并且获得回报。</p><p>谢谢，2018，我们一起加油。</p><h3 id="02-案例：用户体验与结婚教练"><a href="#02-案例：用户体验与结婚教练" class="headerlink" title="02 案例：用户体验与结婚教练"></a>02 案例：用户体验与结婚教练</h3><h4 id="用产品经理的视角来看人"><a href="#用产品经理的视角来看人" class="headerlink" title="用产品经理的视角来看人"></a>用产品经理的视角来看人</h4><p>今天我想讲一个结婚教练的故事。</p><p>她是我的一个朋友，现在做的工作就是指导30多岁下定决心要结婚的女生，如何能够在一年半之内搞定结婚。</p><p>她的方法已经帮助了30多个30多岁的女生完成了结婚。这个结婚教练以前是干什么的呢？她以前是一个互联网公司的产品经理。她的这一套结婚的体系内容挺多的，这堂课我想把她最重要的一个环节拿出来分享。</p><p>这个环节就是如何观察和判断一个人。因为结婚也好，创业找合伙人也罢，都是非常重要的长期关系。改变一个人，那是非常难的事情。<strong>在开始长期关系之前，如何有框架地去观察一个人，进行是否适配的判断，是更关键的</strong>。结婚教练，就是用产品经理的专业视角，来训练用户如何去看一个人。</p><p>因为任何一个人，任何一个产品，大家都会有自己的感受。但是如果没有经历过专业的训练，那么所有的感受是混杂的，是混沌的。你的情绪，一定会被你最有感觉的那个点牵制住，所以就<strong>会有强烈的认知偏差和情绪偏差</strong>，并且在你没有强烈感受的那些地方，还会有大面积的<strong>认知盲点和思维遮蔽</strong>。</p><p>产品经理则是有一个完整的框架体系来看一个产品，不管你的第一直觉是喜欢还是不喜欢，其实你都可以用这套框架，相对完整地度量你对一个人的认识到底有多少。</p><h4 id="人和产品的五个层次"><a href="#人和产品的五个层次" class="headerlink" title="人和产品的五个层次"></a>人和产品的五个层次</h4><p>下面我就简单介绍一下，如何用一个产品经理看产品的专业化方法，去指导一个女孩儿去判断她的相亲对象。其实，就是从外到内的五个层次，我来一一介绍一下。</p><p><strong>第一层——感知层</strong></p><p>一个产品，你拿到它，它设计的美不美，质感怎么样。</p><p>一个人，你看到他的第一眼，这个人的身材、相貌，说话什么口音，穿衣服怎么搭配，这个就是最外层的感知层。</p><p><strong>第二层——角色框架层</strong></p><p>角色是很重要的一个词，我们会专门在第一模块用一课的时间来讲。</p><p>简单来讲就是，我们每个人都生活在角色里，并且被角色驯化。比如说你遇到一个银行职员，一个军人，或者是一个公务员，你在和他打交道的时候，你就能明显看到他身上角色的痕迹。你在办公室和你的公司的同事交往，其实大家的相处首先就是角色的对接。我们谈什么内容，我们知道哪些东西，都会被你的角色所控制。所以，基于表面的感知，基于角色化的接触，都是非常浅层的关系。也就是说，咱们日常和人的接触多半都是浅层关系，因为大家上班都是基于角色在做彼此的交流。大家在接受各种服务，为你提供服务的那个人，其实也都是角色所设定好的沟通方式和交付内容，然后再与你进行沟通、交割和讨论。</p><p>如果你和别人在角色扮演里对接，你就会被牢牢地捆在设定的角色中。其实两个人只是角色的对接关系，是没有办法达到彼此的深入了解和深层关系的。什么是深层关系？那就要走到这个角色之下的下一层，第三层。</p><p>从第三层开始就是一个人的深层部分了。</p><p><strong>第三层——资源结构层</strong></p><p>它可能会包括了一个人的财富资源、人脉资源、精神资源，每个人其实都是不一样的。就是我们人生的历程，其实大概在很多时刻，很多人都会处在同一个角色里，比如说我们都曾经是学生，或者是说毕业刚工作的时候，我们都是小职员。但是接下来，因为每个人的资源不一样，大家的精神资源不一样，出身背景、家庭的人脉资源不一样等等。<strong>资源结构会推动每个人，去往不同的地方</strong>。我们可能都曾处在某一个角色中，但未来会进入到不同系统的不同角色中。所以其实到了资源结构的这个层面，好多姑娘已经不会观察，不会判断了。她会看一个人的外表、穿着，或者问一些非常表面化的问题，比如你存款有多少钱？你有房有车吗？如果用我们产品经理的专业术语，这个叫做只抓表面数据，这种用户研究行为其实是非常低级的。如果是只能抓表面数据的产品经理，肯定不可能成为一个优秀的产品经理。就好像是说一个女生，如果她只能基于一个人的感知层、角色层进行交流，或者基于表面数据的存款和房车去对一个人进行判断，那这个人也是没有办法和别人建立深度关系的。</p><p>一个人的内核，就是他的存在感在这个深度关系之外，再往下一层是什么？这个才是一个人真正的内核。下面还有两层，我把它放在一起讲。</p><p><strong>第四层是人的能力圈。</strong></p><p><strong>第五层是一个人的内核，就是他对自己存在感的定义。</strong></p><p>就是他对他自己为什么而存在，到底是怎么感知的。什么状态下，他的存在感得到了充分的满足？什么时候他让他不爽或者烦躁？<strong>存在感之于人就好像生存之于动物一样，是触发情绪和推动行动的开关。</strong></p><p>你观察一个动物，它的状态、情绪，其实都是关乎它的生存需求是不是被满足。狮子为什么要去咬长颈鹿，其实狮子也很吃力、很勉强，但是必须厮杀下去。因为饿，因为生存条件不满足，生存的需求在驱动它。如果它吃饱了，它才不这么费劲呢。所以一个人为什么奔波、焦虑、不安，机关算尽，上窜下跳？其实是因为他的存在感还没有被满足。动物其实只要生存条件满足，它就很愉快了。但是人和人又是不一样的。有的人只要能够在一段关系里，比如说我在一个家庭中，我在和我的爱人的关系中，只要我的存在感是清晰的，对方给了我足够的确认感，我就能够满足。其实很多女孩儿都是这样的。但是有的人，如果只能够在一段关系中找到自己的存在感，是远远不能满足自己的。他需要在职场、在行业中、在社会影响力中，看到自己的存在感，看到别人的重视。其实很多男人是这样的。所以，就像是生存在驱动动物奔波撕咬一样，对存在感的寻求，以及不安全感，也在驱动男人、女人思前想后、废寝忘食、找人找事找钱，去满足自己，去确认自己的存在感。动物其实是在奔波和厮打中强健了自己的肌肉，一个人是为了不断地强化自己的存在感，在左冲右突里扩充了自己的能力圈。</p><p>这就是我们刚才说的最内核是存在感，它的外面一层是能力圈。如果一个人的存在感满足了，其实他的能力圈就不会再扩充了。就好像说好多女人结了婚就不化妆了，男人满足了就不奋斗了是一样的。因为<strong>扩充能力圈其实是一件很痛苦的事情</strong>，你想狮子为了吃饭去杀长颈鹿，其实它挨打也是极其痛苦的。</p><p>五个层次，层层深入。</p><p>现在，我们再把一个人从外而内的五层再拎一遍。</p><p>最外层是感知层，是你看到的一个人的样子，他的相貌、举止、着装。其实当你看到这个人的时候，你要知道有一部分是天生的，有一部分其实是角色化的产物。</p><p>在感知层之内的第二层是角色框架层。</p><p>在角色框架层的再往里的第三层是资源结构层，资源不只是大家一般都会认为的人脉和财产，还包括了一个人的精神结构和他的精神资源。关于这个，我写过一篇文章，我把它整理成了彩蛋，会晚一点放出来，感兴趣的同学可以去看一下。</p><p>在这个资源结构层再往后的一层就是能力圈，在能力圈的里面就是这个人对自己存在感的感知。所以，如果你明确知道自己想成为一个什么样的存在，你就会不断地改变自己的能力圈，改变自己的资源，然后甚至改变自己外在的样子。比如说，在2005年，我同时认识了做豆瓣的阿北、做抓虾的徐易容和做校内网的王兴。其实当时你会发现这三个人很像，都是外表很斯文的文艺男青年，做的都是Web2.0的网站。十几年过去了，这三个人的能力圈和资源结构都发生了非常大的变化，他们的公司也成了完全不同的三个企业。王兴做了美团，徐易容从抓虾做了美丽说，再到现在在做HIGO，而阿北一直在做他的豆瓣，已经快14年了。如果你可以进入到这三个人的内心，你就会发现说，即使是在2005年，在他们外表看上去很像的时候，其实他们内心自己的存在感就是不一样的。</p><p>以上我简单介绍了如何用产品经理看产品的认知框架，一层一层地去观察和分析一个人。对于浅层关系，最表层的感知层就够了。就像你只是打算购买一个产品，那你只要看到最表层就够了。如果你只是想谈个恋爱，并不打算和任何一个人的命运去深入勾连，那你看到最表层也就够了。但是如果你追求的是深度关系和长期关系，那你需要看到的就绝不仅仅是表面上已经呈现出来的结果。</p><p>没有任何一个人是完美适配另一个人的成熟产品，你需要看到的是一个人能够持续让自己变化的内在的动力。然后在漫长的不确定的未来里，明确你们<strong>两个人是不是能够一起拥抱不确定，拥抱变化，在变化中变得成熟，彼此适配，其实这个才是更关键的东西</strong>。所以，如果你只是做用户，想短期关系、捡现成的，那你看到一个人的感知层和角色层就够了。但如果你是要结婚，你要投资一个人，或者你要选择和某个人成为长期的合伙人，那这个人对自己的存在感到底是一种什么样的自我设定和感知，他对自己的能力圈的建设和经营，他对自己的资源的建设和管理才是更重要的。</p><p>到这里，如何用产品经理看产品的认知框架来看一个人就基本上讲完了。</p><h4 id="乔布斯和他的三个女人"><a href="#乔布斯和他的三个女人" class="headerlink" title="乔布斯和他的三个女人"></a>乔布斯和他的三个女人</h4><p>因为我们讲到了用户体验和结婚，这两个话题连在一起，我就实在是忍不住想讲一讲我们产品经理的大神——乔布斯和他的三个女人的故事。</p><p>乔布斯的三个女人，第一个就是布伦南。布伦南17岁读高中的时候，就认识了乔布斯，两人分分合合大概5年。18岁，布伦南第一次怀孕，但是根据两个人当时的协议，她去做了流产。23岁，布伦南再次怀孕，就生下了乔布斯的第一个女儿丽萨。2005年，50岁的布伦南给乔布斯写信，希望乔布斯给她一些钱，乔布斯没理她。2009年，布伦南疾病缠身、穷困潦倒，借住在朋友家，她给乔布斯写邮件说：我病了3年，已经别无选择，我最后一次请求你，请考虑一下为我提供1万美金，帮我度过几个月的时间。2009年那个时候iPhone已经发布了，乔布斯再次封神，我们都对他崇拜得无以复加，这样的大神当天就回复，说：“我不会被要挟。”你听上去，这个回复感觉怎么样？</p><p>接着我们讲他第二个女人，他的第二个女人叫蒂娜。在人生最后的日子，乔布斯和自己的传记作者谈到蒂娜的时候，当时就潸然泪下，他说：她是我见过的最美的女人，她是我真正爱的第一个人，我们是那么的心意相通，我不知道谁还能比她更理解我。你要知道，那个时候其实他和他太太已经结婚二十多年了。当然，他是向蒂娜求过婚的，在1989年的时候，乔布斯向蒂娜求婚，她当时就拒绝了。她说：“爱上一个以自我为中心的人，这种痛苦令人难以置信。”蒂娜曾经在他们的卧室墙上写了一句话：“忽视是一种虐待。”乔布斯肯定觉得自己很爱蒂娜，但是蒂娜显然觉得用户体验实在太差了，没有办法坚持下去。当然你也可以说，其实蒂娜没有那么爱乔布斯。</p><p>第三个女人，其实就是我们都知道乔布斯的太太，劳伦•鲍威尔。劳伦她自己其实说过一句话：“他像激光那么专注，当他的光芒照耀到你身上，你就会沐浴着他的关爱。但是，当他的光芒转移到其他关注点的时候，你就会觉得人生非常黑暗。”我觉得她这句话其实很真实。因为她几乎是用另外一种方法解释了，蒂娜为什么要在墙上写“忽视是一种虐待”。但区别是什么？区别就是蒂娜没有办法忍受，而劳伦找到了消解这种体验的方法。并且她陪乔布斯27年，给了乔布斯稳定的情感支撑，陪乔布斯度过了重返苹果前后的那段很艰难的时日——与癌症作战的最后人生时光。</p><p>所以今天，当我们谈到这位乔布斯的遗孀时，我们更愿意谈，她继承了乔布斯100亿美元的遗产。但如果你听了第一个和第二个女人的故事，你是不是可以想一下，劳伦曾经经历过什么？她承受了什么？又消化了什么？这个女人本身是非常强大的。</p><h4 id="本讲小结"><a href="#本讲小结" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>今天，我们把一个人由表及里的五层讲了一遍，然后又顺便八卦了乔帮主的三个女人，由表及里的对乔帮主的不同体验和感受。这个时候，我们再想一想，你对人的这五层：</p><p><strong>感知层</strong>、<strong>角色层</strong>、<strong>资源层</strong>、<strong>能力圈</strong>和<strong>存在感</strong>。</p><p>你最在意哪一层，你最不能忍哪一层？如果在生命中，你遇到乔布斯，你能和这样的人长相厮守吗？给你个乔布斯你接得住吗？你要不要？八卦就讲完了，我自己非常开心，希望你也喜欢。</p><p>从下节课开始，我们进入正式的课程。</p><h3 id="模块一）-同理心"><a href="#模块一）-同理心" class="headerlink" title="模块一） 同理心"></a>模块一） 同理心</h3><h3 id="03-同理心训练：怎样理解愉悦与不爽"><a href="#03-同理心训练：怎样理解愉悦与不爽" class="headerlink" title="03 同理心训练：怎样理解愉悦与不爽"></a>03 同理心训练：怎样理解愉悦与不爽</h3><p>今天开始，我们进入到第一个模块，<strong>同理心</strong>。</p><p>我们的第一堂课为什么从情绪开始说起？如果把人想象成一部手机，情绪就是底层的操作系统，有的人是iOS，有的人是安卓，大家版本号都还不太一样。你后天学习的知识技能，都是安装在底层操作系统上的，一个一个的App。有人说：“学了很多道理，但还是过不好这一生。”其实我们后天学习的东西，都是理性，理性是把人往回拉的力量。但是驱动一个人的，其实是他的内在感受、他的情绪、他的底层操作系统。我们都会有情绪冲动的时候。你陷入爱情了，你被愤怒、被恐惧控制了，就好像手机系统崩溃了，所有的App全废了。你所有的后天学的知识、技能、理性都不能说服你。知识的调用需要时间和思考，情绪却是一瞬间的体验。</p><p>我们作为一个产品人，为什么要对情绪这么重视？因为用户是无法像专业的产品经理那样，分层次说出他的体验的，他能展现的就是用户情绪。所以我们从一开始，就要学会读懂用户情绪。</p><h4 id="生物性情绪"><a href="#生物性情绪" class="headerlink" title="生物性情绪"></a>生物性情绪</h4><p>怎么分析用户情绪？</p><p>我们从所有生物都一致的底层情绪——“生物性情绪”开始说。</p><p>所谓生物性情绪，就是所有的动物一出生就有的情绪，从你养的小猫小狗，到动物世界里的野生动物，再到咱们人类都有。</p><p>这一课和下一课，我们就来讲讲四种最基础的生物性情绪，他们分别是：</p><p><strong>愉悦、不爽、愤怒、恐惧</strong>。</p><p>今天这一课，我们先说愉悦和不爽这两个情绪。</p><p>在介绍这两种情绪前，我们必须先提出来一个很重要的词。我们的产品工作，以及我们很多的重要观察与洞察，几乎都是围绕这个词展开。这个很重要的词是什么？其实你早就非常熟悉了，这个词就是“<strong>满足</strong>”。</p><p>满足是一个非常重要的词，它也是你可以用来衡量很多东西的刻度：</p><ul><li>一个产品好不好</li><li>你和一个人的关系好不好</li><li>你对你自己的认识</li></ul><p>我们会在这节课的每一个层次里，依次展开这些话题。</p><h4 id="“满足”和“愉悦”的关系"><a href="#“满足”和“愉悦”的关系" class="headerlink" title="“满足”和“愉悦”的关系"></a>“满足”和“愉悦”的关系</h4><p>我们讲第一个情绪词——愉悦。</p><p>什么叫愉悦？</p><p>直接来说，<strong>愉悦就是被满足</strong>。我们知道，生物的本能就是生存，所以它的操作系统，驱动它一切行为，都是为了满足自己的生存。动物的生存条件被满足，比如，一只虫子，一只鸟，一只猫，温度、湿度适宜，有充足的食物，它就会愉悦。而我们人类，不单纯作为生物性的存在，更是社会性的存在。我们不仅需要生存条件被满足，我们还需要在社会关系中被确认。比如度假，住得舒适、吃好吃的，你会愉悦。读喜欢的书，精神上被满足，你会愉悦。你感受到别人的善意，自己被理解，自己被接纳，自己被尊重，自己被重视。这些都是存在感被满足，都会愉悦。</p><p><strong>需求被满足，这种感觉叫愉悦</strong>。</p><p>一种绷了很久的需求，突然间被满足了，这种感觉叫“爽”。大家肯定都玩过俄罗斯方块的游戏吧？下来一个你需要的形状，消掉一行，消掉两行，伴随着消除的音乐，这种感觉叫愉悦。你摞了很高一列，就等一个四格的长条，越等越危险，越等越焦灼。突然，长条下来了，一下子，四行消掉了，这种感觉叫爽。</p><p>拉动你玩游戏的，就是微小的愉悦感，和绷了很久的需求，突然被满足的爽感，加在一起，这种<strong>确定性的满足就会成瘾</strong>。</p><p><strong>微信红包和支付宝红包</strong></p><p>2015年春节，微信和春晚合作，摇一摇有红包，一举让微信支付的用户量过亿。除夕一晚，微信红包的用户量达到1.04亿人。摇一摇，摇红包的互动，一亿人摇了100亿次。送出微信红包1.2亿个，基本上人人有奖。看着别人摇到了红包，自己跟着也摇，摇了几十次，突然间得了一个红包。这感觉，就是爽。</p><p>2016年春节，阿里砸2.69亿元夺下猴年春晚的合作资格，推支付宝红包。阿里肯定不能和腾讯一样啊。阿里怎么干的呢？大家都记得，他干得是，集齐5福，分2亿现金。然后呢？我想你还有印象，一堆人都集了四福，差最后一个敬业福。数据：支付宝发出了82万多张敬业福。集齐五福的有多少呢？79万。如果去年微信红包有1亿人参加，就算参与支付宝活动的用户最少有2000万。如果照2000万用户参与抢支付宝红包，爽的人不到4%，不爽的人大于96%。这就叫有钱任性啊，花5个亿，让96%的人不爽。没关系，阿里爽就行。</p><p><strong>“不爽”与不“满足”</strong></p><p>既然说道了不爽这个词，我们就再把这种感受细致地说说。</p><p><strong>满足就愉悦，不满足就不爽。</strong></p><p>比如，一只虫子，本来温度适宜。突然，温度大幅提升，它就会瞬间不爽。动物是这样，人也如此。如果我没有满足预期，或者我本来在一个满足状态，突然被剥夺了，这也是不爽。而人类呢，用了一堆词来形容不爽的感觉。比如：生气、烦躁、痛苦、厌倦、悲伤、烦恼、茫然等等。但是本质上，这些不爽的感觉，都是某个点没有被满足。</p><p>做产品，是通过产品建立与人的关系，通过产品来服务人，本质就是用户是否通过你的服务得到了满足。</p><p>一个湖畔大学的工作人员和我说，她希望湖畔是一个人EMBA类学习的最后一站，上完了湖畔，就再也别去其他的商学院学习了。我说，这取决于对方内心是不是被满足。对于他是否被满足，你其实是没有办法的。</p><p><strong>满足是度量产品、人与人关系的刻度</strong></p><p>为什么开篇第一课要研究“<strong>满足</strong>”“<strong>愉悦</strong>”“<strong>不爽</strong>”这三个词？</p><p>因为就用这三个词，你可以<strong>度量一个产品到位不到位</strong>。</p><p>当你做一个产品，或者用一个产品，自己有没有被满足的感觉？你基本可以凭此判断，这是个非常好的产品，还是一个勉强的产品。你也可以度量，你和一个人的关系。对方是不是懂得你的满足与不爽，你是不是懂得对方的满足与不爽。如果彼此都不懂，又无法给予对方的满足和不爽，其实，这就是一段勉强的关系。</p><p>此外，你还可以用这三个词“满足”“愉悦”“不爽”来深入探索你自己，认识你自己。你就想想为什么每个人不一样？为什么让你照着PPT练习3次，你就会痛苦。而乔布斯为了苹果大会对着PPT练习100次，依然乐此不疲。为什么你打扫卫生很痛苦，而有人视打扫房间不厌其烦，一天扫三次？为什么同一个点上，有人痛苦，有人愉悦？所以，觉察一下自己，是不是有一件事，你可以不厌其烦地一直做下去？这就是上帝给你初始化的操作系统的密码，你不厌其烦的地方，就是你的天分所在。</p><h4 id="发现你天分的密码"><a href="#发现你天分的密码" class="headerlink" title="发现你天分的密码"></a>发现你天分的密码</h4><p>我们一般认为的天分是显性天分，比如长得漂亮、身体协调、唱歌好听、智商高。</p><p>其实还有一种天分，是隐性天分，他不会两三岁展现出来，让别人看得到。你会对某些东西感到愉悦，这个东西持续给你满足感，你可以一直花时间在这里，不厌其烦。时间久了，其实你就会与众不同。我们都知道天才的1万小时理论。问题来了，一个人为什么会在一件事上花一万小时呢？有些人是不得已。但是多半人，是在深入体验中，找到了满足，找到了愉悦感。持续的满足和愉悦，才能支撑一个人持续投入一万小时。</p><p>最后，我们再谈谈如何理解“满足”“愉悦”“不爽”这三个词，以及怎么通过这三个词，看到自己的天分，看到别人的天分。我们看到优秀的人才会有几个特性：<strong>敏感、不能忍、有动手优化的能力。</strong></p><p>比如，我妈是一个非常优秀的家庭主妇。她一到我住的地方，马上就尖叫：“你住的地方怎么这么乱啊。”——敏感。接着，她不能忍。她其实就在我这儿呆半天，但她不忍，她马上开始收拾。2、3个小时之后，家里顿时就桌明几亮，井井有条，水果洗了摆桌子上。她不能忍，马上就要动手优化。驱动我妈不能忍，马上动手优化的原因是：整洁让她愉悦，乱她就不爽。</p><p>驱动我妈收拾屋子，和乔布斯把一个图标改100遍的驱动力，其实没什么不同。乔布斯改来改去，朝同事发脾气，不是因为他要追求卓越，而是不改到让他满足，他就不爽。他因为极度不爽、不能忍才不停地改来改去。所以，你吸收谁的营养，你就变成谁。你靠什么满足你，你就会成为它的样子。</p><p><strong>什么东西持续满足你，什么东西永远让你不爽，这就是你的命运</strong>。</p><p><strong>本讲小结</strong></p><p>这一课，我们讲了三个重要的词：“满足”“愉悦”“不爽”。三个词很普通，但是我希望你能够发现很普通的词的深意：</p><ul><li>你可以量度，一个产品到位不到位；</li><li>你可以量度，你和一个人的关系；</li><li>你还可以看到，自己的天分和命运。</li></ul><p><strong>课后作业</strong></p><p>好，这一节课的最后，我给你留一个作业：</p><p>其实我们一开始就是讲情绪和感受，你需要体察自己的情绪和感受，并且做出判断。</p><p>我希望你能够再分享一下，你使用产品的真实体验：</p><ul><li><p>你觉得即使吹得天花乱坠，也用起来感受不好，很勉强的产品。</p></li><li><p>当然也欢迎你分享，你用起来很爽，每一点需求都能够得到满足的产品。</p></li></ul><p>非常欢迎把你的感受，在留言区跟我分享，谢谢。</p><h3 id="04-同理心训练：怎样理解愤怒与恐惧"><a href="#04-同理心训练：怎样理解愤怒与恐惧" class="headerlink" title="04 同理心训练：怎样理解愤怒与恐惧"></a>04 同理心训练：怎样理解愤怒与恐惧</h3><p>上一课我们讲了愉悦与难受。这一课我们讲愤怒和恐惧。就好像愉悦与难受是一对感觉，满足就愉悦，得不到满足就难受。愤怒和恐惧也是同生的一对感觉，都是来自于<strong>被侵犯</strong>。但是因为个体不同，对侵犯者的体量判断不同。所以，有时是愤怒，有时是恐惧。</p><h4 id="什么是愤怒？"><a href="#什么是愤怒？" class="headerlink" title="什么是愤怒？"></a>什么是愤怒？</h4><p>愤怒，就是感觉到自己的边界被侵犯。</p><p>动物都有自己的边界。我们都见过，一只狗、一只猫都会用尿液划定自己的领域。如果一只猫在自己划定的领域里，来了另外一只猫，自己的边界被侵犯，这只猫就会愤怒。</p><p>人的边界呢？就是自己的存在感的边界。比如职场上，一个人去抢另外一个人的工作，就是侵犯边界。比如两个女的，开车刮蹭，不一定愤怒。但是如果对方坐她老公大腿上，这个女的肯定就愤怒了，因为边界被侵犯。</p><h4 id="什么是恐惧？"><a href="#什么是恐惧？" class="headerlink" title="什么是恐惧？"></a>什么是恐惧？</h4><p>一只猫在自己的领域里，来了另外一只猫，边界被侵犯，这只猫就会愤怒。但如果来的不是另外一只猫，而是一只老虎，猫就不愤怒了，它会恐惧。</p><p>几个人要来拆你家房子，你可能是愤怒。但如果龙卷风来了，你就不愤怒了，你就恐惧了。</p><p>如果你仔细去分辨，不同的人，愤怒和恐惧的点也不一样。你会发现英雄人物，在常人会恐惧的点，他体现为愤怒。</p><p>比如，有人侵犯你，比如，被偷，被抢，被打。有人呈现愤怒，有人呈现恐惧。比如《勇敢的心》里的华莱士，面对苏格兰统治者的残酷，99%的人都恐惧了，而他是愤怒，所以他是英雄。所以，本质上，愤怒其实是一种恐惧。</p><p>焦虑呢？焦虑也是恐惧。它来自对恐惧的想象。因为是想象，所以无从逃避，所以是一种持续的恐惧，就会内化为焦虑。</p><p>羞耻感呢？羞耻感也是一种恐惧，它来自对社会评论的恐惧。这个我们会在下一课讲。</p><p>这一讲，我想和你认真地谈一下恐惧。为什么？<strong>因为恐惧很重要。是我们观察人和做产品，非常重要的点。</strong></p><p><strong>一、恐惧是边界</strong></p><p>看到火，你就不会伸手，因为有恐惧。看到风高浪大，你就不会出海，因为有恐惧。所以，恐惧会困住一个人的手脚。</p><p>两个朋友，约我去给一个很大的上市公司CEO去讲互联网，还说，如果可以，是不是可以一起帮他做战略规划什么的。我们聊了一下，我就放弃了。我和朋友说：帮这位大佬做互联网战略的这事，我做不了，你也做不了。因为他根本不是看不到互联网的重要和强大，而是他的恐惧，把他在现有的位置、现有的业务里捆的死死的。除非他能卸下恐惧。如果他能卸下恐惧，很多事，他自己就做了，因为他其实都懂。而能帮他卸下恐惧的人，既不是我，也不是你。所以呢？算了吧。这也是我在讲产品之前，要先讲同理心的原因。</p><p>当你很努力地想说服一个人，去做一件你看来非常正确的动作时，对方不动，不是道理他不懂，而是他内心有恐惧，但他不愿意告诉你。在我少不更事的时候，经常几小时几小时地劝别人干这干那。我劝过别人辞职，劝过人分手，劝过人转行，劝过人创业。我一直觉得自己道理讲的可对了，对方也全听明白了，但之后大家多半还是会选择在原地受苦。</p><p>后来，我明白了，劝人就5分钟。5分钟没说动的事，就不再劝了。而是应该想想，捆住他手脚的是什么。是什么把他压在那里，让他没办法往前走。所以，我看到有人在一个没啥前途的公司岗位上待着不辞职不转行，在一段没有爱的关系里呆着被折磨，而不离开，不是对方对她好，有承诺，而是对方抓住了她的恐惧。所以，知道道理，依然过不好这一生。</p><p>就像我上节课讲的，后天的知识技能道理逻辑都是一个一个的APP，而你内在的愉悦、恐惧才是操作系统。有时候你不是缺某个APP，而是你的操作系统，只能支撑你到这里了。</p><p>看到一个人的恐惧，你就基本上知道他的边界在哪里。很多人，我都知道他的恐惧是什么。但是，好像马云没有恐惧，罗振宇好像也没有恐惧。所以，暂时，我还看不到他们的边界。</p><p><strong>二、恐惧是动力</strong></p><p>我们第一节课说，愉悦和满足感会支撑一个人在一个地方投入一万个小时，从而使这个人成为天才。其实恐惧是另外一种动力。甚至比愉悦的动力更为强大，或者说更强劲。</p><p>有时候，你看到一个人兢兢业业，完全忽略自我的身体感受和家庭体验，一切以这件事为核心，彻底忘我。他是因为愉悦吗？很多时候，是因为恐惧。所以，面对一个年轻人，如果他在工作中，既没有愉悦，也没有恐惧。你基本上可以判断，他在这件事上，不会有什么成就。</p><p><strong>三、恐惧是痛点</strong></p><p>做产品就要抓痛点，我们都了解。但是什么是痛点？</p><p>很多人会把“难受”当痛点。生活中确实有很多不爽，我们已经说了很多词了，生气、烦躁、不爽、痛苦、厌倦、悲伤、烦恼、茫然。所以，要么做一个让人愉悦到爆爽的产品，要么做一个可以帮人抵御恐惧的产品。</p><p>如果做一个看上去可以某种程度帮人不再难受，而在“爽”和“恐惧”无所作为的产品，那就是一个不痛不痒的产品，也许也有人会买单，但绝不会大火。</p><p>每个人的痛点都是他的恐惧，恐惧是痛点。人们会为了解决恐惧，毫不犹豫地花钱。所以中国的医疗和教育，是最大的市场，为什么？对生存的恐惧。为什么医美产品比普通化妆品贵那么多？对青春流逝的恐惧。听罗辑思维、用得到，为什么啊？认知焦虑，还是恐惧嘛。</p><h4 id="本讲小结-1"><a href="#本讲小结-1" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结这节课的内容，就是如何找产品的接入点或者怎么改变自己的人生。</p><p>其实就是四个字：<strong>直面恐惧</strong>。</p><p>课后作业</p><p>我们需要体察自己的情绪，然后在这种情绪中看到产品的机会。</p><p>你可以分享一下：</p><p>你最近看到了什么样的产品，是在力图帮你抵御恐惧？</p><p>哪些产品对你的恐惧，解决得很好？</p><p>哪些产品是想解决你的恐惧问题，但其实效果很勉强？</p><p>欢迎你在留言区写下答案。</p><h3 id="05-同理心训练：产品要顺应用户潜意识"><a href="#05-同理心训练：产品要顺应用户潜意识" class="headerlink" title="05 同理心训练：产品要顺应用户潜意识"></a>05 同理心训练：产品要顺应用户潜意识</h3><p>这节课我们来讲<strong>潜意识</strong>、<strong>防御</strong>与<strong>说服</strong>。</p><p>三大产品经理做出了全世界最大的三个社交网络产品，他们分别是：</p><ul><li><p>做出了Facebook的扎克伯格</p></li><li><p>做出了QQ的马化腾</p></li><li><p>做出了微信的张小龙</p></li></ul><p>这三个人有一个共同点，就是性格内向、不爱社交。</p><p>为什么性格内向，甚至有社交障碍的人，却会做出亿万人依赖的社交产品？</p><h4 id="一次失败的用户调研"><a href="#一次失败的用户调研" class="headerlink" title="一次失败的用户调研"></a>一次失败的用户调研</h4><p>我先不回答这个问题，而是谈我的另外一个观察：大量沟通能力强、长袖善舞的人，比如优秀的销售人员、BD人员，很难成为优秀的产品经理，比如马云校长。</p><p>我给你讲一个沟通的场景。</p><p>我和同事曾经让一个原先做销售做得很优秀的女孩尝试做产品。这个女孩长得漂亮，沟通能力强，擅于在公司抢资源。她自己申请转行做产品经理。我们就让她试试。先让她拿着我们产品的交互稿，去跟几个抽样用户沟通，做她的第一次用户研究。我在之前讲到过，用户就是普通人，他们不会像产品经理一样，有一个思考框架，知道如何有层次地表达感受和体验。作为一个用户，他的表达是混沌的、完全没条理的。在这个女孩的沟通现场，大家乱糟糟地发言，有人讲自己的观察，有人讲自己的感受，有人讲自己的评判，有人讲自己的需要，有人说自己的请求和愿望，有人则直接开始讲故事。这个女生越听越觉得乱，最后终于忍不住了，说：“要不还是我先来给大家介绍一下，我们产品的设计想法。”于是她施展销售的说服功夫，把所有人都说服了。大家认为我们设计得很好，很有道理。于是用户沟通会友好地结束。</p><p>这是什么？这就是一次失败的用户调研。</p><h4 id="为什么用户会口是心非？"><a href="#为什么用户会口是心非？" class="headerlink" title="为什么用户会口是心非？"></a>为什么用户会口是心非？</h4><p>我再举一个正确的用户研究场景。</p><p>Sony准备推出Boomboxes音箱，他们召集了一些潜在的消费者，组成焦点小组，来讨论这个新产品应该是什么颜色：黑色还是黄色。经过这一组潜在购买者的讨论，每个人都认为消费者应该更倾向于黄色。这次会议后，组织者对小组成员表示了感谢，并告诉他们，在离开时，每个人可以免费带走一个Boomboxes音箱作为回报。他们可以在黄色和黑色之间任意挑选，结果每个人拿走的都是黑色音箱。</p><p>人为什么口是心非？用户研究到底要怎么做？</p><p>因为人会基于自身所处的角色、所在的场景和个人的认知判断，选择性地说一些他觉得正确的话。但是，我认为在这个场景中所谓“正确的话”，并不代表这个用户真实的选择。所以，如果我不是在公开的角色中，或特定的场景下，我回家自己看个影片、选个产品，还是会按照自己的真实需求来。</p><p>所以不要被言辞迷惑，而要想办法看到用户的真实选择。</p><h4 id="好销售和好产品经理的区别是什么"><a href="#好销售和好产品经理的区别是什么" class="headerlink" title="好销售和好产品经理的区别是什么"></a>好销售和好产品经理的区别是什么</h4><p>这也是为什么明明我的课是产品课，但是开篇的前五讲，完全不谈产品本身，而是讲情绪、讲潜意识、讲集体人格。</p><ul><li><p>体会各种人的情绪与潜意识；</p></li><li><p>不被一个人基于角色化交流而说出的言辞所迷惑；</p></li><li><p>看到人基于潜意识流露的真实选择。</p></li></ul><p>只有当你能做到以上几点，你才有了做一个好产品经理的开端。</p><p>一个好销售擅长的就是打破防御，因为任何一个人对销售人员一定是防御的。销售人员要充分调度自己可以呈现的所有资源：自己的外貌、仪态，产品包装、价格折扣。从用户意识层面，让用户认为自己获得了专业服务，而且赚了便宜。从用户潜意识层面，再抓住用户心理上小小的满足或不安，打破用户的防御，说服用户，促成用户的选择。这是一个好销售干的事。</p><p>一个好产品经理，则是根本不让用户启动防御。因为一个产品没有表情，没有声音，无法拉住用户的衣服苦苦哀求，甚至不能让用户多注视一会儿。一个产品如果引发用户启动意识，让用户思考，某种意义上，就是在推开用户。为什么？因为，意识即防御。</p><p>所有的思考，其实都会让你产生顾虑。你让用户思考，就是让用户戒备。一个不会说话的产品，根本没有消解戒备的机会，所以马化腾非常推崇的一本书叫《Don’t Make Me Think》，翻译成中文核心意思就是“别让我思考”。对用户防御的态度和敏感度，也是一个好销售和一个好产品经理的区别。你会发现好的销售人员都是有攻击性的。为什么呢？因为他的工作就是要突破别人的防御，他们对突破别人的防御是有成就感的。好的销售非常懂得在与人直接沟通中，如何适当地给对方压力，抓住对方意识与潜意识的抓手，说服对方。在这个过程里，他自己也会获得足够的快感和红利。</p><h4 id="产品是被动的艺术"><a href="#产品是被动的艺术" class="headerlink" title="产品是被动的艺术"></a>产品是被动的艺术</h4><p>但是像扎克伯格、马化腾和张小龙，他们为什么不爱社交？本质是因为在社交中，如果碰到别人对你建立防御的情况，你就手足无措。你不愿意突破别人的防御，也就没办法在社交中获得快感，长此以往就越来越不爱社交。快手的创始人宿华，其实也是这样。</p><p>这些优秀的产品经理退到网络背后，根据数据看到了人们在独处时，在没有压力的状况下，潜意识流露而做出的自然选择。他们对用户的行为不评判、不教育，最多就是柔性地引导，多半的时候只是默默响应和持续地服务。快手的宿华曾经说：“让产品自然生长，不要去碰用户，不要去打扰他们，让他们自然地形成一种互动关系。”这个说法有点玄，但是很真实。作为静态的产品，其实是没有机会说服用户的。所有让用户思考、琢磨一下的产品，其实都是给自己抬高门槛，降低转化率。</p><p><strong>一个产品要做到的就是迎合用户潜意识下的选择</strong>。所以我的一个朋友，烟酒营销大师李克，他说包装的经验，最核心的一条就是——规模感。明明是烟草新品，但是包装一定要让用户觉得很熟悉。<strong>熟悉的感觉就是潜意识里觉得安全的感觉，这样就不会触发防御。</strong></p><h4 id="潜意识是如何形成的"><a href="#潜意识是如何形成的" class="headerlink" title="潜意识是如何形成的"></a>潜意识是如何形成的</h4><p>说了这么多潜意识，潜意识是心理学里非常重要的词，有志于做产品的同学一定需要花时间去研究。这个产品课只能强调它的重要性，不展开讲。我们潜意识里已经存在的东西，是什么时候被放进我们的潜意识中去的呢？简单说，有两种情况。</p><p><strong>一种是在你童年的时候</strong></p><p>因为那个时候什么都不知道，还没有建立意识和防御去辨别。这时的观念就会直接进入你的潜意识，成为你最内在的感知、你本能情绪的一部分。所以为什么说要了解一个人，需要了解他的童年。你想了解一个人的关系模式，最好是了解他童年时与亲近的人之间的互动模式，这几乎就是一个人一生的模式。</p><p><strong>另外一种情况，是一个听上去很玄的词——催眠</strong></p><p>“催眠”这个词其实是来源自一个德语词汇，本意是“绕过防御”。但是让中国人一翻译，就搞得很玄乎。那催眠怎么做呢？本质就是绕过防御。讲催眠的书有一大堆，做产品的人应该系统地学学。微笑是一种催眠，因为它会让你放下防御。重复，是非常重要的催眠，这是我们生活中使用的最重要的方法。所以李开复讲，重要的话要讲30遍。比如雷军是个催眠大师。我们经常听说他劝人，能一劝8个小时、10个小时。从心理学来说，这其实也是一种催眠策略。这么高强度的疲劳战术，对方总有意识松懈的时候，只要一松懈，重复的想法瞬间就被植入他的潜意识中了。所以大家都说雷军给别人刷ROM的能力很强。另外，“送礼要送脑白金”，这种持续重复的广告也是催眠。一些社会观念无孔不入的传播也是催眠。</p><p>如果我们有共同童年，曾经在同一个单位里，在同一个文化场景中，被反复灌输一些观念，其实我们就被共同催眠了。我们会有相似的观念，被类似的观念束缚，有了共同的样子，这就是集体人格。比如湖南人有湖南人的样子，东北人有东北人的特点。从公司来讲，联想人有联想人的样子，腾讯人有腾讯人的特征，阿里人的特点又和这两家公司的人不一样。所以如果你为一个集体做产品，需要研究集体人格。</p><p>关于集体人格我们会在下节课具体介绍。</p><h4 id="本讲小结-2"><a href="#本讲小结-2" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结一下这堂课：</p><p>与人交往，或者做一个产品让别人用，怎么能够突破防御，让对方接受你，说服别人、驱动别人，其实都是一回事。人做一个动作，也许是意识判断，但是70%是潜意识的选择。</p><p>基于意识与人交流，其实是高防御模式。基于意识清醒的交流，达成交易的唯一方式，就是让对方清晰地感觉到一点——“我占了便宜”。小米手机重复性价比的宣传口径，是一个基于意识判断的沟通策略。但更多的时候，在意识没有启动之前，人已经基于潜意识建立了判断，并做出了行动准备。所以，如果你不能用持续高压灌输、高频重复的方法，改变对方的潜意识，那么就要放下自己的主观愿望和判断，放下显示自己高明、教育用户、说服用户的念头。</p><p>作为一个产品经理，要做的事就是不让用户启动防御。主观愿望过强的产品经理，非常容易犯想当然的错误。如果要做一个拥有大用户量的产品经理，你会看到的是“人欲即天理”，要尊重人欲。</p><p>所谓的用户调研，就是清空自己，接纳别人的世界观。</p><p>课后作业</p><p>在这节课的结尾，给你留一个作业：</p><p>你最近用到什么产品，几乎你是不加思考就完成了使用，使用过程感觉很熟悉、很自然？</p><p>你接触到了什么产品，乍一看觉得这个东西得琢磨一下，然后想了想就放弃了？</p><p>回忆一下，自己的潜意识里那些说服和防御的过程，在下面跟我分享一下。</p><h3 id="06-认清人的本性，理解角色化生存"><a href="#06-认清人的本性，理解角色化生存" class="headerlink" title="06 认清人的本性，理解角色化生存"></a>06 认清人的本性，理解角色化生存</h3><p>我养了五只寄居蟹。寄居蟹是一种外形又像螃蟹、又像虾，寄居在其他壳里的小螃蟹。像我这种做事特别认真的人，养个寄居蟹也得记日记。所以，我按照每一只寄居蟹的壳的形状，给它们分别起了名字。但我后来发现，养了它们这么久，我却根本不认识这几只寄居蟹，我只认识它们的壳。比如有一个白壳的寄居蟹死了，壳就留在缸里。过几天我发现，这个白壳又在缸里四处活动。原来是其他的寄居蟹钻进了这只壳里，顶着这个白壳继续生活了下去。我觉得这就像是皇帝死了，很快又有其他人穿上龙袍，坐在龙椅上，继续当皇帝。皇帝谁来当其实对于老百姓来讲都一样，我也不认识皇帝这个人，我只认识这个角色。</p><p>就好像生活中，你会认识一个张处长、一个李局长。但你其实根本就不认识这个人，你认识的只是他的壳、他的角色而已。所以，当你初步去接触一个人或者一群人时，你一开始看到的其实也只是他（们）的角色。就好像你看一只寄居蟹，你只看到它的壳一样。</p><h4 id="集体就是一堆角色"><a href="#集体就是一堆角色" class="headerlink" title="集体就是一堆角色"></a>集体就是一堆角色</h4><p>这节课我们讲的是集体人格，首先我们来讲什么是集体？</p><p>集体其实就是一堆角色。咱们从小的教育其实就是角色化教育，<strong>角色化教育的目的</strong>是什么？就是要训练你成为我需要的那个角色。你要成为好学生，好学生是个角色；你要成为好孩子，好孩子是个角色；好儿子是角色；好女儿也是角色。所以，为什么孔子对于中华民族是非常重要的人，因为他给我们整个民族都写了角色说明书：君君臣臣、父父子子、夫妇。两千多年以来，我们一直在用孔子定义的角色和角色关系来安放自己，来处理我们的关系。</p><p>你会发现中国人和外国人，在很多地方的心理预期是不一样的，比如对自我的感受、对关系的预期。为什么？因为角色说明书不一样。所以在角色里，你是什么样的人，你的感受是什么，这些是不重要的。重要的是，壳是什么样子的，角色要求你成为什么样子。当我们都被角色训练好，收敛自我，钻进一个同质化的壳里，我们就成为了一个集体。这群钻进了同质化壳里的人，就会呈现出来一种集体人格。</p><h4 id="集体人格是怎么形成的"><a href="#集体人格是怎么形成的" class="headerlink" title="集体人格是怎么形成的"></a>集体人格是怎么形成的</h4><p>集体人格是怎么形成的？我们是怎么被训练成为角色的？在回答这个问题之前，我先说说怎么得到一只听话的小狗。这个过程大概是这样的。</p><p>首先，你要给狗狗准备一个垫子。刚一开始它肯定是什么都不懂，在屋子里随便到处小便，这个时候你就要呵斥它。肯定会有一次，它偶然地做对了动作，尿在了垫子上，你就要立刻奖励、反馈——抚摸它、夸奖它、给吃的。然后不断重复，你就会得到一只在垫子上尿尿的狗了。</p><p>这其实也就是我们被教育的过程。这个过程我们稍微拆解一下，一共有五个关键动作：</p><ul><li><p>第一个，<strong>确定目标</strong>。</p><p>你要知道这一次教育或者培训的目标是什么，要树立一个什么样的观念。我们给狗狗的观念就是说不能随便尿尿，只能尿在垫子上。</p></li><li><p>第二个，<strong>建立恐惧的边界</strong>。</p><p>你需要让狗狗知道，它没有做被希望的事情就会被呵斥，甚至惩罚。这时候狗狗就会建立恐惧，它知道自己的行为会被惩罚。</p></li><li><p>第三个，<strong>放入清晰的标的</strong>。</p><p>正确的动作只有一个，就是在垫子上尿尿。</p></li><li><p>第四个，<strong>给予红利</strong>，然后让它产生路径依赖。</p><p>尿在垫子上就被奖励，听话的孩子就有糖吃。</p></li><li><p>第五个，<strong>不断重复</strong>。</p><p>重复是动作的关键，重复还可以树立榜样。</p></li></ul><p>于是，小狗就会产生角色化的行为，尿尿只尿在垫子上，因为不尿在垫子上就会被惩罚。</p><p>好，我们再来问，为什么要训练小狗，让一只狗狗产生只能尿在垫子上的观念？为了便于管理。也就是说，我们从小所受的教育，工作之后所受的培训，目的只有一个，就是为了便于被管理。如果说尿尿只能尿在垫子上是违反狗性的，那么其实<strong>教育是违反人性的</strong>。</p><h4 id="教育是反人性的"><a href="#教育是反人性的" class="headerlink" title="教育是反人性的"></a>教育是反人性的</h4><p>暴风影音的冯鑫给我们分享过他读《道德经》的心得。他用理工男擅长的归纳法，把《道德经》里所有的高频词全都数了一遍。《道德经》里出现最多的一个字，你猜是什么？是“反”，这个“反”字一共出现了12次。冯鑫说：“你看《道德经》是讲自然规律的，但是你认真读完以后，你会发现其中所讲的大量规律，与我们的认知是相反的。”我当然认同，其实教育就是反人性的。如果一个人没有被教育过，那他就是没有羞耻心的，就是懒惰的。但是我们为什么要受教育？教育是按照人类对社会的美好期望来教育你，换句话来讲，所有的教育都是理想化的。如果人本身就是这个样子，也就没必要教育了。</p><p>比如我们小时候看《梁祝》里那种至死不渝的爱情、《三国演义》里“刘关张结义”那种同生共死的友谊，你就会以为爱情、友谊就应该这样。在人世活了半生以后，你才会发现真实的人世间不这样，这样的友谊与爱情真是少之又少的小概率事件。所以这样的友谊和爱情才会成为传奇，才会被传颂。如果满地都是这样的友谊和爱情，大家就不传颂了。书读得越多的人越容易理想化，说得俗一点，就是不接地气。</p><h4 id="产品经理应该如何看待角色"><a href="#产品经理应该如何看待角色" class="headerlink" title="产品经理应该如何看待角色"></a>产品经理应该如何看待角色</h4><p>明明这是产品课，为什么要谈角色化和集体人格呢？</p><p>我经常遇到一些很初级的产品经理，讨论过程中他们特别喜欢用一个词：“应该”。他们认为用户应该这么做。</p><p>比如一个母亲就应该如何，她就应该具备某种能力、某些认知，因此她选择时的权重次序就应该是这样。但你凭什么这么认为？母亲其实只是一个角色。只有在很大的压力下，人才会按照角色行事。一个人忙了一天回到家，坐在沙发上，掏出手机想休息一会儿的时候，凭什么你认为她“应该”继续完成角色，并且按照角色的设定点点戳戳你的产品呢？</p><p>我补充正反两个例子：</p><p>第一个，举一个正面例子。</p><p>微信之父张小龙认为：“<strong>好的用户体验，目标就是做到自然。</strong>”</p><p>什么叫自然？自然和角色化是相反的两个词。</p><p>举个例子，3岁的小孩用iPhone就很容易上手。比如iPhone的开锁，小孩不用学就会用，因为触摸是人的天性。小孩是看不懂文字的，但是他知道触摸、滑动，通过iPhone上的箭头一滑就解锁了。再比如用手一撑图片就放大了，这个不需要教，小孩天生就会。这就叫自然。</p><p>第二个，再举一个反例。</p><p>我有一个女性朋友，她在外企工作，在职场上非常优秀，但是她在谈恋爱的时候老是有问题。我跟她沟通以后就发现，她对男友或者丈夫，有太过于刻板的角色化预期。她喜欢上班，因为上班的时候是角色化的对接，所有人该如何对接、如何预期、如何反馈，这些都很清晰。但是下了班回到生活中，该如何与生活中的人相处、有什么样预期和反馈，她就不明白了。她觉得她的男友或者丈夫，为什么老是不能够按照自己的预期去行动呢？但对方凭什么按照你的预期去行动？</p><p>这个问题和产品经理新手遇到的问题是一样的。他们已经习惯了角色化思考，放弃了对一个真实、完整、鲜活的人的观察和接纳。人其实只有在压力非常大的情况下，才会去扮演角色。除非你能给他的压力非常到位，否则就不要对他做角色化预期。</p><p>如果你是想做一个能让用户放松使用的产品，或者你想和一个人拥有轻松惬意的亲密关系，那你为什么要给对方那么大压力，让对方来扮演你所期望的角色呢？所以，基于角色化预期其实很难和人互动。不管是在生活中真实地与人互动，还是通过一个产品与人互动，你都很难基于角色化预期做到。</p><h4 id="集体人格"><a href="#集体人格" class="headerlink" title="集体人格"></a>集体人格</h4><p>再来谈集体人格问题。</p><p>有一次和钉钉App的产品经理交流，我就说钉钉反人性。他回答：“对，因为我们是给一个集体做产品，集体人格就是反人性的。”他说得好有道理，我竟无言以对。</p><p>如果你的产品的使用对象是一个“个体”，那你必须要抛开对个体角色化的刻板想象，而把对方当成一个完整的、鲜活的人，去做用户研究。但是如果你是在给一个特定的集体做产品，那么其实你应该充分研究这个集体的集体人格、共同记忆和核心观念。</p><p>举一个最简单的例子。小米拍了一个广告片叫《100个梦想赞助人》，大概就是讲前100个小米粉丝的故事。广告片播放的时候，小米的几个合伙人热泪盈眶，但我坐在旁边就很尴尬。因为我完全不知道它在说什么，我没有这个片子传递的记忆，我也不知道这个片字传递的观念是什么。这个产品其实是精准地投放给属于这个集体的人。因为我不属于这个集体，所以我是个无效用户。</p><h4 id="本讲小结-3"><a href="#本讲小结-3" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>这节课就到这里，总结一下：</p><p>人是因为训练和压力才成为角色的，而集体就是角色的聚集。</p><p>如果你想做一个好的产品经理，那么首先要学习的就是通过“去角色化”来研究真实的用户，而不是用一堆“应该”来臆测用户的行为。</p><p>如果你希望用户在很放松的情况下，毫无压力地、自然地使用你的产品，或者你想找到在生活中可以放松惬意相处的伴侣，那么你就要放弃对人的理想化、角色化预期，去认识并接纳那个在“寄居蟹的壳”下面真实的人。角色化生存就是我们真实的生存处境，但是只有去角色化地认识、沟通、交互，你才能够得到真正的感情。</p><p>课后作业</p><p>角色化生存，基本上是我们现代人生存的真实情况，既是方便，也是痛点。</p><p>1.你觉得自己是不是擅长角色化生存，或者擅长把别人训练成角色呢？</p><p>2.你能够去角色化地和别人建立真实的交流吗？</p><p>欢迎分享你的故事。</p><h3 id="07-自我与自律，哪一种更贴近产品精神"><a href="#07-自我与自律，哪一种更贴近产品精神" class="headerlink" title="07 自我与自律，哪一种更贴近产品精神"></a>07 自我与自律，哪一种更贴近产品精神</h3><p>这是第一模块的最后一讲。我们之前用了四讲来讲怎么观察别人，这一讲我们回到自己。</p><p>良好的产品思维是今天最稀缺的职业能力。那么，具有什么天赋的人，最适合做产品经理呢？</p><p>我一直在思考这个问题，但久久没有找到合适的答案。没想到，我竟然在自己学绘画的过程中得到了启发。这个发现，要归功于我学绘画用的一本书——《五天学会绘画》。这本书不仅帮我在短期内提升了绘画水平，而且让我发现了一位优秀的产品经理和其他的管理者，在思维方式方面的最大差异。</p><p>我的结论是——做产品经理的人善于感知，能在已经有结论的地方建立新观点。而做其他管理地人更善于逻辑推理和总结归纳。</p><p>有一种流行的说法，把善于观察、发散的思维叫做右脑思维，把善于逻辑归纳的思维叫做左脑思维。其实学界已经证明，人的左右脑管辖区域并没有那么明显的区分，但这两个概念已经被人熟知。《五天学会绘画》这本书里也用了这样的说法，为了便于理解，本讲下文且用“右脑”代指擅长观察发散的思维方式，“左脑”代指逻辑归纳的思维方式。从学绘画中，理解两种思维我先介绍一下这本书的核心内容。</p><p>《五天学会绘画》首先抛出了一个问题：随着年龄的增长，人的手做精细动作的能力越来越强。但是，为什么一般人的绘画能力，却停留在孩子的水平？作者的解答是：因为9岁之后，大部分孩子的时间被学校的系统训练占得满满的，而学校的教育一般只开发左脑，训练我们的判断、逻辑、效率等能力。所以9岁之后，我们的认知就被左脑主导了。左脑指导我们把握要点，快速概括。</p><p>《五天学会绘画》的解决方法是：不要去画你认为自己看到的东西，那只是你左脑的判断。具体怎么做？书中给出的训练方法就是——想办法绕开左脑。</p><h4 id="怎么绕开左脑呢？"><a href="#怎么绕开左脑呢？" class="headerlink" title="怎么绕开左脑呢？"></a>怎么绕开左脑呢？</h4><p>画画的时候，不要急着用线条概括你要画的主体，而是要描绘主体和背景之间的边线。然后，你会发现所有物体的边线都是共享的。如果你要画一个放在桌子上的杯子，那就忘掉杯子本身，去描摹杯子和桌子交界处的边线。因为杯子的边线，也是桌子的边线。看起来是你一直在画桌子的部分，但其实空出来的地方就是那个杯子。这样你能得到的画面，会比直接画一个杯子拥有更丰富的细节。</p><p>把这个方法迁移到我们的思考习惯中，当你积极用左脑思考时，学校训练的知识、效率、时间观念等，会从你的潜意识中冒出来。你按这种思路画出的东西，一定不是你能最大化观察到、感受到的，而是左脑认为效率最高的。所以用《五天学会绘画》的逻辑来推论：</p><ul><li><p>被认为算“左脑思维”的人逻辑推理能力强、时间观念强，同时感受力差；因为感受力差，所以没那么敏感和情绪化，整个人体现为情绪稳定，甚至刻板；更容易根据规则调适自己，更自律，更容易角色化。</p></li><li><p>而被认为算作“右脑思维”的人，就正好相反，感受力强；能在别人已经有结论的地方，建立自己的新观察，并且不太喜欢听已有的逻辑；难以控制自己的情绪，能激情地表达自己，具有人格魅力。</p><p>这些人还有一个特点是时间观念差，比如开会原本预计一个小时，激情上来了，可能变成4个小时，把后面的事都耽误了。这样的人非常自我，也因此会非常自私。</p></li></ul><h4 id="自我的人更适合做产品"><a href="#自我的人更适合做产品" class="headerlink" title="自我的人更适合做产品"></a>自我的人更适合做产品</h4><p>这两类人，哪类人适合做产品经理？</p><p>答案是，自我的人更适合做产品经理。因为创造力是自我的延伸，而控制力是自律的延伸。创造力要求对自我有极深的体察和释放，但控制力是自律的体现，是社会化的产物，是对别人的体谅与迁就。人长期关注什么，就会认为什么东西更重要。自我的人长期关注的就是自己，所以必然自私；自律的人，长期关注的是外部的边界和规则，所以这类人有克己奉公的精神。一种人更关注我喜欢什么，而另一种人更关注什么是对的。</p><p>比如说，联想培养的人是自律的人，腾讯更能够容纳自我的人。我曾给不同的企业推荐过几个很优秀的腾讯产品经理，对方的评价都是：这个人太自我了，对自己考虑得太多，没办法用。我心里默默想，你们为什么不深思一下，为什么你们觉得没办法用的人，腾讯可以用。</p><p>还有一个问题，为什么优秀的女性产品经理很少？其实本质原因是相同的。我们上一节讲了集体人格，女性也是一种集体人格。所有的社会观念在潜移默化地要求女性，说女性应该是隐忍的、体谅的、照顾他人感受的。在这种集体人格的塑造下，女性很难去为难别人，容易觉得过意不去。</p><p>自我并且自私的人天然没有这种障碍。我曾与一个很优秀的产品经理一起协作。他要挑一张App的开机图，图片闪现时间其实不到1秒。他挑了100多张图都不满意，最后挑到设计师无法忍受，提出了辞职。当我告诉他，和他配合的设计师要辞职时，他的第一反应是：“新的设计师什么时候到？得接着改。”一个优秀的产品经理，比如乔布斯，会把他的设计师和工程人员逼疯，会把对方骂得死去活来。这么做是因为乔布斯真的受不了，但他根本不关心与自己合作的人是死是活。</p><p>刚才我们说的产品经理的特点——感受力强、暴躁、情绪化、无时间观念、自我、自私……乔布斯每条都符合。所以，一个优秀的产品经理，有可能是一个在工作集体中或者生活中让你觉得非常讨厌的人。</p><h4 id="找到自己，接纳他人"><a href="#找到自己，接纳他人" class="headerlink" title="找到自己，接纳他人"></a>找到自己，接纳他人</h4><p>说到这里，可能会有人问：我应该自我呢？还是应该自律呢？</p><p>当你问出这个问题的时候，本质上你关注的就是规则与边界，其实你就是个挺自律的人。但是，我们可能每个人都是在这种自律的、集体主义的氛围中长大。所以即使再自我的人，可能都得有一部分学会自律。你可能还会问：未来我应该释放哪一方面的能力呢？</p><p>找到你自己的愉悦或者恐惧吧。</p><p>靠愉悦驱动的人，往往自我。</p><p>靠恐惧驱动的人，往往自律。</p><p>这两者，都会催生非常优秀、非常成功的人。</p><p>每个希望成大事的人，都需要想办法接纳与自己完全相反的那个人，让他成为你亲密的合作伙伴。</p><h4 id="模块小结"><a href="#模块小结" class="headerlink" title="模块小结"></a>模块小结</h4><p>到这里，第一模块——同理心，就讲完了。</p><p>我们内在的愉悦、恐惧、潜意识与集体人格，共同形成了我们自己。当你要认识一个人，或者要做一个产品时，你要思考自己到底要在哪个层面下功夫？你还是要回到自己的内心，看到自己的愉悦与恐惧，看到自己的天分，看到用户的愉悦与恐惧，了解他们的潜意识和集体人格，不要触发他们的防御。这就是你的起点。</p><p>从这个起点开始，我们要进入第二模块：机会判断。第二模块的第一节课，从一个点开始——点线面体的战略选择。</p><p><strong>课后作业</strong></p><p>1.你觉得你是一个更加偏自我，还是一个更加偏自律的人呢？</p><p>2.你有没有过与“和你完全相反的人”合作的经历？如果有，你们是怎么相处的？</p><p>除了回答以上的问题之外，如果你有任何关于产品的问题，欢迎你在留言区分享。</p><h3 id="模块二）-机会判断"><a href="#模块二）-机会判断" class="headerlink" title="模块二） 机会判断"></a>模块二） 机会判断</h3><h3 id="08-机会判断：点线面体的战略选择"><a href="#08-机会判断：点线面体的战略选择" class="headerlink" title="08 机会判断：点线面体的战略选择"></a>08 机会判断：点线面体的战略选择</h3><p>这一课，我们开始进入第二模块——机会判断。</p><p>本模块第一节，我讲一个非常重要的战略判断框架。这是一个非常简洁的思考结构，叫<strong>点线面体</strong>。</p><p>点线面体是曾鸣教授的理论，他在得到App的课程《智能商业20讲》中做了阐述。我也从曾鸣教授这个新型的定位方法中收益良多。我和他说要在我的产品课里，把我的理解再讲讲，获得了他的授权。</p><h4 id="富人与穷人的区别"><a href="#富人与穷人的区别" class="headerlink" title="富人与穷人的区别"></a>富人与穷人的区别</h4><p>有句老话说：男怕入错行，女怕嫁错郎。说的就是怕选错。</p><p>举个例子，有一对双胞胎，在2010年一起大学毕业，一个加入腾讯，一个进入报社。7年之后，去腾讯的那位已经是年薪百万，而且满街都是挖他的猎头。投资人也在挖他，只要出来创业就给钱。去报社的那位，因为报社沉沦了，他曾经寄托理想的整个产业都没有了，一切都需要重来。</p><p>这里不是说双胞胎的素质或者能力有多大差异，也不是说他们分别跟随的领导的能力或者个人操守有问题。核心问题是这两个单位所附着的经济体，一个在快速崛起，一个在快速崩溃。这就是我们要谈的点线面体。</p><p>其实我们都有体会，努力工作的工资收益，远远不如2013年以前买了腾讯的股票，或者2010年以前买了北上广的房子。为什么？<strong>因为你再努力工作，你还是一个点。一个月或一年的工资，只是一个点的努力成果。</strong>但是腾讯股票与北上广房子的收益，是因为这个点附着于一个快速崛起的经济体，这是一个线性周期的结果。对于做投资来说，<strong>你需要首先选择某个正在崛起的大型经济体，接着去找一个领域，投它的成长周期。</strong>所以你会发现很多投资人，会投资一个赛道上所有的产业。为什么呢？因为他不赌单点，而是整个周期的收益。比如金砖四国的概念，是高盛公司包装出来的投资概念。他们要寻觅大型经济体的崛起，再从这种大型经济体里找到自己的位置。</p><p>所以，普通人和富人的区别是什么？</p><p><strong>普通人勤恳努力、斤斤计较，他在意的是每一个当下的点，而任何一个点都不会产生过多的收益。</strong>如果要成为中产，至少要获得一次线性周期的收益。比如持有腾讯股票10年，什么都不用干，10万变1000万。<strong>那么成为富人呢？就要借助面和体的崛起。</strong>当你选择要做一个产品的时候，你不但要投入自己的时间和资源，还要“忽悠”更多人，把他们的时间和资源一起投入进来，这也是说你要为更多的人负责。你在做选择的时候，要看到你切入的点是在一条什么样的线上，这条线在一个什么样的面上，以及这个面又处于一个什么样的体上。你面对的是什么竞争，是来自对手的竞争？还是来自趋势的竞争？所以，<strong>点线面体的战略选择非常重要。你再怎么优化产品、提升效率，一旦点线面体选错了，都是白搭。</strong></p><h4 id="安全市场的两次颠覆"><a href="#安全市场的两次颠覆" class="headerlink" title="安全市场的两次颠覆"></a>安全市场的两次颠覆</h4><p>我会用两节课来谈这个概念。这一节课，时间会比较长，我要讲一个横跨大约二十年的故事。</p><p>今天我们都知道，360是互联网安全的企业。但是上世纪90年代，还没有互联网安全的概念，当然也没有360。那个时候，这个市场叫杀毒软件市场。更早的时候，还不是软件，而是硬件——防病毒卡。</p><p>1991年，瑞星公司成立，开始做防病毒卡。1993年的时候，瑞星成为这个市场的老大。1994年，江民公司成立，做出了旗帜性的KV100杀病毒软件。</p><p>1995年，瑞星创始人王莘生病了，瑞星公司群龙无首、业绩下滑，而江民杀毒软件开始在中关村崛起。</p><p>1998年，康复归来的王莘重返中关村，当时江民已经占了杀毒软件市场的80%。这时候王莘就用了一招，以超低价格，对硬件厂商捆绑销售瑞星杀毒软件。当时一套正版杀毒软件零售价格应该在100元左右，而瑞星以低于10元的超低价，向联想、方正等电脑厂商供货，让出厂的电脑自带瑞星的杀毒软件。王莘归来一年后，瑞星在媒体宣布重获计算机安全市场占有率第一，并且此后当了很多年老大。瑞星在巅峰的时候，年收入7亿，净利润3亿多。这个市场太肥了。</p><p>2001年，雷军的金山也推出了金山毒霸，进了这个市场。这三家公司的产品，瑞星、江民和金山，其实都是同维度的点，持续了好几年，用按件付费的方式打来打去。</p><p>2006年7月，周鸿祎进场了。奇虎公司推出了360安全卫士，赠送卡巴斯基杀毒软件半年使用权。同年12月，腾讯公司也推出QQ医生。至此，今天重要的网络安全主角就全部入场了。</p><p>2008年，360发起了向瑞星所代表的传统杀毒企业的进攻，可以说是以互联网思维进攻、颠覆传统产业的发端。以后，几乎所有的互联网企业打击传统企业都是这么干的。</p><p>我来说一下当时几方的实力状况。2007年，瑞星的年营业额7亿人民币，利润是3亿，公司有充足的现金面对战争。2008年，周鸿祎开始发动进攻。而2005年才成立的360公司，在那个时间刚刚完成了两轮融资，一共募到两轮合计4500万美元，约3亿人民币。所以在2008年，周鸿祎打这一仗的时候，无论是现金、技术积累，还是人才储备都不如瑞星。前面说过，1998年，瑞星通过低价OEM切入PC大厂的用户网络，快速超越当时市场覆盖率80%的江民，夺回安全软件市场占有率第一。10年之后，2008年，周鸿祎发动新一轮进攻的前两个动作，与当年王莘曾用过的招数如出一辙。王莘低价，周鸿祎免费。王莘借助PC大厂的用户，完成用户积累。周鸿祎则选择了一个更为广大的用户渠道，就是已经拥有3亿网民的互联网，背后是PC互联网崛起的这个面。</p><p>为什么这场战役里，有7亿现金的瑞星会输？其实瑞星是输在产品的战略结构上了。这就是我们今天要谈的点线面体。瑞星赢了江民，它是用一个点赢了另外一个点，但之后的十年时间，它依然只是一个点，没有发生变化。而360通过免费策略，快速获得用户，短时间内超越瑞星成为用户量第一的网络安全服务商，就好像当年瑞星超过江民一样。</p><h4 id="360如何由点到面"><a href="#360如何由点到面" class="headerlink" title="360如何由点到面"></a>360如何由点到面</h4><p>360在第一个点砸实之后，迅速扩张成了一个面。</p><p>2008年3月，360启用360.cn的域名，将360安全产品，升级为安全平台。同时，推出360安全浏览器，向使用360免费杀毒的用户推广。这时候，浏览器就可以通过工具栏广告、内置广告、搜索分成等方式获得商业收入。浏览器之后，360又展开了网站导航、软件下载、手机App分发等众多服务。360从一个免费安全的点入手，快速变成了一个安全平台，接着变成流量分发平台。这就是360的三级火箭策略。2010年1月18日，360杀毒用户规模突破1亿。其实，2010年360的收入为5379万美元，折合人民币约3.6亿。大约为瑞星巅峰时期年收入的50%。换言之，360拿下了整个杀毒市场的时候，整个市场产生的利润，不到旧市场中大户利润的一半。这就叫改朝换代。</p><p>我在回顾这段往事的时候，突然意识到，2008年，周鸿祎通过打这一仗，一举拿下了这个利润丰厚的市场里的绝对地位。这距离他1998年开始创业，已经过了11个年头了。其实所谓的创业维艰，真的是一身英雄胆，却无处安放。所以，我能理解为什么2010年，估值4亿美元的360，会挥刀冲向估值400亿美元的腾讯，打了一场互联网历史上最有名的3Q大战。因为当时腾讯是互联网的“恐怖大魔王”，几乎是腾讯之下寸草不生。你想想，老周干了11年，才拿下一块对他来讲算是真正战略根据地的江山。消停了才1年，腾讯就大兵压境，搁谁也得拼命。当然，3Q大战同时成就了360和腾讯。一仗之后，腾讯推出了开放平台，并改变了公司的生态策略。到了2010年，腾讯市值400亿美元，今天已经是3000亿美元了。360用户与收入都大增，并且第二年在美国纽交所上市。</p><h4 id="移动互联网的趋势"><a href="#移动互联网的趋势" class="headerlink" title="移动互联网的趋势"></a>移动互联网的趋势</h4><p>所有熟悉老周的人，都知道老周是有搜索情结的。所以，2011年360上市成功，有钱了，周鸿祎亲自带队憋大招——再做搜索。2010年3Q大战时，马化腾曾接受采访称：“周鸿祎要我们投资他，就像微软投资Facebook一样。周鸿祎还说要联合我们打百度，把搜索流量卖给我们。他会出一个拦截百度的东西，先攻击百度的医疗广告。”马化腾讲话的真假暂且不论，这里其实透露出的重要信息是：360一直在观察百度的弱点，以及一直在寻找向百度发起进攻的时机。要知道，老周那个时候就知道，百度的医疗广告是百度的命门。那个时间点，比魏泽西事件爆出来，至少早了6年。当面要打架的时候，点就有机会。面一定会给点让度最大的利益。老周挂帅做搜索的时候，一个百度员工告诉腾讯科技，当时为了应对360的挖角，他所在部门的几位核心员工都获得了一定程度的涨薪。更让他震惊的是，有几个特别聪明的人，在百度、搜狗和360这三家搜索公司之间来回跳槽，一年的时间，让工资收入翻了四倍以上。这也是面在竞争时，资源一定会溢出，让点有红利的一个小例子。就像淘宝早期要发展，一定要让几个商家占便宜，道理是一样的。</p><p>2012年8月16日，在360搜索正式上线的同一天，还有一个产品发布，就是小米2手机。360对百度的战争，他们遇到的真正敌人，是“趋势”。2012年，堪称中国移动互联网爆发之年。PC互联网的整体流量开始大幅下滑，用户集体向移动互联网迁移。360推搜索的同一天，雷军推小米2手机，这是一个很有象征性的场景。周鸿祎是著名的产品经理，但是他在做360搜索的产品决策时，漏掉了移动互联网这个巨大的经济体。所以，今天360公司的公司估值，不如今日头条。要知道，在360发布搜索产品的那一年，今日头条公司才刚刚注册成立。</p><h4 id="本讲小结-4"><a href="#本讲小结-4" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>我们简单回顾了360几场战役的得失。我想说的是：当你想做一个产品的时候，入手只能是一个点。但你要想清楚，它附着在哪个面上？这个面在和谁竞争，它能如何展开？这个面，是在哪个经济体上？这个经济体，是在快速崛起，还是沉沦？</p><p><strong>悲催的人生，就是在一个常态的面上，做一个勤奋的点。</strong></p><p><strong>更悲催的人生，就是在一个看上去常态的面上，做一个勤奋的点，你每天都在想着未来，但其实这个面正在下沉。</strong></p><p><strong>最悲催的人生，就是在一个看上去常态的面上，做一个勤奋的点，其实这个面附着的经济体正在下沉。</strong></p><p><strong>如果一个人一生只能收到点状努力的计时收益，从来没有享受过一次线性周期的成果回报，这就叫穷人勤奋的一生。</strong></p><p>课后作业</p><p>1.描述一下，你现在的职业是什么样的一个点？</p><p>2.你所在的公司或者业务肯定是需要串联很多点的一条线，那你的这个点是在公司这条线的什么位置上？</p><p>3.这个公司附着在什么样的一个面上，谁在给你或你的公司赋能？这个面又是附着在哪个经济体上？</p><p>就好像在地球仪上，找到自己的位置点一样，请你用点线面体的框架，尝试标一下自己的位置。</p><h3 id="09-机会判断：怎样找到有势能的趋势"><a href="#09-机会判断：怎样找到有势能的趋势" class="headerlink" title="09 机会判断：怎样找到有势能的趋势"></a>09 机会判断：怎样找到有势能的趋势</h3><p>这节课，我们继续谈“点线面体”。</p><p>女生相亲的三点建议</p><p>在课程最开始，我讲了一个结婚教练的故事。不少人感兴趣，我就再多说一点技术性细节。结婚教练给女孩第一次相亲提了三点建议：</p><ul><li><p>打扮要女性化。</p></li><li><p>不要努力表现自己，不要谈自己最擅长的东西，不要努力营造氛围，平淡如水即可。</p></li><li><p>适当的时候，主动结束约会。如果对方不再约你了，就放弃这个人。</p></li></ul><p>第一点很容易理解。如果教练要求女孩打扮得漂亮一点，其实每个女孩对打扮得漂亮的理解都不一样，要化个浓妆吗？要穿晚礼服吗？但如果要求是女性化，那么至少一些非常男性化和中性化的打扮方式就可以被过滤掉。在女性化的范畴里，你按照自己能做到的，自己舒服就行了。因为你是去相亲，就跟打开一个网页一样。你要在对方看到你的0.1秒内，让对方意识到，他是在和一个女性约会，这是第一场景。</p><p>第二点的目的是什么呢？很多女孩在希望引起一个男生注意的时候，会表现得非常用力。她会努力拿出自己最好的一面，给对方留个好印象。比如，一个女孩是个计算机高手。她可能会在和男生第一次相亲的时候，把话题引到自己最擅长的领域，然后在自己最擅长的领域里充分展示自己，希望给对方留下一个深刻的印象。这样做对吗？第一次见面，到底是应该照着平淡如水来，还是去玩命地表现自己？如果是追求短线关系和片面接触，当然应该玩命闪耀。比如表演，比如做销售。但如果是长期关系，两个人认识相处的目的是缔结婚姻，成为长期合作、伴侣关系，那么就应该平淡处理。为什么？因为每个人现在呈现的样子，其实都是自己过往所有经历的累加。有句话说：“你的样子里，有你爱过的人，走过的路，看过的风景，读过的书。”相亲时，对方看你一眼，喜欢就是喜欢，不喜欢就是不喜欢。</p><p>所以有了第三条，如果对方不再联系你，那你就放弃吧，因为对方没感觉。其实做产品也是这样的。你也许会想会不会是因为他没有看到你最闪耀的点，所以没有喜欢上你，这样是不是太亏了？如果你追求的是长期关系，就不能基于自己最闪耀的点去缔结关系。因为你所有闪耀的点，都有它没用的时候。做生意有亏钱的时候；你擅长计算机，但是技术也在不断更新迭代；你是名记者，但是媒体行业也在不断变革，也不是所有人脉永远买你的账。如果对方是因为你闪耀的这些点才喜欢你，那你是不是为了保持对方对你的兴趣，要不停地闪耀呢？长期关系里，没有人做得到。你平平常常拿出来的样子，就是你真实的样子。这才是你可以稳定提供的样子，才是可预期的样子。从这个稳定的点开始，作为一段长期关系的发端，有可能才是靠谱的。</p><h4 id="从你做得到的“点”出发"><a href="#从你做得到的“点”出发" class="headerlink" title="从你做得到的“点”出发"></a>从你做得到的“点”出发</h4><p>做产品也是如此，世上的机会千千万，应该从哪个“点”开始呢？和相亲一样，从你能做到的、能稳定提供的那个“点”开始。<strong>不要憋大招，自古长考出臭棋。</strong>如果是需要卯足了劲跳起来才能够得到的一个“点”，其实很难持久。</p><p>我见过无数创业者，真的非常痛苦。为什么？因为当下能做得到的事，他觉得不甘心，甚至自己都无法直视自己的真实能力、真实水平。他更不愿意客观面对，这就是自己实际能够达到的“点”，这就是自己当下配得上的人。而他自己想要的，够起来太费劲。这就是我要把“点线面体”再讲一课的原因。</p><p>因为不论是相亲还是其它的事，看得上我的人我看不上，我看得上的人看不上我。或者我想要的离我太远；我能做到的我看不上。这是无数人的痛苦。我认为，这是同一个问题，就是过于关注“点”。这个人只对“点”有感觉，对“线”、“面”、“体”的力量，完全无视，甚至完全没概念。任何一个点都有它的来路，都有使它成为“今天”这个点的线、面、体。如果你对线、面、体完全无感，只想拥有一个点的当下，那基本上是守株待兔。比如说你想嫁一个有房有车的人，看上去好像很难。但如果你找一个在BAT工作的码农，或者某个新兴独角兽公司的早期员工，稳定了几年之后，就会有房有车。你要看到这条“线”，而不要纠结于当下的“点”。在一个“点”上反复纠结，其实得不出本质的结论。不如花时间，从这个“点”上跳出来，研究一下这个“点”下面的大框架——“线”、“面”、“体”。</p><h4 id="易到的选择"><a href="#易到的选择" class="headerlink" title="易到的选择"></a>易到的选择</h4><p>比如，易到用车是2011年开始的，算得上是全球第一家互联网约车公司，比Uber都早。用创始人周航自己的话说：“干了一年，完全没有对手，心里都发毛了。”第二年，也就是2012年，是移动互联网的元年，一个新经济体诞生了，并且快速膨胀。一瞬间，基于这个新经济体的各种应用全都涌出来了。这一年，Uber、滴滴、快的及100多家各种各样的网约车公司同时出现。风口周边，必然VC成群，这是个铁律。所以，当时江湖上所有的投资公司，以及有投资业务的大佬，全都找过周航，包括腾讯、阿里等等。最后，周航选择了携程。为什么呢？周航觉得业务相关。</p><p>接着，就是2014年著名的打车补贴大战。为什么会补贴打车应用？其实不是滴滴和快的要打，而是腾讯和阿里在打。这两个“面”为了争夺移动支付市场，需要争夺打车软件这个移动支付场景。所以滴滴和快的的大战，背后是腾讯与阿里这两个“面”对它们的赋能。这和上节课我讲360和百度打仗时，几个“点”上的员工涨了工资一样。当“面”打仗的时候，“面”上的“点”是有红利的。2016年，易到卖给了乐视。但实际上，它的败局在2014年拿携程投资的时候，就已经注定了。</p><h4 id="求之于势，不责于人"><a href="#求之于势，不责于人" class="headerlink" title="求之于势，不责于人"></a>求之于势，不责于人</h4><p>我读《孙子兵法》，最大的收获是两句话，一句是“胜与不胜在于彼，败与不败在于己”。这句不是《孙子兵法》的原话，是我自己总结的。</p><p>《孙子兵法》的全篇核心就是这个概念，意思就是说：我能不能赢了你，其实我做不了主，这是你的问题；但是我会不会输，会不会打光所有的牌，会不会下桌走人，那是我自己的问题。</p><p>另外一句是《孙子兵法》的原话：“<strong>求之于势，不责于人。</strong>”</p><p>这句话出自《孙子兵法·势篇》，相关原文如下：“故善战者，求之于势，不责于人，故能择人而任势。任势者，其战人也，如转木石；木石之性，安则静，危则动，方则止，圆则行。故善战人之势，如转圆石于千仞之山者，势也。”</p><p>雷军曾经告诉傅盛：“一个人要做成一件事情，其实本质上不是在于你多强，而是你要顺势而为，于万仞之上推千钧之石。”基于“点”的评估，其实每块石头都是一样的。但是位置不同，势能不同。所以，当你观察一个人或产品机会时，就像你手里拿着一块石头。你是要拿着这块石头站在原地，还是爬上山顶把它推下山去成为千钧之势？</p><p>我们再来说一下后半句，“不责于人”。刚才我们说了石头都一样，人都一样。它们之间的区别取决于它们搭载在哪个“面”上，“面”在哪个“体”上。如果你和敌人，在平原地带拼刺刀，确实只能依赖一个又一个士兵的单兵战斗力。第一模块我们谈了生物性情绪，面对危险和压力，恐惧与焦虑是人类的正常反应。有经验的将军其实能够通过训练与管理，让一个集体的集体人格短时间压倒个体的脆弱。老大一声喊，大家就冲上去了，但是这是不得已才会发生的情况。“制高点”这个词，就是从战争中来的。一个将军，不能担心自己的士兵怕死。为什么？人怕死、人不够勇敢，这是人的常态，这是人性。士兵怕死和销售怕产品难卖一样，是必然的。对于必然的事情，你有什么可担心、可抱怨的呢？</p><p>如果你选择做一个将军，那你就要找到战略制高点，带大家爬上一座山，从山上推石头下来砸敌人。这时你会发现，每个士兵的勇气与战斗力都提升了3倍，因为地理优势为团队的每个人都赋了能。但是作为将军或管理者，不能抱怨士兵或员工不够勇敢，这叫“责于人”。</p><p>“求之于势，不责于人”，是要自己去找有势能的“面”，而不能寄希望于员工的“点”。如果想一切靠员工的“点”的努力来得到，所有的士兵其实都贪生怕死，所有的员工都害怕努力而没有收获。</p><p>“求之于势，不责于人”，这才是CEO该干的事。找到外部势能，为你的整个组织赋能。</p><p>比如，优酷被爱奇艺超过。优酷的对外解释是，上市到了一个周期需要给投资人回报，所以减少了版权购买的支出。结果，爱奇艺抓住机会加大版权购买，只用了一年时间就超过了优酷。其实背后还有一个逻辑是，百度对爱奇艺的赋能。因为版权购买就是花钱，谁都能做。而百度用高效流量的和机房IDC（数据托管服务）能力，极大地为爱奇艺赋能了。所以，后来优酷也抱了大腿，加入了阿里巴巴。但对于视频网站来说，阿里巴巴所擅长的能力不如百度的能力有效。纵使阿里今天的市值是百度的很多倍，就这一“点”的赋能能力，还是百度强。</p><p>“求之于势，不责于人”，这才是通往幸福的道路。</p><p>作为一个CEO，你不应该天天对自己的团队和员工不满意。你应该去找外部势能，为你的组织赋能。今天能跟着你干活的，都是你能得到的最好的员工。每一个人，就只是一个当下的“点”，资源都很有限。一个“点”，你再抱怨，再压榨，也就只是一个“点”的资源而已。反过来你要想，大家把自己最好的“点”都给了你。在一个时间周期之后，你会回报给大家什么样的线性收益呢？</p><h4 id="本讲小结-5"><a href="#本讲小结-5" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>女孩判断伴侣，产品经理判断产品机会，创业者判断创业方向，这三者的痛苦其实是一样的。我看得上的看不上我，我能做到的又觉得不够。所以，我们为什么第一模块要花整整五讲来说构成了你心智的情绪、潜意识和集体人格。因为你需要知道，这些东西其实只是情绪而已。你在做关键决策的时候，不要被这些小情绪干扰。你要强迫自己，离开牵动你情绪的“点”，去看到“线”的方向，去预测这条“线”的周期，并且明确你自己在周期的哪个位置，是哪个“面”在给你赋能。你要明白外部的势能才是重要的，不要过于苛求那个跟随你的“点”，这才是决策的关键。但这确实很难。比如巴菲特的合伙人查理·芒格，为了把自己训练得客观，用了一生的时间。</p><p><strong>人生的选择远比努力更重要。</strong></p><p>你的选择应该是一条“线”、一个“面”，甚至是一个“体”的收益。你个人的努力，只是在“点”、“线”、“面”、“体”的既定框架内，作为一个“点”的挣扎而已。</p><p>课后作业</p><p>这节课我们讲了“求之于势，不责于人”，但是如果势能发生了变化，比如说你所在行业的风突然之间停了，你觉得应该怎么做呢？</p><h3 id="10-痛点、痒点、爽点都是产品机会"><a href="#10-痛点、痒点、爽点都是产品机会" class="headerlink" title="10 痛点、痒点、爽点都是产品机会"></a>10 痛点、痒点、爽点都是产品机会</h3><p>上节课我们讲了点线面体。</p><p>不管你是做一个产品，接触一个产品，还是接触一个人，总得从一个点开始。</p><p>今天我们就来讲点。</p><h4 id="痛点是恐惧"><a href="#痛点是恐惧" class="headerlink" title="痛点是恐惧"></a>痛点是恐惧</h4><p>我们做产品不可避免地就要谈一个词叫痛点。</p><p>什么叫痛点？</p><p>我搜了一下，在“什么是痛点”的问题下，排第一的答案是：“对于产品来说，痛点多是指尚未被满足的、而又被广泛渴望的需求。”这个答案当然不对。</p><p>没有被满足用户只是难受而已，不能拿用户的难受当痛点，或者产品的切入点。为什么？我在下面会讲到。</p><p>反而一些网友讲自己的案例，非常有意思。一个叫子柳的网友说：</p><p>手机上一天到晚都会收到推销的广告电话，恨不得卸载手机的通话功能，直到我遇上某某号码通。碰到头疼脑热的小病，跑医院能把人折腾死，又不敢乱吃药，这时候有一个App就很好地解决了我的问题。</p><p>一个叫舒大畅的网友说：</p><p>当年的海飞丝广告就很打动我。我第一次拜访岳父岳母，肩上都是头皮屑，让老人一脸嫌弃；面试的时候衣服上都是白点，让面试官皱眉头……这些都是很痛的事情。</p><p>你注意一下，上述场景中用户决定要用什么产品帮助自己时，他们用的一个词是“怕”。<strong>痛点是恐惧。</strong></p><p>接下来，我要讲一篇文章叫《如何抓住用户痛点做产品》。这篇文章的说法是错的，所以我当作错误示范来讲。</p><p>张太太是个全职太太，全职在家带两个孩子。她每天早上起床后，要先给两个宝宝做早饭，老大吃完后就要去幼儿园。张太太要推着婴儿车让老二坐在里面，再牵着老大的手把孩子送到幼儿园。之后，她要赶紧回家，哄老二吃饭，并陪他玩耍。到幼儿园放学时，张太太又要带着老二去接老大。到家后先生也要下班了，她又要开始准备晚饭。张太太也有自己的兴趣爱好，有自己的想法和梦想，但实际上家务活已经占去了她所有时间。</p><p>接着这篇文章对张太太做痛点分析。张太太没有自已的时间，时间全部被孩子占据了，能不能有一款产品解决张太太的问题？这不是她一个人的痛，这是一群忙于家庭生活的、大多数女性的痛。</p><p><strong>这是痛点吗？当然不是，因为这中间没有恐惧。</strong></p><h4 id="爽点是即时满足"><a href="#爽点是即时满足" class="headerlink" title="爽点是即时满足"></a>爽点是即时满足</h4><p>痛点，是做产品的抓手。另外一个做产品的抓手，是爽点。</p><p>什么叫爽点？</p><p>人在满足时的状态叫愉悦，人不被满足就会难受，就会开始寻求。如果这个人在寻求中，能立刻得到即时满足，这种感觉就是爽。</p><p>当年俞军在百度招聘产品经理时，招聘题目是百度如果要做音乐该怎么做？很多人都写了洋洋洒洒的规划书给他，有一个人只写了六个字：“搜得到，能下载”。俞军就挑了这个人，他就是后来当上百度副总裁的李明远。当年互联网资源非常少，人们上百度找音乐找自己想听的歌，一搜就搜得到，还能下载，这就是爽。今天的外卖，你在家用手机下单，吃的就送到你家来了。你在河狸家上下单，美甲师就上门给你做美甲了。</p><p><strong>有需求，还能被即时满足，这就是爽。</strong></p><p>回到刚才的场景，我们知道张太太自我实现的想法没有被满足，这当然是不爽的状态。但是，你的服务可以让她即时满足吗？你能做个产品，能即时满足这类女性实现自我的需求吗？这是个复杂问题，是不可能做到即时满足的。这不像是在游戏里顶个蘑菇加10分那么简单。你看到了张太太不爽的状态，但是如果你没找到让她即时满足的方法，那么你依然没有找到这个产品的切入点。</p><p>为什么？因为自我实现其实是一条漫长而痛苦的路，人的本性是懒惰的。你看到一个人展现出了勤奋、规整、自律，其实这是被一系列的恐惧、集体人格、潜意识压迫，才会呈现出那个样子。所以，如果没有恐惧这条疯狗追着，没有爽点这种满足感来持续喂养，只靠一个App帮助女性实现自我，那可以不客气地说，这就是个不痛不痒的产品。</p><h4 id="痒点是满足虚拟自我"><a href="#痒点是满足虚拟自我" class="headerlink" title="痒点是满足虚拟自我"></a>痒点是满足虚拟自我</h4><p>痛点和爽点，我们说完了。刚才说到不痛不痒，我们再说说痒点。</p><p>那什么叫痒点呢？这其实是我自己挖的坑，我以前在自己的微信公众号上写过一篇文章，叫做《痛点痒点》。痛点已经成了今天互联网的万金油概念了。但今天满街都是创业者和投资人，只靠抓一个痛点做产品，其实不容易。这时咱们发现近两年有一个现象，各种网红产品层出不穷。比如网红奶茶、网红酸奶、网红曲奇、网红洗发水，它们的爆红是靠抓住痛点吗？显然不是，网红产品们靠的是痒点。什么是痒点？</p><p>咱们说一部大家都知道的韩剧《来自星星的你》。这是好几年前的剧了，我当时热追来着。我为什么会追这样一部剧？因为它的痒点非常打动我。它讲的是一个女明星和外星人的爱情故事。听上去，这个故事创意也没什么新意，为什么当时那么火呢？“痛点控”们总结说：这部戏抓住了女性对英雄和美少年合体的想象，满足了这个痛点。如果这个痛点是对的，那么单靠一个痛点，怎么可能拍出20集九百多分钟的内容呢？怎么会让我们不停地看，还愿意不停地讨论，甚至做一些周边产品呢？</p><p>你可以翻一翻百度贴吧“来自星星的你吧”，看一下大家都在聊什么。我当时去看的时候，有600多万个帖子在讨论这部剧。大家都在谈的是，教授（男主角都敏俊）的微表情、教授的眼神、论教授对二千（女主角千颂伊）态度的转变、二千的衣服、二千的妆容与唇膏、二千的配饰……这些其实都是痒点。</p><p>痒点是什么？这也是我自己定义的，<strong>痒点满足的是人的虚拟自我。</strong></p><p>什么是虚拟自我？<strong>就是想象中那个理想的自己</strong>。</p><p>比如，我们看偶像剧，追星，看网文，看英雄故事，看网上的名人八卦，看名人的创业故事、成功神话。你是在热追他们吗？不是，你情不自禁投入到关注的内容，是你的虚拟自我，是你自我想象的一个投射。</p><p>这时咱们再来说说这一波网红电商。其实<strong>网红为你营造了虚拟自我的生活，是大家理想生活的投射。</strong>我们购买网红的东西，就部分地实现了自己的虚拟自我。</p><p>比如，淘宝第一网红雪梨，在谈她的运营经验的时候说，为了营造更好的形象，每次为新款的衣服拍照，只有45公斤的雪梨要提前一周节食。你在微博上看到的那种非常“随意”的街拍照片，是她用10天时间拍摄，然后挑选和修图运营出来的产品。在微博上发照片，就是她与粉丝最重要的互动。她要用她的照片，为粉丝营造出一种生活场景，她说：“你卖的其实是一种生活方式，它要满足女孩心中美美的幻想。”雪梨的粉丝成套地买雪梨的穿搭，她们买的不是衣服，不是基于功能性的需求，不是天冷了需要一件衣服保暖。而是我要穿雪梨在巴黎穿过的那件衣服，穿上雪梨的衣服，她们就会觉得自己部分地过上了雪梨所营造的生活。这就是一种虚拟自我的实现。</p><h4 id="本讲小结-6"><a href="#本讲小结-6" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结一下，什么才是一个产品的入手点。痛点、爽点、痒点都是不错的点。这个就看产品经理自己对用户的哪个点感受最深、手感最准。比如说，饿了要吃东西。但是“吃饱了”和“吃得很满足”，这是两个概念。吃个馒头能饱，但是仅仅是满足了功能需求，不能支持好产品的概念。</p><p>酣畅淋漓地吃一顿海底捞火锅，大汗淋漓，感觉爆爽。这就抓住了爽点，这是好产品。</p><p>怕吃火锅长胖，抓住这一点的恐惧，抓住痛点，也有产品空间可以做。或者还可以做一个美美的网红餐厅，像雕爷做的薛蟠烤串。用户点一份干冰爆米花，吃一把，两个耳朵往外冒干冰的白气，人人都会拍张照然后发朋友圈，这是痒点。</p><p>吃顿饭，其实也可以有痛点、爽点、痒点这些不同的切入点来做产品的。</p><p>课后作业</p><p>你能不能介绍一下，你现在正在做的产品，核心是在打痛点，还是打痒点，还是在抓爽点，或者三不沾呢？</p><p>欢迎在留言区分享。</p><h3 id="11-两套经典的用户画像"><a href="#11-两套经典的用户画像" class="headerlink" title="11 两套经典的用户画像"></a>11 两套经典的用户画像</h3><p>这节课来讲用户画像。</p><p>有非常多的书在讲用户画像，并且有一大堆方法论。所以在这一课里，我讲讲我们在实际工作的过程中用到的用户画像，希望能够给你启发或者能够直接用得上。</p><h4 id="第一套用户画像：羊群与草地"><a href="#第一套用户画像：羊群与草地" class="headerlink" title="第一套用户画像：羊群与草地"></a>第一套用户画像：羊群与草地</h4><p>比如，YY的创始人和董事长李学凌给我讲了一组用户画像，我早期做产品就是用他的这组用户画像来做的。他教我说：如果我有一片草地，我就在我的草地上养羊，所以我先要有第一只羊。如果这一只羊能够在我的草地上活下来，玩得很好，那么我的草地就是没问题的，我就可以引入更多的羊。羊多了，你就会发现头羊才是关键的，为什么呢？因为一只头羊可以管一大堆羊，你就不用管了，那些小羊就不用管了，头羊都会管。只要有头羊，羊群就可以聚集。羊多了就会有狼，狼多了，我就把羊圈起来，然后向狼收费。</p><p>几乎所有的互联网社区，都是按照这个场景和用户描述去做的。在这里我们谈到了几个用户画像：第一只羊、头羊、狼。你的草地上来了第一只羊，接着这只羊吃了一口草，死了。第一只羊是什么？就是你迎来了第一个用户，这个用户玩了一下就走了，再也不来了，就叫“死了”。那怎么办？你再拉来第二只羊吗？有很多同学问我，为什么相亲后男生不再主动联系，你就放弃，在这里也一样，就是因为不匹配。一个人的自然状态，让另外一个人觉得不喜欢，和你准备的一个产品请一个用户来用，用户不喜欢，这两种情况其实是一样的。你可以为了留住这只羊，动用很多外部资源，比如我从外面买草买料，可以暂时把这只羊留下来。但这其实是靠额外付出，才能撑住场面。并不是说你的产品、你的草地已经具备了生生不息的自然状态。所以如果你要有羊，还是需要回来继续解决你自己的草的问题。</p><p>接着你有一片草地，迎来了第一只羊，这只羊吃了一口草没死，但是玩得不开心，这个是什么意思呢？就是你有了一个产品，来了一个用户，然后这个用户用了一下觉得也还可以，但是没那么爽。这个时候你可以引入更多的羊吗？也就是说你要开始推广你的产品了吗？当然还是不行，其实这依然是你的草的问题，你的产品的问题。日本的剑圣宫本武藏，有一本书叫<strong>《五轮书》</strong>。他说：“即使面对千军万马，你要斩杀的其实只有你对面的一人。”所以测试你的产品，其实你不需要其他的条件。首先要有第一只羊；这只羊在这里过得很好、玩得很开心，它得到了即时满足；这时可以引入更多羊，也就是产品可以推广了。</p><p>做产品需要磨炼自己的心力，让你的心非常硬，不能自欺欺人，不要骗自己感觉良好。不要觉得万一去推广时会有其他的羊喜欢。不能这样，你要从找到第一只羊开始。第一只羊是最关键的角色。你找到了这个用户，他可以在你这里得到即时满足，玩得很开心，那么针对这只羊，针对这个用户的同类用户去做推广，你的产品就可以被快速地推开。</p><h4 id="头羊与网络效应"><a href="#头羊与网络效应" class="headerlink" title="头羊与网络效应"></a>头羊与网络效应</h4><p>第二个关键角色是什么呢？是头羊。李学凌说整个生态发展到最后，最核心的就是头羊。整个企业的资源核心就是要去维护头羊，只要有头羊就会有羊群。有时候小羊叫一叫表示不满，我们根本不用管，因为企业资源有限。什么叫头羊？比如说论坛的版主、YY公会的老大、微博的大V、重度用户、淘宝的店主，这些都是头羊。当你的草地上出现了头羊，头羊开始自己管羊群的时候，这代表着什么？其实这就代表了自组织的开始，你开始拥有了网络效应。我想你可能听过曾鸣讲的《智能商业20讲》，其中说到了<strong>未来商业最核心的双螺旋：数据智能和网络效应。</strong>他还专门讲了为什么Uber没有网络效应。在这里，我再援引头羊的理论，把网络效应再解释一下。Uber有头羊吗？滴滴有头羊吗？没有。Uber、滴滴都是一家公司直接服务每一个单点司机，所以Uber、滴滴不存在自组织，也没有网络效应。</p><p>当你要评估一个产品或者一家公司的网络效应有多大时，一个非常简单的评估方式就是数一数它有多少头羊。比如说一个很火的摄影网站叫蜂鸟BBS，它大概有50个版主，所以它有50个头羊；那另外一个更火的BBS——天涯，最少有5000个版主，所以它至少有5000个头羊。这样一对比，你就大概知道，天涯的网络效应肯定是远远大于蜂鸟的。百度贴吧有多少版主，就至少有多少头羊；淘宝上有多少卖家，就有多少头羊。那按照这个标准来看，百度贴吧和淘宝，它们的网络效应其实是巨无霸级的。草地、第一只羊、头羊和狼就是一组经典的用户画像。狼是什么我们放到最后说。其实，基本上所有玩互联网网络效应的、玩社区的，都用这一组用户画像去开启他的生态体系。</p><h4 id="第二套用户画像——大明"><a href="#第二套用户画像——大明" class="headerlink" title="第二套用户画像——大明"></a>第二套用户画像——大明</h4><p>另外一套经典的用户画像是我做的，有三个核心角色，叫大明、笨笨和小闲。</p><p>在这一套用户画像里，第一个用户叫大明。大明有什么特点？大明对自己的需求非常了解、非常清晰。比如说男人买衬衫就是大明，或者男人买一个手机或3C产品，他就是大明。因为他对他要的东西是非常清晰的，所以他要寻找的核心是价格或者硬货。这个时候，网站的页面做得再漂亮、格调再高雅，如果产品价格不好，大明一样不买账。所以互联网产品中，大明最依赖的工具是搜索，因为他对自己主动要找的东西是非常清晰的。最早的互联网电商都是依靠大明用户开始的。比如成熟最早的旅游，卖机票、卖酒店，这些都是标准品。然后卖3C产品，也是标准品。比如，像去哪儿的搜索比价引擎，提供从同一班航班里找到最便宜的机票这一服务，这更是大明用户所青睐的一个经典产品。</p><p>京东其实就是定位于服务大明的，所以标准品的竞争几乎都是京东赢。为什么？因为大明用户极其简单，他要干的事情就是两件：一、搜索自己要的；二、比价格。京东的体量优势越来越大，对供应链的挤压能力越来越强，所以它服务大明用户的能力就越来越强。现在一些B2C品类暂时还有机会，其实是京东的火力还没有扩展到那里。标准品的电商，只要是京东来做，根本不需要精细化的运营就能够压倒其他的商家，为什么？因为大明用户要的就是价格和效率。</p><p>当然了，大明用户还有一个特点，他没有忠诚度。比如一个男士，他买衬衫，买了就走，不会再多看一眼其他的东西。易到用车的创始人周航有一个朋友跟他说：“我对你的忠诚度就是10块钱。用易到和用其他的打车软件，如果差价是10块以内，那我就选易到。但如果说差价超过10块，不好意思，谁便宜我选谁。”这就是大明用户。</p><h4 id="第二套用户画像——笨笨"><a href="#第二套用户画像——笨笨" class="headerlink" title="第二套用户画像——笨笨"></a>第二套用户画像——笨笨</h4><p>说完了大明，咱们说笨笨。</p><p>笨笨的特征是什么？就是我有大概的需求，但是还没有那么明确。</p><p>如果说男人买衬衫是大明，那女人买裙子就是笨笨。</p><p>你问女生她想要一条什么样的裙子，她真的不知道，我得看、挑选、比较，最后从各种信息中做一个决定。所以如果男人要出门买衬衫，基本上一定会买一件衬衫回来；但如果女人要出门买裙子，她可能会逛十家店看了200条裙子，最后买了一顶帽子。</p><p>如果京东是服务大明的，那么现在有一个给女生用的App叫小红书，它就是一个经典的服务笨笨的应用。我们来比较这两个的区别是什么。</p><p>京东有一个很强的产品目录检索，小红书没有这个功能。而且小红书搜索任何一个结果都会出一大堆产品，你想要用关键词过滤掉？做不到。为什么？故意的。因为女孩儿的目的不是要有效率地、快速地找到自己要的东西，而是想东看看、西看看，看看有什么她不知道的，有什么她没见过的，看得多了就会忍不住买一样。最后买的东西和她最初想要的东西相不相关，这不重要，这就是笨笨用户。</p><p>淘宝，尤其是智能化升级之后的淘宝，更是服务笨笨用户的。马云说淘宝是一个娱乐公司，为什么？因为每天晚上都有2000万的女生在淘宝上逛，什么也不买，就是逛。但是，如果笨笨决定了要买什么产品，那么下一秒有70%-80%的概率，笨笨就会变成大明，然后开始去追求价格。一个经典场景是我在豆瓣东西上找买东西的灵感，接着到淘宝上去找最便宜的一件购买。</p><h4 id="第二套用户画像——小闲"><a href="#第二套用户画像——小闲" class="headerlink" title="第二套用户画像——小闲"></a>第二套用户画像——小闲</h4><p>第三个用户就是小闲。小闲的特征是什么？就是我没有消费需求，我就是来打发时间的。如果说百度、京东服务大明，淘宝服务笨笨，那么腾讯其实就是服务小闲的。</p><p>QQ聊天是因为闲，微信刷朋友圈还是因为闲，你玩游戏依然是因为闲。所以你在任何一个闲的时候，打开腾讯的产品一定可以帮你杀时间。所以腾讯的用户往游戏和视频去转化，转化率就会非常高，为什么呢？因为用户玩游戏也好，看视频也罢，其实他都是因为闲，是沿着小闲既定的心理需求和行为路径发展下去，继续打发时间。但是如果你要让腾讯的小闲流量转化为购物的电商，效果就很差，为什么？因为场景不对。场景是个大词，我之后会专门讲。</p><p>总之，一个人到这来是来打发时间的，如果你突然让他买东西，他会觉得他心理建设没做好，他没有这个预期。其实不单是腾讯，其他服务小闲的社区，比如说天涯、豆瓣、蚂蜂窝，用它们的社区用户去做产品的交易导流，效果都挺一般的。</p><h4 id="本讲小结-7"><a href="#本讲小结-7" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>讲完了大明、笨笨、小闲，你就会发现，互联网的BAT就是服务这三类经典用户涨起来的。百度服务大明，你要什么说清楚，我帮你找；淘宝服务笨笨，没什么事你就上来逛吧，有层出不穷的东西给你看；腾讯服务小闲，闲着没事的时候，打开腾讯的任何一个产品打发时间。</p><p>这三个用户和上面那个草地与羊的关系是什么呢？</p><p>不管大明、笨笨和小闲其实都是羊，你想服务具体哪种羊，你就要按照大明羊、笨笨羊、小闲羊，三种不同羊的需求，来管理你的草地，制作你的产品。所以具体到痛点、痒点、爽点，你得让大明羊、笨笨羊、小闲羊按照他的心理预期，来吃一口你的草，如果吃得开心就再也离不开了。刚才说完了羊，这个角色里其实还有一个狼，那么狼是谁呢？对于B2C的企业来讲，如果你是向B端收费，那其实狼就是B端。比如说像京东、淘宝，其实它们都是向上游挣钱的，所以<strong>商家是狼</strong>。那对于腾讯呢？其实腾讯的主要收入来源不是在B端，而是在C端，所以我们可以认为腾讯也会把少量的羊卖给狼，但是它主要是靠剪羊毛成为一家巨大的公司的。</p><p>课后作业</p><p>请你选一个产品分析一下，这个产品核心是服务大明、笨笨，还是小闲呢？这个产品的竞争对手是谁？你觉得谁服务得更好一点？</p><h3 id="12-设计产品时要包括产品的场景"><a href="#12-设计产品时要包括产品的场景" class="headerlink" title="12 设计产品时要包括产品的场景"></a>12 设计产品时要包括产品的场景</h3><p>上节课提到了场景，所以这节课就把场景这件事细说一说。</p><h4 id="用好场景，让美女脱颖而出"><a href="#用好场景，让美女脱颖而出" class="headerlink" title="用好场景，让美女脱颖而出"></a>用好场景，让美女脱颖而出</h4><p>场景在几年前还是个新概念，现在满大街都能听到这个词。为什么经常提到场景呢？因为场景本来就是产品的一部分。你脱离了场景谈产品，就好比你给了一个女孩一件很漂亮的晚礼服，东西很美，女生也很喜欢，但是无处安放。那这东西有什么用呢？</p><p>什么叫场景？咱们都知道杰奎琳是美国历史上最优雅的总统夫人，她有一句名言：“我知道我不管做什么事，都不如我把衣服穿得好更重要。”杰奎琳穿衣服有多讲究呢？她陪肯尼迪出国访问的时候，她会提前要对方接机仪仗队的着装方案以及接机的场景，为的是当她走下飞机的那一刻，她的着装在整个场景中既无比和谐，又能非常好地突出自己。</p><p>有一篇文章讲到了电影《绣春刀2》里的杨幂，用了一个词，我觉得特别有趣，说杨幂在这部电影里的作用叫“女性景观”。“女性景观”这个词很有意思。如果我们按照一个女生有多美来作一个比喻，有的女生就像路边的野草，完全不会留下任何印象。也会有一些美女是家庭盆景级，挺漂亮的，会有个印象。但是有的美女，比如说像张艾嘉，茶道的张南揽，已经把自己修炼成了行走的艺术品。而杰奎琳真的是把自己做成了女性景观。</p><p>什么叫女性景观？就是你会专门花钱买一本她的画册，就好像你会专门花钱买某个著名风景的明信片那样。有人会把她的海报印出来，有人把她的头像设置成壁纸，就像对待美丽的风景那样。她的美已经是一种景观级别。那么，这种景观级别的美是天生的还是刻意为之的？就杰奎琳来讲，她是把她自己作为一个产品运营，也就是她对自己公众形象的运营。杰奎琳为什么有这么多好照片？对于普通人来讲，高兴就拍张照。但是对于杰奎琳来讲，她的照片不是个人记忆，而是公众视觉，是公众记忆的一部分，是她自己的重要产品。你看到杰奎琳那些很棒的照片，是她精细化运营的结果，而照片中的场景就是产品的一部分，甚至是非常重要的一部分。你想一想，如果脱离了出国访问的仪仗队背景，或者脱离了白宫中某一个特色角落的背景，只是一个美女，摆个姿势照个相，会有多少传播度呢？杰奎琳的做法是<strong>重视场景，有效地使用场景，然后在场景中成就自己的形象。</strong></p><h4 id="什么是场景"><a href="#什么是场景" class="headerlink" title="什么是场景"></a>什么是场景</h4><p>我们刚才一直在谈场景这个词，那场景到底是怎么定义？</p><p>要把场景拆开，场和景。<strong>“场”是时间和空间的概念，一个场就是时间加空间。</strong>用户可以在这个空间里停留和消费，如果一个人不能在某个空间去停留、消费，这个场就是不存在的。“景”是什么意思？<strong>景就是情景和互动。</strong>当用户停留在这个空间的时间里，要有情景和互动让用户的情绪触发，并且裹挟用户的意见，这就是场景。</p><p>很多时候，你以为你是在消费产品，其实你是在消费场景。举一个高发的消费行为——吃饭。吃饭有多少场景？我们简单说一下。比如说，早餐怎么吃？是自己对付一下，还是摆好盘、拍照晒朋友圈？这就是不同的场景。中午饭怎么吃？你自己带便当，一边看网剧一边吃，这是一个场景；几个同事一起叫便当，在会议室里边吃边聊，这是一个场景；几个同事一起出去吃，然后AA制结账，这是一个场景；中午请客户吃饭，这是一个场景；中午情侣约会也是一个场景。所以脑补一下，你会发现在不同的场景下，发生的消费其实是完全不一样的。</p><p>接着再说晚餐。回家吃是一个场景，在单位加班叫外卖是一个场景，朋友聚会是一个场景，恋人约会是一个场景，请客户吃饭是一个场景，求人办事要摆排场是另外一个场景。其实我刚才说的场景拆得极其粗，往细里还有无数的细分场景。所以开一家餐厅绝不是说你要输出的产品就是菜，或者加上菜的摆盘。开一家餐厅就是要运营一个场景。</p><p>一个朋友跟我说，他打算做一个便当品牌，决定打败<em>黄太吉</em>。他的方法是只做一种便当——寿司，因为寿司既健康又美味，而且时尚。我就问他，你的便当的消费场景是什么呢？它的消费场景是一个人自己吃，还是几个同事一起吃？如果你没有把它的消费场景考虑进去，这个产品就是不合格的。咱们之前讲过点线面体，新场景的出现其实也是一个“体”，比如碎片时间就是一个新场景。</p><h4 id="场景要能触发情绪"><a href="#场景要能触发情绪" class="headerlink" title="场景要能触发情绪"></a>场景要能触发情绪</h4><p>在移动互联网不成熟之前，我们要乘地铁，会堵车，也要等人。</p><p>碎片时间本来就充斥着我们的生活，但是因为移动互联网的成熟，使你有机会把这些碎片时间利用起来。比如“得到”，其实就是抓住了碎片时间和认知焦虑的两大红利，然后成长起来的一只独角兽。</p><p>其实罗辑思维有一个例子，就很好地体现了场景的力量。</p><p>不知道你是否记得2015年罗辑思维卖书的事？罗辑思维打包卖书的套装，一套六本，你不知道都会有哪些书，一共8000套。一个淘宝店店主当时就觉得这个套装肯定有价值，因为只有8000套。所以他在开卖的第一时间就抢了10套，8000套书在一个小时之内就卖光了。这个时候罗辑思维的群里还有人问，怎么没有了？到哪里买？于是这个淘宝店店主赶紧把他买到的这10套书上架销售。他想现在的状况是大家想买而买不着，那怎么也得加点价吧。所以他标价450元，结果放了两天也没人来问。然后他就降到了原价400元，还是没有人问。打折以后依然无人问津，最后这套书在淘宝是零交易。</p><p>为什么同一套书，在罗辑思维的这个场景里，8000套书在一小时之内被一抢而空？而在淘宝店店主自己的小店里，打了对折，放了10天还是卖不出去？原因就是罗辑思维搭建了“场”加“景”，在这个时间和空间里，大家一起疯抢，对彼此进行了意见挟裹和挤压。<strong>如果你架构的场景不能影响别人的情绪，不能形成对别人情绪的触发，它就不是一个场景。</strong>所以淘宝店店主把书放在货架上，冷冷清清往地一摆，这个是没有任何情绪触发的，只是一个“场”，不存在“景”，它不是一个场景。所以，场景的核心是在空间加时间的点上触发别人的情绪。</p><p>在第一模块已经说了，其实人所有的理智和意识都是把人往回拉的，而所有的情绪是在推动人的行动。所以人会去做一个动作，会往前走，是被情绪推动的。</p><p>比如电影《罗马假日》里，不知道你还记不记得一个桥段。公主和记者一起大闹派对，被警察追，然后他们跑赢了警察，气喘吁吁地并肩在一个街边坐下。当时真的是很美，岁月静好，月落无声。看这一幕的时候，我就在想，此情此景他怎能不吻她呢？果然下一个镜头派克就吻了赫本，这叫什么？这就叫场景和情绪触发。只有能触发用户情绪的场景才是真正的流量入口。互联网商业其实就是三个核心词：<strong>产品、流量、转化率</strong>，也就是产品的比拼、流量的争夺、转化率的优化，这就是互联网商业竞争的全部。</p><p>在万物互联的未来，到处都是屏幕，到处都是网络连接的入口。<strong>入口不是场景</strong>，它就像是淘宝店家有一个店面，那是一个时间加空间，但不是场景。<strong>想要成为场景，它还要能够触发情绪。</strong></p><h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>因此，我把场景作为咱们第二模块的最后一讲。你要规划一个产品，需要问自己<strong>七个问题</strong>：</p><ul><li><p>第一，我的产品解决了什么问题？是痛点、痒点，还是爽点？</p></li><li><p>第二，我在为谁解决这个问题？他得到<strong>即刻满足</strong>了吗？这是用户画像的问题。</p></li><li><p>第三，有多少人需要解决这个问题呢？这是市场规模的问题。</p></li><li><p>第四，目前人们是怎么解决这个问题的呢？这是竞争分析的问题。</p></li><li><p>第五，我的竞争方案为什么能够在市场竞争中胜出？你不要简单地看单点的竞争力，而是要看点线面体，谁给你赋能。</p></li><li><p>第六，用户会在什么样的场景触发情绪？需要马上去解决问题，这是场景问题。</p></li><li><p>第七，当用户遇到问题的时候，他会想到哪个名字呢？我在第四模块会讲。</p></li></ul><p>到此，第二模块就讲完了。</p><p>本讲作业</p><p>马上就是春节了，春节肯定是中国人的超级场景，不管是春节本身、春运还是春晚。你知道哪些把春节这个场景用得非常好的例子，或者说你基于春节这个场景，自己想做什么事情？</p><p>欢迎你留言与我分享。</p><h3 id="模块三）-系统能力"><a href="#模块三）-系统能力" class="headerlink" title="模块三） 系统能力"></a>模块三） 系统能力</h3><h3 id="13-怎样用系统能力给人提供确定性"><a href="#13-怎样用系统能力给人提供确定性" class="headerlink" title="13 怎样用系统能力给人提供确定性"></a>13 怎样用系统能力给人提供确定性</h3><p>这一课将进入到<strong>第三模块——系统能力。</strong></p><p>什么是系统能力？我以前问过这个问题，给你泥土和水，你能做出一个苹果吗？几乎每个人都会茫然，但是苹果树可以。<strong>用泥土和水做出苹果就是苹果树的系统能力</strong>。我们看到的所有结果，都是系统能力的产物。</p><p>你可以回到《机会判断：点线面体的战略选择》一课里，思考为什么一个“点”没那么重要？因为任何一个“点”都附着在一条“线”上，每一个“点”其实都是一条“线”的截面。这也是为什么结婚教练建议以结婚为目的的相亲，第一次见面正常平淡即可，没有必要专门地表现自己，因为每个人的自然呈现都是系统能力的结果。</p><p>比如一个人好的身材，其实是长期自律的结果；一个人得体而有美感的着装，其实是长期的审美陶冶的产物；一个人的神情和谈吐，其实是学识和性情的产物。所以一个人很自然地展现的一切，是层层叠加、长期积累的系统能力的产物。</p><p>当你说你要做一个产品，你需要的是建设一套系统能力。就好像你想拥有好的身材，就必须得有控制饮食和保持运动的系统能力一样。</p><h4 id="整体流程与确定性"><a href="#整体流程与确定性" class="headerlink" title="整体流程与确定性"></a>整体流程与确定性</h4><p>这一课有两个关键词：整体流程与确定性。</p><p>2011年，我加入腾讯的时候，被震惊到的地方就是，这家以产品著称的公司，在内部沟通时没有人提产品这个词，谁说产品谁外行。大家经常会用的词是什么呢？服务。</p><p>为什么？举个例子，比如说我们生产一个打孔机，用户要的是这个吗？其实用户不需要一台打孔机，用户需要的是墙上有一个洞。如果你定义自己在做的不是一个产品，而是一个服务的话，你的逻辑就会变成：我需要提供怎样一种服务让用户的墙上有一个洞？</p><p>那至少有几种方案：</p><ul><li><p>第一个就是做一个打孔机，然后卖给用户；</p></li><li><p>第二个就是做一个打孔机借给用户，或者提供一个服务，用户需要的时候，我就上门去给他打孔。</p></li></ul><p>以用户得到这个孔为目的去提供服务，而不是想着我要做一个打孔机，然后卖出去，这就是产品和服务的区别。</p><p>如果大家总是在谈产品，会很容易以产品经理为中心，就想着要做一个产品来改变世界。但是如果出发点是提供一个服务，就会以用户获得和用户满足为中心来做设计。这两种方式的目的和实现途径完全不一样。</p><p>今天我们要谈的不是一个互联网的产品，而是一个ATM机，为什么呢？因为ATM机是一个最简单的产品或者服务。ATM机提供什么服务？取现金。那ATM机提供的确定性就是在验证你的ID后，问你需要多少钱，把现金给到你。就像是罗辑思维提供的确定性，每天早晨6点多，罗胖都会给你60秒语音。60秒这个概念其实是马化腾提出来的，当时罗胖发了这条语音，他自己没有意识到，但马化腾马上就说这个60秒是个好概念。</p><p>马化腾是对确定性和压力点都极其敏感，也极其执着的人。为什么确定性这么重要？我们都是有感觉的，人生如此不确定，所以当你看到有一个东西非常确定的时候，是让人留恋的。</p><p>我们为什么会留恋自己的家？因为自己的家是一个确定性的存在。但如果两人天天吵架，动不动就会把离婚、分手挂在嘴边，这就会产生不确定感。不确定的东西是没有办法让你投入时间或者持续依赖的。所以我刚才谈了两个很重要的词，<strong>确定性</strong>和<strong>依赖</strong>。在我们整个课程的最后一课，我会再讲一遍，希望你有空也多体会这两个词。</p><h4 id="ATM机的确定性"><a href="#ATM机的确定性" class="headerlink" title="ATM机的确定性"></a>ATM机的确定性</h4><p>还是回到ATM机的例子上，ATM机提供的确定性就是验证ID之后给现金，围绕ATM机系统能力的设计和建设，所做的一切就是为了保证这个确定性。所以如果问ATM机有什么特点？怎么设计？从答案你就可以分辨出，一个产品经理是不是上道了。</p><p>如果让一个不上道的产品经理来说，他就会花过多的时间在ATM机的显性特性上。比如这个ATM机长什么样子，是长的还是宽的，界面是红的还是蓝的，是先出卡还是先出钞，等等。这个产品经理所有的观察和兴奋点，其实只是非常表面的一部分。刚才说了，ATM机的<strong>核心服务</strong>是取钱。一台ATM机里要放20万的现金，如果一个银行提供100台ATM机的话，就意味着要把2000万的现金放到外面去。就是说<strong>当你在提供核心服务的时候，也分流了企业的核心资源。</strong>ATM机是红的还是蓝的，这不是服务的本质，我们是需要回到服务本质来看的。基于这个服务本质我们需要有几个流程：</p><ul><li><p>第一步，首先需要有一个战略判断，战略部门需要做出一个决策，为什么要提供这个服务？提供这个服务对于企业，对于用户的价值是什么？</p><p>这个时候ATM机有两个价值点：</p><p>​    第一个是放在营业网点的旁边，分流取钱的压力，我们看到所有银行的营业网点旁都会有ATM机。</p><p>​    第二个价值点是放在人流密集的地方，可以服务用户，增加企业的曝光，增强用户黏性，提高好感度。</p></li><li><p>第二步，运营部门要对每一台ATM机有没有实现战略诉求来做价值评估。比如，钱放了很长时间都没有被取掉，那可能说明人流过少，这个点就应该拆撤；这个营业网点旁取现压力过大，一台ATM机不足，那就应该增加一台。</p></li></ul><ul><li><p>第三步，在运营部门对每个点的战略价值做完数据分析和价值评估之后，需要哪个点存在，我就要保证它的服务可用。为了保障服务可用，还要做哪些事呢？</p><p>最首要的肯定是现金，一台取不出钱的ATM机就是个铁盒子，是毫无意义的，就像无数个App都做得很漂亮，但用户真正需要一个漂亮的界面吗？不需要。就像我们在《痛点、痒点、爽点都是产品机会》那一课说的，用户需要的是即时满足。我要取现马上给我钱，有源源不断的钱，这个才是最重要的事情。</p></li><li><p>第四步，维护ATM机还要做很多其他事，比如说硬件管理。要保障ATM机不能间断电源，打印机要能打印凭条，还得有油墨、纸张，打印机的硬件不能坏掉。</p></li></ul><ul><li>第五步，要有客服管理。比如机器突然吞卡了，出钞有问题了，用户要投诉，这得有人处理。所以ATM机是一个最简单的产品，因为它提供的确定性就是出钞。钱是最简单的产品，为什么呢？因为它没有用户区分，不管男女老幼，只要拿到钱，他就是满意的。除了钱之外的任何一种商品，可能都是有用户区隔的。男性需求、女性需求、老人需求、孩子需求可能都不太一样。所以ATM机是不需要有用户区隔的，只需要能够保证确定性的供给，用户就会满意。但即使是这样一个最简单的产品，你要能够保证服务，提供完整的系统能力需要七个岗位：<strong>战略、运营、现金、密码、硬件、客服、技术。</strong></li></ul><p>如果说每次取钱ATM机可以收两块钱，一台ATM机总体回收成本大概是10年，这就是整体的服务成本。这也是为什么很多公司死了，而一些看上去页面很粗糙，做得不怎么好看的网站和App依然有旺盛的生命力。因为稳定出钞，这个是最关键的。<strong>持续地提供用户可以依赖的确定性，这个是关键。</strong>如果你把过多的热情花在了诸如ATM机应该是什么形状的，是红的还是蓝的，可不可以再精美一点，这些显性特性的东西上，对于整体的业务效率和业务结果没什么影响。</p><h4 id="本讲小结-8"><a href="#本讲小结-8" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>如果回到第二模块讲的点线面体，你从“面”看回“点”的价值，这时候你就会发现，今天的手机支付越来越普及，我们对现金已经没什么需求了。所以对于ATM机这个“点”，我们基于上述的考虑，ATM机已经走向没落了，所以基于它的技术开发和优化，可以整体降低投入了。所以当你准备做一个产品的时候，你可以把ATM机这个最简单的产品拿出来对照一下：</p><ul><li><p>第一，你的产品在“点线面体”的什么位置？</p></li><li><p>第二，你提供的是一个什么样的确定性？</p></li><li><p>第三，为了保证确定性的稳定提供，你需要的系统能力都要包括哪些环节？你有足够的资本和能力来支撑所有的环节吗？</p></li></ul><p>很多创业企业其实死在这里，你想提供取现服务，知道一台ATM机价格是20万，但是没有把它要用到的资金成本，以及它的七个岗位的运营成本和能力充分地计算在内。用我们的话来讲叫“老鼠尾巴”，就是你抓了一个很小的东西，你以为这就是全貌，但往前走一走，你才发现好大的一块还在后面，这是你完全不能够覆盖的，这样去做产品其实是很危险的。</p><p>课后作业</p><p>1.挑选一个你最熟悉的产品，说说它应该给用户提供怎样的确定性满足？这个产品做到了吗？如果没有，你觉得问题在哪？</p><p>2.持续的满足就会依赖，不确定的感觉就是伤害。你可以说说，你有没有确定性被伤害的时候？</p><p>欢迎你留言与我分享。</p><h3 id="14-系统效率：小米的效率革命"><a href="#14-系统效率：小米的效率革命" class="headerlink" title="14 系统效率：小米的效率革命"></a>14 系统效率：小米的效率革命</h3><p>这个模块是讲系统能力，产品是一个系统能力的产物。</p><p>本模块的第一课讲的是确定性，如果不能保证确定性，用户是没有办法依赖你的，这就不可能有忠诚用户，所有的铁粉是对确定性有依赖。</p><p>这一课讲效率。为什么讲效率？因为企业是效率分工的产物。</p><p>中国古代是自然经济，男耕女织，一个家庭解决所有的问题，但是现在已经再也不会回到那样的社会了。为什么？太没效率。这个环节应该交给谁做，谁的效率高就分工给谁。所以做产品是建设一套系统能力，提供并保障确定性，而效率则是这个系统能力的一个核心指标。</p><h4 id="小米的护城河是效率"><a href="#小米的护城河是效率" class="headerlink" title="小米的护城河是效率"></a>小米的护城河是效率</h4><p>这堂课的案例，我想讲讲小米，为什么？因为手机的竞争是现在产品竞争最激烈的板块。</p><p>当我们在谈产品竞争的时候，我们拼的是什么？是前端的产品吗？一台ATM机，你表面看到的是ATM机，但实际上让它有用的，是它背后银行的系统能力。那么我们看手机市场竞争的时候，它背后是什么系统能力？</p><p>2011年，小米手机一代发布，三年时间就做到了中国第一、世界前三，在全球的硬件企业中，这基本上是绝无仅有的成长速度。2015年和2016年，这两年小米挺困难的，但是在2017年奇迹般地逆转了。这么大体量的硬件企业在大幅下滑之后还能够快速逆转，甚至再次大幅增长，这在全球的商业领域也是绝无仅有的。</p><p>关于小米之前的快速增长和这一年奇迹般的逆转，流传着很多解读版本。我也有一个解读，而我的关键词就是：“效率”。雷军说过：“互联网思维里最关键的是两个点：第一是用户体验，第二是效率。”他还说过：“小米真正的护城河就是效率，而小米真正要做的就是效率革命。”</p><p>与小米竞争的其他手机厂商，认为小米是在比拼产品，其实小米在比拼效率。2010年，雷军带着十几个人，拿着3000万人民币开始创业。3000万是什么概念？就是500万美元，比今天的绝大多数创业者拿到的钱都要少很多。</p><h4 id="三浪并发，推动小米崛起"><a href="#三浪并发，推动小米崛起" class="headerlink" title="三浪并发，推动小米崛起"></a>三浪并发，推动小米崛起</h4><p>他们最先搭起的是小米社区，聚集了一批手机的发烧友，然后在社区以互动的方式做出了MIUI操作系统。这个过程的主导者是黎万强，他出过一本现象级的书叫<strong>《参与感：小米口碑营销内部手册》</strong>。在这本书里，他很详细地介绍了他们怎么每个星期都迭代一版系统，强制性地每周发新版。每个版本如果采纳了哪个网友的意见，就会专门跟这个网友讲：“你上次提的意见，我们新版已经改掉了”。这个网友就超有参与感，于是就有了第一批铁粉。</p><p>对于这批人来讲，MIUI是他们一起做的，小米是他们一起做的，因此是神圣不可侵犯的。在MIUI发布之后，小米继续采用它的参与感大法，推出了小米手机、小米网电商。我的解读是“个人效率”，小米对“个人效率”做了哪些事情呢？用雷军自己的话来讲：</p><p>一方面，互联网把人数字化了，把每个人的工作成果全都数字化了。所以每个人每天都可以看到自己的数字，数字自然会对人产生压力。员工每天一看自己的数字，就得给自己一个判断。</p><p>另一方面，小米打造了一个全员面对用户的组织结构，接受来自用户的压力。</p><p>这个里面的差别在于，你让员工修改一个东西，两个人是要相互说服的。如果你要拿领导的权威去压他，他可能就会说那我改吧，但心里不服气。如果这个建议是来自用户，用户说不舒服，这个员工自己就默默改了，他加班也得改，而且心服口服。</p><p>2011年，小米推出第一款手机。当时市场上有300多个手机品牌，每个品牌都有几十款手机。那个时候我写过一篇文章《Allin——雷军的极致》，为什么雷军会有这么大的勇气，赌上他所有的一切？一次只推一款主力机型，而不是多做几款手机，降低他的失败概率？这和他以效率为核心的价值观是一脉相承的。</p><p>雷军的评估是，很多公司的研发成本高，是因为要开发将近100个型号的产品。小米是把几乎所有的资源砸在一两个型号上，用这一两个型号卖到一个很大的规模。比如，其他品牌做一款手机的研发经费是1000万，我一年投10个亿，做100款手机的研发，这样就分担了企业的风险。小米是用1亿人民币来研发一款手机，单款小米手机的研发投入可能是同行业的10倍，但是总研发成本，小米却是其他品牌的1/10。所以在这个点上，小米也提升了效率。用这种方法，小米把自己的一个单点做到很强。</p><p>我们再回到2011年、2012年，用“点线面体”的战略结构来看这件事情。</p><p>2011年到2012年这个时间节点，是一个三浪并发的时刻，智能手机大换代、消费升级、网红电商的流量红利。</p><p>产品的新需求、用户的变化、流量的变化，这三个时代级的红利一起撑起了小米手机。我们盘点一下，除了小米之外其他手机品牌，这三大红利，它们吃到了几个？你会发现其他品牌最多吃了其一、其二，而只有小米这个“点”有三个快速张开的“面”共同给它赋能。所以小米只用了三年时间，在三大红利的共同推动下，做到了中国第一、全球前三。这个也很好地阐释了，“点线面体”的战略选择有多重要。</p><h4 id="小米快速逆转的法门，还是效率"><a href="#小米快速逆转的法门，还是效率" class="headerlink" title="小米快速逆转的法门，还是效率"></a>小米快速逆转的法门，还是效率</h4><p>刚才说的是小米的老故事，我更想谈的是小米2017年的新故事——小米是怎么逆转的。</p><p>2017年，小米的逆转靠的依然是效率。2015年和2016年两年是小米的负向周期。2017年初，甚至还有一个评论说：“世界上没有任何一家手机公司在销量下滑后还能够成功逆转，小米前途堪忧。”</p><p>为什么这么说呢？因为手机行业的供应链是全球高度整合的，上游高度垄断，技术迭代很快。所以一个手机的成功，需要一个价值网上的很多合作伙伴共同努力才能实现。但是当一个手机品牌进入下滑周期时，容易导致整个价值网都不看好你，也就意味着来自价值网的支持会减少，这势必会加剧这家公司一步一步滑向深渊。</p><p>先不谈小米怎么逆转，先来谈谈为什么vivo和OPPO这两年胜出了，明面的原因至少包括两条：</p><p>第一，vivo和OPPO的用户体验很好，它们的OS做得非常好。</p><p>第二，它们用的是明星代言的流量模式，从电视上拿到了新流量。</p><p>我写过一篇文章叫《创京东》，做市场的同学应该看看，这个套路在那篇文章中讨论过。小米遇到的问题，首先就是流量不够了，在这之前小米销售纯粹依靠互联网流量、靠雷军代言的单一模式，但后期乏力。互联网的战争就是产品和流量。你的产品够不够硬？你从哪里拿流量？OPPO和vivo显然没什么互联网思维的包袱，就是遵从生意的本质，哪有流量就去哪堵用户。所以OPPO、vivo快速做了渠道下沉，沉到了中国六七级市场——县和镇的级别，在全国开了超过60万家专卖店。这个时间窗口，小米一心一意专注在线上，错过了县、乡市场的线下换机潮。这是两家销量拉开差距的一个本质原因。</p><p>从整个中国的商业格局来看，电商其实只占商品零售总额的10%。到今天，其实90%的人还是在线下买东西，即使你拿到了线上100%的市场，但是在整个大市场里，你也只有10%。联想的杨元庆、360的周鸿祎、小米的雷军，都是中关村孕育的豪杰，怎么可能认输呢？为了和OPPO、vivo对决，小米用了不到一年的时间，就把自己的渠道迅速扩张成了一张立体的网。在这之前小米打的是互联网思维，主要依靠小米官网，同时向京东、天猫这一类的主流电商供货。在这之后，它开始启动了小米之家线下店，然后通过电商磨炼出来的大数据，支持线下零售做高效率的决策。目前，小米的线下零售做到了27万的坪效（零售卖场每坪面积所产生的营业额），排在全球第二，并且小米还打算开1000个小米之家。</p><h4 id="利用个人流量，快速拓展小米小店"><a href="#利用个人流量，快速拓展小米小店" class="headerlink" title="利用个人流量，快速拓展小米小店"></a>利用个人流量，快速拓展小米小店</h4><p>我想再说一个小米零售的创新——小米小店。</p><p>阿里也在做一个天猫小店，但是小米小店的特性是它有小米的供应链优势。</p><p>小米之家是开在一、二、三级城市，而小米小店是只开在县和镇这两级，任何个人都可以申请做小米小店的店主。</p><p>小米利用它的大数据来做审核，比如这个人必须得这个县和镇的地理位置上生活，根据手机定位的活动区域可以做判断。便捷的审核后，小米小店就能快速集聚大量的店主，他们很容易就可以把店开起来。接着这些小米小店的店主，就用自己的模式来拓展流量。产品的竞争其实就是产品加流量的竞争，小米利用了大量的个人流量，把它们变成小米小店来拓展流量。你可以去赶集，可以有个自己的店，也可以摆个摊位支易拉宝。所有的货都是小米统一邮寄给用户。但是客服工作还是这个小米小店的店主来承担，为什么？乡里乡亲比较熟悉，解释起来方便。2017年8月，小米小店全国销售量最高的人是一位镇上的警察，他认识全镇的人，所以大家找他很方便。小米小店是在几乎没有人知道的情况下，用不到一年的时间开了20万家。小米的计划是开到100万家。</p><p>这就是小米的策略，用非常快的速度开100万个小米小店，以此来对垒OPPO、vivo的60万家实体店。为什么在我们都不知道的情况下，小米只用了几个月的时间就可以开20万家小米小店？这靠的是小米长期积累的数据智能，也是小米长期运营的智能效率系统。你会发现，雷军打OPPO、vivo这仗和周鸿祎打瑞星方法有点像，都是在用整个“面”来打一个“点”。现在小米和当年的360有点像，都成为了搭建一个三级火箭的模式。</p><p>小米的三级火箭模式是：</p><ul><li><p>一级火箭：小米手机，也是头部流量。我们都知道一级火箭是不挣钱的，所以小米手机的利润极其低。</p></li><li><p>二级火箭：小米手机拉动的立体化零售渠道。</p></li><li><p>三级火箭：未来MIUI、小米云等互联网业务，才真正支撑起小米的利润以及它的智能化未来。</p></li></ul><p>当vivo、OPPO在跟小米拼手机的时候，小米却在拼效率。手机对于小米来讲只是一级火箭，它的智能化未来，才是真正的核心。此外，雷军还很擅于借势，会持续引入其他的外部势能来为组织赋能。我们在讲“点线面体”的时候说过，CEO最重要的事情就是不断地寻求外部势能为你的组织赋能。比如，小米和武汉成立200亿的长江基金，这意味着什么？意味着雷军有200亿来夯实小米业务，但却没有稀释小米的股份，这是一个很高明的做法。所以小米打OPPO和vivo的这一仗，我会赌小米赢。OPPO和vivo当然是非常强悍的“点”，但是小米是用了几个“面”，建立起了一个复杂的“体”来打这个“点”，并且几个“面”彼此借力。这个战术有非常强的周转空间。</p><h4 id="本讲小结-9"><a href="#本讲小结-9" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>第一，小米打OPPO和vivo，看上去是手机的产品战争，但实际上背后是它们的效率之争。小米展现的至少是两方面的效率：一个是小米组织里个人的特殊效率；另外一个是小米系统性地搭建了智能效率。</p><p>第二，当你决定要做一个产品，准备搭建自己的系统能力时，你先问自己一句“我应该从哪个点来建立我系统性的效率优势？”因为没有效率优势，这个系统是一个没有竞争力的系统。</p><p>关于效率，我推荐一个卫哲的演讲，你可以在得到搜索“卫哲”，查看李翔知识内参转述的《卫哲：五个方面提高效率》来了解。</p><p>再次强调，<strong>企业的存在就是社会效率分工的产物，天下武功唯快不破。</strong></p><p>课后作业</p><p>企业是效率分工的产物，那么你所在的企业的护城河在哪？你觉得它在哪个方面的效率比别人做得更好？</p><h3 id="15-系统世界观：微信、米聊、陌陌"><a href="#15-系统世界观：微信、米聊、陌陌" class="headerlink" title="15 系统世界观：微信、米聊、陌陌"></a>15 系统世界观：微信、米聊、陌陌</h3><p>第三个模块的第三节课，我们来谈迭代。</p><p>迭代是什么意思？<strong>迭代就是小步快跑，把最内核的部分先放出来，不断优化、小范围试错。</strong></p><p>我有个说法：让互联网产品在互联网上生长。</p><h4 id="产品设计要直指人心"><a href="#产品设计要直指人心" class="headerlink" title="产品设计要直指人心"></a>产品设计要直指人心</h4><p>为什么要把迭代作为专门的一节课来讲？</p><p>简单粗暴的回答就是：<strong>版本规划能力是产品经理的重要能力。</strong>当然这是一个角色化的要求，但是为什么要这样做角色要求呢？因为我经常看到有的产品经理出产品规划，第一版产品就无比复杂。我常常听某个产品经理，非常有激情地介绍自己规划的产品，无比复杂。这是一开始就要做整个互联网吗？<strong>判断一个产品经理是否厉害，很重要的一条就是判断他设计的产品第一个版本有多简单、直接、切中要点，能不能直指人心。</strong></p><p>为什么很多产品经理要把产品的第一个版本设计得那么复杂？因为他们不自信。他们对“我只要做强哪个点，用户就必然买账”没把握，而希望在一些附加的功能点上，寻找心理依靠。这种产品天生没劲，怎么可能意外爆发。</p><h4 id="系统能力让微信赢了米聊"><a href="#系统能力让微信赢了米聊" class="headerlink" title="系统能力让微信赢了米聊"></a>系统能力让微信赢了米聊</h4><p>在这节课，我讲一个案例——微信的迭代过程。</p><p>今天，咱们都已经非常依赖微信了，使用微信聊天、支付、玩游戏、订电影票，觉得一切都是如此天经地义。但实际上，它也是从非常简陋的版本，一个非常小的内核开始，一点一点迭代，成为了今天的样子。</p><p>微信是腾讯在2011年1月发布的一款产品，比小米公司的米聊晚两个月。微信的1.0版本基本和米聊一样，应用场景定义为熟人间的通讯工具。简单说，就是可以免费发短信和照片，代替收费短信和彩信。</p><p>为什么说它的定义是熟人间的通讯工具呢？因为微信刚上线时只有四个主要功能：</p><ul><li><p>导入通讯录；</p></li><li><p>发送信息；</p></li><li><p>发送图片；</p></li><li><p>设置头像和微信名。</p></li></ul><p>备注和黑名单功能是在微信的1.2版本才加入的。微信的1.0和1.1版本时，加好友是不需要备注的，因为我不会加陌生人，这里只有我特别熟的朋友。微信2.0版本时，微信用户有400万，而米聊有1000万。所以在微信1.0的时代，不管是功能上还是用户数量上，微信一直在追赶米聊。米聊有开发人员在论坛上说：这是我们米聊新上的功能，截个图，放在论坛立帖为证，微信几天之后就会抄我们。果然，一周之后，微信就抄了这个新功能——语音通讯功能。但是，微信2.0的时候很快就追上了米聊，并从此将米聊远远甩在后面。为什么？抛开前端体验，就系统能力而言，微信的运维能力比米聊强太多。张小龙在做微信之前，做了十年的腾讯邮箱，那是全国最大的邮箱服务平台。它有一个很强的功能是超大附件，要有强大的服务器功能保证，超大数据定点传输中负载均衡，系统不崩溃。微信的背后有数十万台服务器支撑微信的数据流量。这样的系统能力建设，对于腾讯这样的公司是天然的。而创业初期的小米，根本不可能囤积那么多的设备去提升米聊的性能。所以两个前端体验基本一致的产品，你用微信，永远都会觉得很快，而米聊有时会慢、会卡，偶尔会系统崩溃。两个产品的区别在这里就开始拉开了。回到ATM机的例子，比起系统能力，前端那个铁盒子没那么重要。</p><h4 id="微信、陌陌、米聊的不同路径"><a href="#微信、陌陌、米聊的不同路径" class="headerlink" title="微信、陌陌、米聊的不同路径"></a>微信、陌陌、米聊的不同路径</h4><p>微信赢米聊，仅仅是靠系统能力吗？绝不仅如此。迭代中，重要的是次序，前一个动作是后一个动作的预动作。微信2.1版本里添加了一个新的功能，叫做“好友验证”。2.1版本之前，都没有好友验证。随后2.2版本推出一个核心功能，叫做“查看附近的人”。戏剧化的是，微信发布“查看附近的人”功能的同一天，另外一款和它一模一样的产品在苹果的AppStore上线了，这款产品叫陌陌。陌陌和微信在同一天开始，基于位置的陌生人语音社交。米聊就此止步于熟人社交，直到很长时间之后才打破这点，但那时大势已去。微信和米聊刚开始的产品中观设计是一样的，为什么几次迭代之后，走上了不同的道路？</p><p>我个人揣测，因为张小龙、唐岩是湖南人，雷军是湖北人，三个人非常不同。雷军少年得志，非常年轻就成为了中关村的大佬。他的世界一直非常拥挤，他的时间极端宝贵。他个人的需求就是提升与熟人间的沟通效率，没有需求认识一个陌生人。张小龙和唐岩是曾体验过孤独与弱势的人，所以他们有与陌生人建立连接的需求，并且对和陌生人交往过程中，压力点的体验非常清楚。区别是什么，注意一些细小的点，比如“表情包”。人为什么要在交流的时候使用表情？其实是因为用户很多时候找不到合适的词汇。QQ最早就在表情包上下功夫，帮助想表达却老是觉得词不达意的宅男宅女，用一种更轻的思考方式传递自己的想法、感觉、情感。长于沟通、长于说服的雷军、马云，出品的通讯工具，从来不在表情包上下功夫，因为老板没有被辞不达意困扰过。这是什么？这叫<strong>微观体感</strong>不同。在米聊上，你发了一个信息会有信息状态，如果对方读了就会从“已发送”改为“已读”。而微信没有这个设置，为什么？腾讯的高层为了这个点，讨论了好几天，最后还是觉得，这一点点功能会给对方心理压力太大，还是决定不放。我之前说过，马化腾对压力和确定性的体会极深。但雷军一直是大佬，对给人压力这件事，没有那么在意。增加了“查看附近的人”功能以后，微信的用户从400万达到了2000万，与仍然专注熟人社交的米聊拉开了差距。随后的迭代里，微信3.0推出“摇一摇”功能。3.0之后，微信用户上亿，米聊的峰值永远停留在了3000万。</p><p>在这里，我再补一句场景概念。我在《设计产品时要包括产品的场景》那节课说：</p><p><strong>“在万物互联的未来，到处都是屏幕，到处都是网络连接的入口。入口不是场景，能触发情绪才是。”</strong></p><p>米聊的例子，就印证了入口不是场景，不一定产生流量。小米手机年销售几千万台，几年下来应该累计了几亿小米手机的用户吧，而每一台手机上都内置了米聊，但米聊用户非常少。这就叫“有入口，没场景”。</p><p>米聊就说到这里，我们接着说和微信的“查看附近的人”同一天上线的陌陌。米聊的系统能力弱于微信，陌陌难道好吗？当然不。运维能力不足、代码效率差的问题，陌陌在初期其实也遇到了。唐岩告诉我，曾经陌陌流量过大，导致宕机3天，服务器瘫痪。但是3天之后，服务器一旦再次运转，那些饥渴的用户瞬间回到这里，并没有流失。为什么？对于寻求某种满足的人，陌陌能提供确定性满足。</p><h4 id="本讲小结-10"><a href="#本讲小结-10" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>是去连接广阔的陌生人，还是提升与熟人沟通的效率，这是微信与米聊的区别。微信的3.5版本，与陌陌也拉开了差距。3.5版本的微信先做了功能前置，加了“扫描二维码”；3.6版本的微信加了“微信公众号”。从3.6版本开始，微信与陌陌开始走向不同的道路。陌陌继续连接陌生人，而微信选择去连接线下更多的内容与商业，去连接广阔的物理世界。3.6版本的微信，赢了米聊与陌陌，但依然是一个通讯工具。但微信没有止步于此，它继续迭代和蜕变。这节课就到这里，下节课我们继续讲微信的迭代。</p><p>课后作业</p><p>微信的迭代其实有两个价值：</p><p>对外部，可以快速得到用户的反馈，让用户反馈去驱动产品；</p><p>对内部，建立了开发团队的节奏感和确定性，每周都有新版本。</p><p>请分享一下：</p><p>1.你的公司或产品对于新版本的节奏或者感受。</p><p>2.欢迎你谈谈对微信故事的感受。</p><h3 id="16-系统迭代：微信红包的意外与刻意"><a href="#16-系统迭代：微信红包的意外与刻意" class="headerlink" title="16 系统迭代：微信红包的意外与刻意"></a>16 系统迭代：微信红包的意外与刻意</h3><p>微信确实是这个时代最伟大的产品之一，所以咱们用两讲的时间来说一说微信是怎么迭代过来的。即使是用两课的时间来讲，也只能讲一些非常皮毛的东西。</p><p>上一讲，我们说到微信在2.2版本之后就甩开了米聊，从3.6版本之后和陌陌走上了不同的道路。这一讲我们从微信的4.0版本说起。</p><h4 id="迭代中，核心功能最重要"><a href="#迭代中，核心功能最重要" class="headerlink" title="迭代中，核心功能最重要"></a>迭代中，核心功能最重要</h4><p>微信1.0版本，就是一个在熟人之间可以免费发文本信息和图片的工具。</p><p>微信2.0版本，增加了微信的语音功能和“查找附近陌生人”的功能。到这里，微信成为了陌生人语音社交的工具，但还是个工具。</p><p>微信3.0版本的时候推出了“扫一扫”、“服务号”，从这个点开始，微信开始连接世界。</p><p>微信4.0版本的时候，微信推出了“朋友圈”，也就是说微信从通讯工具开始进化，变成了社交平台。</p><p>微信在推出“朋友圈”功能之前，做了两个前置工作：3.5版本加了扫描二维码；3.6版本加入了微信的公众号。这两个动作的价值在于，一个普通人的生活没有那么多可供朋友消费的内容，如果没有这两个前置功能，我们就直接打开朋友圈，会非常难看。</p><p>4.0版本时，你在朋友圈发照片，如果朋友评论，你是没有办法回复评论的。回复评论的功能，直到4.2版本才做出来。这说明什么呢？没有必要憋大招，没有必要把所有功能全都做好再放出来。不能回复朋友在朋友圈下的评论又怎么样呢？如果我非常想回复他，大可以点对点跟他说。所以产品的核心功能点有效比什么都重要，基于核心功能附加的其他功能点没有那么重要，可以一步步来。接着就是微信的4.5版本，推出的就是今天的内容公众号，推动了一批媒体人创业，孕育了一大波网红。</p><h4 id="微信红包的发布"><a href="#微信红包的发布" class="headerlink" title="微信红包的发布"></a>微信红包的发布</h4><p>微信的5.0版本，对微信来说有一个巨大跃升，就是加上了“绑定银行卡”。要知道在5.0版本之前，微信是不沾钱的。如果微信不加“绑定银行卡”的这个动作，没有把微信和钱连在一起，微信就是一个移动版的QQ空间，大家可以在这里晒照片、聊天、彼此点赞。但是微信绝不会成为今天的移动生活场景，甚至是移动商业帝国。5.0版本的第一个挑战是什么呢？那时微信已经有了4.7亿用户了，大家平时用微信的社交功能已经够用了，为什么要升级到5.0版本，又为什么要把我的银行卡绑在微信上？</p><p>关于这一点，我会在微信的6.0的版本里谈。但是微信得先拥有绑银行卡的能力，这个能力点是5.0版本提升的。怎么让大家升级成5.0版本？这个时候微信做了一个非常漂亮的运营，而这个运营是通过产品来完成的。它推出了一个小产品，我想你还有印象，就是“打飞机”。那个时候如果你刚升级了5.0的版本，一打开微信就直接出现一个“打飞机”游戏的界面，然后大家就都开始玩。身边的人听说了也会去升级版本，加入打飞机大战的战团，彼此PK。微信就在不知不觉间，完成了5亿用户的升级。直到今天，我们经常看到一些App拉用户升级，还是会非常傻大黑粗地吆喝一下：“你的版本过低，建议升级”。甚至更讨厌的就是直接闪退，不升级不让用。这就是产品的高低段位的差别，哪怕在你让用户选择版本这一个动作上，怎么能让用户舒舒服服地去更新，差别都是很大的。接着就是刚才已经预告过的微信6.0版本。这个时候，微信面对的难题是：用户为什么要把自己的银行卡绑定在微信上？而且还要在微信上发生钱的流通？这时候有一个重要事件就是微信红包。微信的支付团队是从财付通团队脱胎而来的。互联网圈都知道，大概有十年的时间，支付宝一直都是财付通头顶的一座大山。2013年的第三方统计，移动支付市场，支付宝的市场占有率是76%，财付通只有3.3%，20多倍的差距，这是三层楼和76层楼的体量差别。就是在2013年这一年，诞生了微信红包，改变了支付战局。微信红包是财付通下面的微信支付团队里一个小团队内部做的一个小项目，一群小孩利用自己的业余时间没有做任何的申报，用公司资源就做了。当时微信支付的总经理吴毅在回忆微信红包发布的场景时说，他当时在自己的办公室里坐着，觉得外面的办公区特别吵，一帮人在那儿又喊又叫地折腾。他就推门出去说：“你们在干什么？怎么这么吵啊？上班呢！”这些小孩就说，“我们以前说要做一个发红包的小应用，现在做出来了，特别好玩，要不你试一试？”一个是点对点红包，一个是拼手气红包，当时还是作为一个插件安装在微信里的，大家开始测试，这时候就有人顺手把一个红包丢到了腾讯的一个大群里。于是从根本上改变了支付宝和财付通战局的产品就这样发布了。在此之前，其实腾讯内部都不知道有这样一个产品。接着，我们就看到微信红包从一个小插件，换到了输入框下面的重要位置。现在红包已经成为了微信使用率最高的功能，远远大于“查找附近的陌生人”、“摇一摇”，这些微信的早期里程碑产品。</p><h4 id="圈层与圈层壁"><a href="#圈层与圈层壁" class="headerlink" title="圈层与圈层壁"></a>圈层与圈层壁</h4><p>有两个故事，我想把它拆出来，再讲一下。</p><p>第一个故事，我想通过这个故事讲一个概念词——<strong>圈层</strong>。我们都生活在某个圈层里，而且<strong>圈层之间是彼此不了解</strong>，<strong>也很难破壁的</strong>。比如，我原来腾讯的同事，一个1985年的男生，他做了一个短期小额贷款产品，大概每天有300多万人向他贷款。他基本上是通过大数据的方式去审核筛查，给100万多人放钱。这些人要贷多少钱呢？基本上是贷200块到1000块钱之间，贷款的时间大概是两个星期到两个月。场景就是很多人离发工资还差两个星期，但是实在没有钱撑不下去了，需要借200块钱撑两个星期。所以我当时的第一反应就是，我不能理解为什么200块钱还要贷款？他说：“这就是圈层，是有这样的圈层存在的。你去关注一下这群找我贷款的人的关系链，你会发现，几乎是同一时间，这个人的整条关系链都在借钱。”就是说这个人要借200块，而他身边几乎是人人都在借钱，没有人可以借200块钱给他。这件事情我当时听到是很震撼的。</p><p>回到微信红包，也有一个故事，我非常震撼。刚才说微信红包是在2013年的某一天偶然间发布的，然后就很自然、很流畅地被大家发来发去，进入了各个互联网公司，大家都开始使用。2014年春节，微信红包就达到了它的第一个用户峰值，多少人呢？458万人。这之后的几个月时间里，微信红包的用户数就再也没有突破过这个数字。除夕肯定是红包的高发期，那一天使用微信红包的达到了458万人，之后的几个月，又从这个高峰值上掉下来了，而且再也没有达到过这个数字。这叫什么？这就叫遇到了<strong>圈层壁垒</strong>。所以每次有人问我说互联网圈的核心活跃人数有多少？我就跟他说，有458万。因为这是微信红包按照它的自然能量达到的极限值。像红包这么天然的东西，微信红包操作又是这么简单，但是在没有借助任何外部势能的情况下，将近7个月的时间，它就困在400万用户里无法突破。实际上，互联网的尝鲜爱好者就这么多，它的自然传播极限大概也就是这样了。这个圈层壁是怎么被打破的呢？春晚。我想很多人还记得，2015年微信和春晚合作。我们不得不承认，春节就是我们中国最高的文化势能之一。微信是怎么做的呢？就是摇一摇抢红包，操作足够简单，当天微信红包新增一亿用户。从400万用户到一亿用户，靠春节这样一个核心场景的触发完成。支付宝积累一亿用户用了多久呢？大概是8年，而微信支付是一天。当然，能够一天从400万用户平滑升级到一亿用户，这也是依靠腾讯强大的系统能力。不是随便一个小公司，给你一亿用户你就能接得住。</p><p><strong>支付宝红包有什么不同</strong></p><p>刚才我们说的是微信红包，虽然支付宝红包前面讲过，但这里作为对照你再看看支付宝红包有什么不一样。关于2015年的支付宝红包为什么失败有很多总结，比如社交场景不同。但我们从用户体验来讲：</p><p>微信红包简简单单，发的就是红包，点开就是钱，再没有其他的东西了，拿到就很爽。</p><p>支付宝红包上面则是放了一堆广告。我收发一个红包，还得给淘宝打广告，点红包没有瞄准，可能还点到广告上。这是什么呢？就是不爽。</p><p>关键问题是什么？是支付宝没有认真去总结问题，同样的错误，它在2016年又犯了一次。2015年微信红包通过和春晚合作，用户一举破了亿。2016年，阿里砸了2.69亿元拿下了猴年春晚的合作资格，干什么？就是推支付宝红包。它是怎么做的呢？它当时还提了一个概念叫“集齐五福，分两亿现金”。你肯定也有印象，一堆人都集齐了四福，就差最后一张敬业福。我们来盘点数字，支付宝一共发出了82万张敬业福。而所有的用户里，集齐五福的有多少呢？79万。这样一听没什么概念。我们再扔两个数据出来，参加这个活动的用户有多少呢？最少不可能少于2000万，而支付宝的总用户是多少呢？四亿用户。我们在第一课就讲了，什么叫爽，就是被满足。被满足的感觉就是爽，不被满足就是不爽。我满怀期待，努力了半天去集福，集齐了四个，最后一个没集着，肯定不爽。2016年支付宝红包的不爽率有多高？支付宝花了2.69亿去打广告，如果有2000万用户参与支付宝抢红包的话，不爽的人大于96%。如果说是它的四亿用户都去参与了抢红包，不爽率是99.8%。总之，从此微信支付就一举改变了这种战局。</p><p>现在有不同的统计数据，但总体来讲都说微信支付和支付宝两家的体量是相接近的。从我来讲当然是希望它们继续打，因为商家竞争，我们用户的体验才能变好。</p><h4 id="本讲小结-11"><a href="#本讲小结-11" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>到这里，6.0版本之后的微信就是咱们今天熟悉的样子，它就成了我们今天移动生活的场景。</p><p>我们简单地讲了微信的六次大版本的迭代，它过去一共迭代了几百次。从最早是一个通讯工具，到社交平台，到现在的移动生活场景，甚至是移动商业帝国。它自己从一个“点”变成了一个“面”，最后形成了一个巨大的经济体，无数企业和个人，从生活到财富，光荣与梦想，都能够在微信里得到支撑，甚至在微信上完成闭环。腾讯的强大是这家公司的系统能力，它能够孕育出一批小马化腾，不断在腾讯的土壤中产生像QQ、QQ空间、微信、王者荣耀这一类奇迹级的产品。微信肯定已经成为了一个经济体，但它也只是腾讯公司的一个产品。</p><p>腾讯当然是这个数字时代的一个巨大经济体，腾讯同时也是深圳市的一个企业，只是深圳的350个上市公司之一。</p><p>深圳有350个上市公司，这个城市不过只有37岁，比我们今天很多得到App的用户还要年轻。罗马不是一天建成的。不管我们今天看到的是微信这个我们每天都要依赖的产品，还是腾讯这家公司，抑或是深圳这座城市，都是迭代的产物。我们自己的人生也是迭代的产物。</p><p>从一个最好的内核开始，一个一个动作地持续迭代和一次一次微小的选择，就会成就你的产品以及你的人生。微信不过就是7年，深圳市也不过就是37年。今天你在一个什么样的点位上没有那么重要，重要的是在未来的几年里，你会用什么样的方式持续迭代。</p><p>课后作业</p><p>1.微信红包这样的产品都有好几个月的时间无法突破圈层壁垒，你的产品有没有遇到过这样的情况？你是怎么做的呢？</p><p>2.你的人生产品，你准备怎么迭代呢？</p><p>欢迎你与我分享。</p><h3 id="17-系统生死线：猎豹和它的关键任务"><a href="#17-系统生死线：猎豹和它的关键任务" class="headerlink" title="17 系统生死线：猎豹和它的关键任务"></a>17 系统生死线：猎豹和它的关键任务</h3><p>第三模块的最后一节课，我来讲关键任务——穿越生死线。</p><p>这个话题是我和阿里巴巴管HR的副总裁王民明聊领导力的时候谈到的。我问王民明：“阿里巴巴怎么定义领导力？”他说：“把握客观元素，把事情做成的能力。”接着他又说了一个很有趣的话题，阿里巴巴对领导力的定义就是带领大家穿越生死的能力。</p><p>在日常状态下，大家做流程、分工、项目进度、质量评估，这个叫<strong>项目管理</strong>。但是，在面对巨大压力，甚至是生死存亡的时间点时，在一大堆事情里找到关键任务，带领所有人穿越生死，这个是<strong>领导力</strong>。</p><h4 id="朝鲜商人的生死线"><a href="#朝鲜商人的生死线" class="headerlink" title="朝鲜商人的生死线"></a>朝鲜商人的生死线</h4><p>韩国作家崔仁浩写过一本小说叫《商道》，讲的是19世纪朝鲜时期商人林尚沃，从一无所有变成了富甲朝鲜九道的朝鲜首富的故事。</p><p>这本小说讲了林尚沃的三个节点，分别是：“死”、“鼎”、“戒盈”。</p><p>我们就讲他的第一个节点：“死”，林尚沃遇到的第一个生死线就是一场商战。</p><p>当时朝鲜最有价值的商品是红参。林尚沃带商团到北京和大清商人在做交易时，遭遇到了清商的联合压价。清商希望成交价是70两白银。林尚沃为了扛住价格，借款收购了朝鲜商团所有的人参，形成了垄断。清朝商人就联合抵制，不降价他们就不买。这时，林尚沃面对巨大的压力，他是借的钱，所有的人参在他手上，如果人参卖不掉，贷款的利息他都还不起。这时他做了一个选择：烧人参。反正每天烧一点，如果没有人来买，我就把今年朝鲜的人参烧光，今年中国市场上就没有朝鲜人参了。于是，清商的联盟就崩溃了，按照林尚沃的价格160两白银成交。</p><p>当时有人问林尚沃，你烧人参的时候，有没有想过人参都烧完了，还没有人找你买怎么办？林尚沃说，“在我刚开始动手烧人参的时候，我就已经想好了，如果所有的人参都烧完了，我就跳进火里自焚，和人参一起消失。”这就是生死线，这就是别人不敢玩、不敢拼的风险，就是壁垒。在生死线之外是安全区，安全区是没有壁垒的。</p><h4 id="腾讯用风控能力区分职级"><a href="#腾讯用风控能力区分职级" class="headerlink" title="腾讯用风控能力区分职级"></a>腾讯用风控能力区分职级</h4><p>腾讯的职级系统中，对不同级别员工的风控能力的描述很智慧。</p><p>普通员工，明确知晓常见风险。比如，别靠近水，游泳有风险。</p><p>项目经理，具备风险规避意识。比如，安排活动路线的时候，有危险的地方就放弃、绕过。</p><p>小蓝车估值十亿，一瞬间消失了，这叫不具备风险规避意识。</p><p>总监，有风控能力。我有风险规避意识，明确知道长线风险。避不过的时候，我知道应该怎么组织大家，以及做好突发事件的预案。</p><p>总经理，能操作有风险的执行。常规水域安全但竞争激烈，僧多粥少。有个地方鱼很多，但是要穿过一片风高浪大的地方，我有本事跨越大海，带你们去资源丰盛的地方打大鱼。</p><p>常言道：富贵险中求。</p><p>平平安安，顺顺当当的地方，一定早有人来到这里，趟平所有的坑，控制了核心资源，并定下了有利于他自己的规则。平原地带的竞争，一定是体量大的赢，先到的赢，不要命的赢。所以，如果你来得晚、体量小、还怕死，就踏踏实实地按照项目管理的方法做项目。知足常乐、自求多福，也是一种人生的选择。但是如果你有强悍的愿景，你不甘心，还有另外的道路。</p><h4 id="傅盛带领金山，跨越生死线"><a href="#傅盛带领金山，跨越生死线" class="headerlink" title="傅盛带领金山，跨越生死线"></a>傅盛带领金山，跨越生死线</h4><p>刚才讲了一个小说里朝鲜商人的故事，我再分享一个我身边朋友的故事。傅盛和他的猎豹的故事。</p><p>在第二个模块讲“点线面体”的时候，我讲了周鸿祎如何利用互联网思维杀入了杀毒市场，并且一举占据了杀毒市场大概90%的市场份额。当时杀毒市场里都有谁？老大是瑞星，还有江民、金山。瑞星、金山、江民这三家都是在杀毒这种点状市场里竞争，大家都是一条连贯的曲线，线性发展了很多年。突然冒出来360的降维打击，它们就像遇到了非连续，原来的线性发展无法持续。瑞星、江民持续了十年的线性发展到此戛然而止，而金山跨越了非连续，也就是说它穿过了生死线。有一个很有名的记者——程苓峰，写过一篇很棒的关于这个故事的报道，你可以搜一下看看。360其实是傅盛做的，后来傅盛从360辞职。更加戏剧性的是，2010年他带着自己创业的可牛公司几十个兄弟加入了360的对手金山，合并以后公司就改名叫金山网络，后来又改名叫猎豹。所以他到金山网络的时候，应该算是危机四伏，生死一线，列出来的死法至少有三种：</p><ul><li><p>第一种死法就是可牛和金山合并不顺利，团队崩盘，公司死了。</p></li><li><p>第二种死法就是被360灭掉。2010年，周鸿祎就放话说，当年有一家安全厂商会死，一夜之间卸载了金山网盾的8000万用户。当时网盾的负责人陈勇，一个汉子放声痛哭，基本上大家就知道周鸿祎放言要灭掉的是谁了。</p></li><li><p>第三种死法，他们团队没有崩盘，也没有被360灭掉，但是因为产品没有办法超越360，只能是在股东的保护伞下苟延残喘，赖着过日子，先被嫌弃，再被抛弃，慢慢死去。</p></li></ul><p>死法有三种，而活路只有一条，就是跨越非连续。</p><p>从一家已经有23年历史的软件公司变成一家互联网公司。他们面临的风险是同一个，不改革是等死，改革是找死，甚至有可能死得更快。那个时候傅盛只有33岁，当时他面对的局面还包括傅盛和金山合并的时候，傅盛有40人，金山400人。金山23年了，很多人都在这里干了十多年，所以老金山人是不信任这个年轻人的，并且同时怀疑他的能力。金山的工程师水平不错，所有的企业都跑过来高薪挖人，很可能只要有一个骨干走了，所有人一瞬间就走光了。所以，傅盛在决定接手金山的48小时之内就做了几个决定。</p><p>第一，   我们不能够做一个全新的创业公司，我们需要先守住根基——安全。</p><p>当时金山毒霸的日活跃用户只有700万，而且还在跌，360当时有一亿用户。当时乔布斯回到苹果也是先守根基，第一件事是先重新把Mac做好，推出了iMac之后才推出了iPod，重新奠定江湖地位。</p><p>第二件事就是砍产品，Allin。</p><p>我们在之前讲过，如果你对自己不够自信，才会分散精力，但是如果你内心可以放下恐惧，在最重要的点上全力以赴，才真的有可能把这个点做强。傅盛把金山原有的七八条老产品线砍到只剩下了两个——毒霸、卫士。因为如果你不集中力量肯定是死。所有人员都被抽调去做毒霸肯定不痛快，但是理解得砍，不理解也得砍。</p><p>第三件是就是砍组织结构。</p><p>一个23年的公司，副总裁、高级总监、总监、高级经理一概取消，把整个公司从十来个层级砍到只剩三层：管理层、骨干层、执行层。管理层一竿子扎到底，就像指挥打仗一样，直接过问产品细节，直接跟一线员工和用户沟通。然后把技术、产品、运营、市场、销售、售后这些部门全部打通，所有的职能围绕产品线重新组织。整个公司只剩下两个部门，就是毒霸和卫士，所有的人都为产品服务。产品与研发、市场就不再是平级的了，我是你的领导。</p><p>第四件事，做个野蛮人。</p><p>几刀砍下来，金山的老人们看傅盛的眼光不再是怀疑，而是“你伤害了我们的感情”、“你打破了内部和谐”。傅盛索性就做个彻底的野蛮人，实话都抖出来。金山是一家成立了23年的老牌软件公司，为什么被刚成立几年的360打成这样？就是因为因循守旧、表面和气。我今天是伤害了你的面子、你的尊严、你的友好气氛。但是在生存面前，你能不能放下面子，放下尊严，放下友好气氛，生还是死，我们搏一次。你可以说傅盛运气好，他干完这些事四个月后，就赶上了3Q大战爆发。那个时候腾讯干了“二选一”，要求所有的用户卸载360。腾讯要求用户卸360就必须给出非腾讯的第三方替代方案，当时只有金山一家同时有杀毒和安全的全套产品并且性能完善。这也归功于几个月前傅盛叫停其它业务，全力打造这两款核心产品，并且在3Q大战前一个月推出。腾讯“二选一”三天后，金山毒霸日活跃从700万涨到1200万，卫士从200万涨到1000万。3Q大战打完，360上市了，腾讯开放了。金山这家老牌软件公司完成了向互联网公司的蜕变，跨越了非连续，活下来了。瑞星和江民，今天已经边缘化了。</p><h4 id="领导力的核心，是甄别关键任务"><a href="#领导力的核心，是甄别关键任务" class="headerlink" title="领导力的核心，是甄别关键任务"></a>领导力的核心，是甄别关键任务</h4><p>这个故事核心表达的是什么呢？</p><p>面对生死考验的时候，你能依靠的不是管理能力，而是领导力。</p><p>领导力的核心，是甄别“关键任务”，然后动员大家穿越生死。</p><p>一个人如果曾经有一次穿越生死，他做事的态度，他的笃定和胆魄，一定不同于常人。每天都为一些员工的小情绪纠结掂量的管理者，一定是没经历过生死的。</p><p>傅盛和他的猎豹的故事，我个人非常喜欢。因为他在强敌压境的情况下，完成了一个软件公司向互联网企业的转型，穿越了生死线。并且在这之后，傅盛带着他的猎豹第二次跨越了非连续，完成了向移动互联网，向海外能力扩展的企业能力突破。这个故事我会在第五模块再讲。</p><h4 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h4><p>第三模块系统能力就大致介绍完毕了，我在这里把第三模块简单总结一下。</p><p><strong>所有的产品都是某个系统能力的结果，你要的不是做一个产品，而是建设一套系统能力，然后为你的用户提供确定性。系统能力的效率优势、系统的迭代能力，都不是最后你呈现的产品表面能看得出来的，但是你的系统能力是你的产品能否存在的本质。如果生于和平年代，也许按照项目管理，把项目做好上线运营就好了。但机会、资本、野心、人才云集的今天，几乎每一块蓝海，都会转瞬变为红海。你需要的是像摩西一样的领导力，甄别关键任务，动员众人，劈开红海，带领大家穿越生死。只要你在创业，终有一天会面临跨越生死。那个时候，副总裁、总监通通都帮不了你。这时能够支撑你的，是你对关键任务的甄别，你内心的确认感和你真正的兄弟。</strong></p><p>课后作业</p><p>在跨越生死的关键任务场景下，股东、竞争对手、核心团队、公司中层、公司员工、用户，这六类人你最在意谁？你会把精力放在谁的身上？欢迎你跟我讨论一下。</p><h3 id="模块四）-用户体验"><a href="#模块四）-用户体验" class="headerlink" title="模块四） 用户体验"></a>模块四） 用户体验</h3><h3 id="18-用户体验的五个层次"><a href="#18-用户体验的五个层次" class="headerlink" title="18 用户体验的五个层次"></a>18 用户体验的五个层次</h3><p>我们进入第四个模块——用户体验。</p><p>之前三个模块，我们希望解决的问题是<strong>你能够情绪纠偏、认知纠偏，不再只从原生感受上来看问题</strong>。接着我们讲的是建设系统的能力。厚积薄发，“厚积”是系统能力，“薄发”是表面的呈现，就是用户体验。我们看到很多新的互联网公司、淘品牌，系统能力不如传统企业，但是可以从传统企业那里抢夺大量用户，靠的就是用户体验。在体量差异这么大的情况下，用户体验能成为核心竞争力；同维度竞争的时候，用户体验更是最核心的竞争力。</p><p>从这节课开始，我们要连续用5节的课程讲用户体验。</p><p>我给腾讯起的外号是“拜用户体验神教”，每个人都像念咒一样每天念用户体验。你在腾讯每次想推动事情前进，想拒绝需求，都得提用户体验。用户体验到底是什么？不是一句“好用”或“不好用”能说得清的，我们要拆得很细。</p><h4 id="用户体验的五层要素"><a href="#用户体验的五层要素" class="headerlink" title="用户体验的五层要素"></a>用户体验的五层要素</h4><p>我推荐一本书叫《用户体验要素》，一本讲网站设计的书。我把它的框架，加了一点自己的理解。《用户体验要素》这本书里提到：“用户体验的要素，来自5个层次的层层选择与叠加建设。”这五层分别是：</p><ul><li><p><em>感知层</em></p></li><li><p><em>角色框架层</em></p></li><li><p><em>资源结构层</em></p></li><li><p><em>能力圈范围层</em></p></li><li><p><em>战略存在层</em></p></li></ul><p><strong>最核心的战略存在层</strong></p><p>就是着手做任何一个产品前，必须明确地定义这两个问题，你需要把它们贴在墙上，保证项目组的每个人都清楚，都认同：</p><ol><li><p>我们要通过这个产品得到什么？</p></li><li><p>我们的用户要通过这个产品得到什么，他们为什么会依赖我们？得到我们各自需要的东西，我们才能继续做下去。</p></li><li>你对自己的存在战略设计是什么？你能存在，不是因为你厉害，而是别人需要你，别人能持续依赖你。真正厉害的人，能清醒地认识到这一点。</li></ol><p>我前两天又把毛泽东的<strong>《中国的红色政权为什么能够存在？》</strong>读了一遍，从这篇文章中，你可以看到什么是战略能力。战略能力，讲未来，更讲现在；讲长远的愿景，更讲谁需要红色政权，谁需要持续依赖红色政权。有人需要才是红色政权的存在条件，也是它的发展基础和战略。</p><p><strong>战略层的外延是第二层——能力圈层</strong></p><p>能力圈要确定：</p><ol><li><p>我们要做到哪些事，具体要提供什么样的确定性。</p></li><li><p>我们不做哪些事，对这些事坚决不碰。</p></li></ol><p>35岁的毛泽东对范围层的定义是：农村包围城市。能力圈的建设是：要在三不管地带建立根据地，要建立自己的武装军队。能力圈是变化的。如果有清晰的战略，能力圈就会朝着战略的方向变化、拓展；如果没有清晰的战略，能力圈的变化就是偶发和随机的。</p><p><strong>能力圈的外是第三层——资源结构层</strong></p><p>毛泽东一句话定义了“资源”，就是“谁是我们的敌人，谁是我们的朋友”。建设资源固然和能力有关，但更与战略相关。就好像《西游记》里唐僧取经一路过关，靠孙悟空上天入地搬神仙帮忙。孙悟空能上九重天，敲神仙的门，固然是孙悟空的能力；但所有的神仙肯出手相助，是为了西游的战略——唐僧取经。并且，孙悟空的加入，本身也是唐僧为了实现取经战略必须扩充的能力圈。</p><p><strong>资源结构层外是第四层——角色框架层</strong></p><p>用于网站是框架，用于人世间是角色。框架就是框定每个页面需要有多少元素，它们的链接关系、调用规则分别是什么。你打开任何一个网页，你在感知层感知到的一切内容、功能，都是在这个框架内被框定的。你和一个空姐在飞机上说话，或者和一个银行职员在银行里说话，她的反馈方式很大程度是她的角色框定的。</p><p><strong>角色框架层外就是第五层，也就是最表层的感知层</strong></p><p>我们都很明白感知层，颜色、声音、嗅觉……感知层当然很重要，就好像俊男美女，修饰得体的人永远容易赢得第一好感一样。但是，如果一个设计得非常精美的网站上，找不到你要的内容，无法实现你的目标。你要解决的问题，反而在页面设计非常简陋，而且打开速度很慢的网站上搞定了。你会觉得哪个网站的用户体验更好一些呢？</p><h4 id="百度和Google之争"><a href="#百度和Google之争" class="headerlink" title="百度和Google之争"></a>百度和Google之争</h4><p>五层要素讲了一遍，我举一个咱们经常使用的产品当案例——搜索，把这五层要素再讲一次。</p><p>说到搜索，你一定非常了解百度，也有的人用Google，还有的用户用过一个古老的霸主——Yahoo。IT一般都用蓝色调，Yahoo的主色调是紫色。</p><p>如果有一个场景，用户指着Yahoo搜索的紫色按钮，说：“不好用”。他到底在说什么？“不好用”的体验到底是什么意思？他是说感知层的问题吗？是他不喜欢紫色？还是他觉得按钮的形状不好看，或者尺寸太大了，还是按钮位置不合适？还是框架层的问题，他要的搜索结果没有按照他希望的方式陈列？</p><p>你在百度上搜“顺丰快递”，搜索结果页的第一条就是顺丰单号查询框，之下依次是顺丰官网、百度贴吧的信息等。百度框架的意义就是能让用户在第二个动作得到他要的信息，绝不让用户多点一层。百度能出这样的搜索结果，是因为它的爬虫以毫秒为单位，在抓取各个网站的动态信息。它不但持续积累资源，而且还不断优化自己的资源处理能力。</p><p>Google还在中国开展业务的时候，百度做了Google没有做的动作，自己着手建设内容资源，做了百度贴吧和百度知道。百度贴吧上线的时间是2003年，那时整个中国互联网上的内容都不多。Google的算法当然比百度好，但即使Google抓遍了所有中国网站，也没有足够的内容资源。所以，当时的中国互联网搜索引擎的竞争还是资源量的竞争。百度从2003年开始做百度贴吧，2005年做百度知道，做了大量资源建设的工作。而以Google的清高和耿直，不会做这样的事。当有用户有需求的时候，Google还会为百度导流量，给对手送弹药。</p><p><strong>为什么移动场景的搜索竞争百度会输呢？</strong></p><p>因为在移动场景下，微信干了当年和百度一样的事。微信用公众号的方式，自己培育内容资源。现在你在百度上搜微信公众号的内容，几乎是搜不到的。最新的内容都在微信里了，百度进入移动场景，却没有新内容可供搜索，这是在资源层出了问题。这也是今日头条为什么必须花大力气建设内容的原因，这是资源层的比拼。</p><p><strong>资源层再往下是能力圈。</strong>百度当然建设了符合中国市场特色的能力圈，而Google没有。就中国市场而言，论能力圈，百度赢；论资源层，百度赢。所以，你不能说Google退出了中国之后，才给了百度发展的机会。当然如果Google没有退出，两家竞争，那么百度肯定会比今天更健康。</p><p><strong>Yahoo为什么输给Google</strong></p><p>为什么前面提了一下Yahoo呢？百度贴吧之父俞军给我讲了个故事。</p><p>2004年，一批华尔街精英做了搜索引擎的对比评测，评测结果是Yahoo最好。但奇怪的是，评测完之后，大家平时还是都用Google。为什么大家心口不一？俞军发现，这批华尔街精英的测试方法是选了十几个关键词，在Google、Yahoo等六七个搜索引擎中搜索，打印出所有搜索结果页放在一起对比。每人拿一把硬币，认为哪个搜索结果页更好就投一个硬币，最后Yahoo获胜。为什么Yahoo会胜出？因为当时Yahoo使用的后台搜索引擎也是Google的，但Yahoo对一些热门关键词做了人工优化，它的搜索结果不是跟Google一样，就是优于Google。但是在界面呈现上，Yahoo显示的分辨率很大，banner广告很大，设计很宽松，只看到一两条结果。而浏览Google的搜索结果页，第一屏能多看几十条结果。那些金融精英在工作中还是希望能看到更多内容，虽然Yahoo的内容更好，但宁可一下子多看三四十条。在资源一致的情况下，Yahoo在表层的框架层就输了。三个搜索引擎，感知层差别不大，用户体验的差别其实是分别在框架层、资源层和能力圈层。所以，当一个用户向你抱怨，用户体验不够好，他到底指向的是哪个层的问题？比如一个电商的App，用户说不好用，是前端交互流程的问题，还是供应链的问题，还是他根本就不是你定位的用户？</p><h4 id="看人的五层要素"><a href="#看人的五层要素" class="headerlink" title="看人的五层要素"></a>看人的五层要素</h4><p>做产品如此，看人也是一样。</p><p>开篇结婚教练的案例里讲到：最表层，你接触的都是一个人的仪表谈吐。接着你会发现，一个人的仪表、谈吐、交互方式与他的角色非常相关。如果是浅层关系，了解一个人的角色就够了。但如果你希望与一个人建立的是深度关系、长期关系、战略关系，那么你需要更深地了解一个人角色之内的另外三层：</p><ul><li><p>他的内心是什么？什么是他想要的存在感？</p></li><li><p>他为了自己的存在感，一直在怎样积蓄、打造他的能力圈？</p></li><li><p>他在怎样积累和建设自己的资源，才会拥有今天的角色？</p></li></ul><p>谈恋爱、看人和买产品是一样的，关注的是最表层的用户体验。结婚和股权投资类似，最内的三层更为关键：<strong>一个人对自己存在的自我设定、能力圈建设、资源建设</strong>。所以，我们历数伟人，孙中山、乔布斯等等，你真实地跟他打交道，会发现他们问题太大了。但是他们自我的存在战略，是绝对的、伟大的、独一无二的。当你被一个人感知层的瑕疵折磨，为此怀疑、痛苦的时候，你有没有认真去评估，他天赐一般无可替代的战略存在价值呢？以及你爱不爱他这一点？这就是对一个人做判断时的芝麻与西瓜。</p><p>当然，我有一个完全相反的例子。著名女作家三毛的丈夫荷西对三毛说自己的存在战略：“我没什么追求，不可能有个大房子，我就想有个小公寓，有个你这样的太太，下班给我煮饭。”很多女人一听这个男人这么没追求，可能瞬间就放弃了，再帅也不嫁。但是三毛在这句话中，听到了荷西的未来规划，听到了自己在这段关系中的存在感，听到了荷西对她的接纳与依赖，这就是他们婚姻或者关系的基础。你说他们在之后相处中，感知层、框架层、资源层有没有冲突？当然有，他们来自不同国家，会有沟通、文化的隔阂，生活资源的不满足。但是他们这段关系里的基础始终存在，就是<strong>彼此的存在感，互相认定与依赖。</strong></p><h4 id="本讲小结-12"><a href="#本讲小结-12" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>没有完美的产品，也没有完美的关系。</p><p>做一个产品，就是我要做一个东西，让它成为某些人生活中、工作中可以确定性依赖的存在。</p><p>看一个人，则是我知道对方想成为一个什么样的存在，我是不是认同他想要的存在感。并且站在这个人的立场，接纳这个人的瑕疵，帮助他，成就他。</p><p>乔布斯说自己要成为伟人，荷西说他没什么追求，你是不是认同他要的存在感？</p><p>回顾一下，本节课，密度有点大，概念词有五个：</p><p><strong>战略存在、能力圈、资源结构、角色框架</strong>和<strong>感知层。</strong></p><p>课后作业</p><p>1.一个产品的体验有五层，你能不能说一下，你现在正在做的产品，最核心建设的，或者你觉得做得最优秀的是哪一层？</p><p>2.你有没有处在一段深度关系中，你知道对方自我存在的设定是什么吗？你们这段关系的基础是什么？</p><p>你可以在留言区分享一下。</p><h3 id="19-怎样绘制用户体验的地图"><a href="#19-怎样绘制用户体验的地图" class="headerlink" title="19 怎样绘制用户体验的地图"></a>19 怎样绘制用户体验的地图</h3><p>这一节讲用户体验地图和用户故事。</p><p>用户体验地图就是通过画一张图，用一种讲故事的方式，从一个特定用户的角度出发，记录下他与产品或者服务进行接触、进入、互动的完整过程。</p><p>开始做产品经理的人容易犯的错误，就是用管理员的视角来规划产品。我经常看到这种全局型的产品设计图，复杂、全面、没重点，这肯定是错的。我一般会告诉这种产品经理，请按照一个用户使用的路径，把这个产品设计图再画一遍。从一开始用户怎么进入，到每一步怎么体验，最后怎么离开。这就是我们在《两套经典的用户画像》那节课里讲的，“第一只羊”怎么能够在你的“草地”上活下来，而且玩得很开心的过程。画出“第一只羊”从开始到结束的完整体验，这就是用户体验地图。</p><h4 id="怎么画用户体验地图"><a href="#怎么画用户体验地图" class="headerlink" title="怎么画用户体验地图"></a>怎么画用户体验地图</h4><ol><li><p>一个画像完整的人物角色：需要对“第一只羊”有完整地了解。</p></li><li><p>清晰描述用户的目标和预期：他为什么来到你的草地上？他要什么？比如，用户买钻孔机，但是他的目标不是拥有钻孔机，而是需要在墙上打个洞。比如吃饭，用户目标是吃饱？还是想要营造气氛？还是想获得一次交流机会？搞清楚用户的目标和预期到底是什么。</p></li><li><p>服务触点：用户从接触你的服务，到实现他的目标之间，会跟你在产品上有哪些接触，你需要在这些地方服务用户。</p></li><li><p>用户使用路径：使用路径与服务触点的关系是什么？用户在宜家逛的过程是使用路径；在宜家里向工作人员咨询，到盒子前拿免费的资料是服务触点。</p></li><li><p>用户情绪曲线：场景是要触发情绪的。在整个过程中，用户的情绪是如何变化的？把这个用户从接触你的服务开始，到达成自己的目标为止（或者放弃为止），整个流程画一个坐标图，横轴是用户的使用路径与触点；纵轴是用户情绪。这样你就可以得到一条用户在与你的服务互动过程中的情绪波动曲线了。</p></li></ol><h4 id="为什么要画用户体验地图"><a href="#为什么要画用户体验地图" class="headerlink" title="为什么要画用户体验地图"></a>为什么要画用户体验地图</h4><p>为了避免管理员视角，很多初级产品经理都是用管理员视角在设计产品，有什么产品罗列什么，而不是考虑用户要什么。你要通过用户体验地图，让自己<strong>以用户视角来思考</strong>，用户能不能一步一步实现目标，这个过程是困难还是容易？</p><p>比如，我的一个朋友闫辉做了一个中医养生类的Keep，叫一体。用视频教用户怎么做八段锦、拉筋等等。我感觉产品方向不错，但下载后却发现是产品只有一堆教学视频的罗列，有易筋经、八段锦、五禽戏等等，但我作为用户不知道应该看什么。我问闫辉说，为什么我是你的目标用户，但我没办法坚持用你的产品呢？</p><p>其实可以通过用户体验地图来分析一下：</p><ol><li><p>用户画像：</p><p>亚健康、需要自我调理的人，智能手机用户。</p></li><li><p>我的目标是什么？</p><p>我的目标是调整我的亚健康状态，我的问题是脖子疼、肩膀疼、后背疼。看着视频做动作，不是我的目标。比如，Keep会对新进入的用户提问：你的目标是减肥、塑形，还是练出马甲线？</p></li><li><p>我的触点是什么？</p><p>只有一个，看教学视频。</p></li><li><p>我的使用路径是什么？</p><p>因为我看不到自己的目标，除了自己搜索看视频，没有其他路径。</p><p>以Keep为例，有以下路径：选择减肥；选择能承受哪个负荷的运动；女生最热门的运动；1个月打造马甲线的专项等。多路径的设计，让用户更容易找到合适练习的方式。</p></li><li><p>用户情绪曲线：</p><p>在我需要的前提下打开它，首先没有看到我的目标和这些视频之间的关系。其次没有用户使用路径设计，导致我不知所措。虽然目前内容资源都有，但用户要知道该如何使用你的内容，达到自己的目标。</p></li></ol><p>刚刚讲了很多概念词，所以当产品经理进行沟通的时候，应该如何描述目标、触点和情绪曲线呢？应该用用户故事的方法。</p><h4 id="什么是用户故事"><a href="#什么是用户故事" class="headerlink" title="什么是用户故事"></a>什么是用户故事</h4><p>开放大学是英国最大的大学，它提供的是远程教育，它的网站起着两个关键作用：连接学生与大学；帮助潜在生源找到学校。</p><p>我们来看一下开放大学网站交互设计的变化。一开始，开放大学提供的课程目录是典型的数据库和目录。从学院列表开始，再进入到具体的课程介绍。这种设计的前提是，网站假设用户最想知道的内容是每个课程的详细信息介绍。这种设计其实是给大明用户用的，比如京东就是给大明用户用的，所以它的检索、产品目录很强。这种设计可以让需求明确的用户，沿着搜索、目录，找到自己要的东西。</p><p>选课的交互设计上线之后，设计人员很快发现这种方式不是最佳的。为什么？因为开放大学网站的设计人员认为他的用户是大明用户，但其实他的用户是笨笨用户。他们其实不知道自己要学什么课，更不了解详细的课程信息，他们更关注自己的梦想如何能实现。</p><p>我们来分析下，开放大学可能有以下几种用户：</p><p>一位同学烦透了他的工作，他想寻找更具挑战性的转变；</p><p>一位做会务策划工作的同学，想将这份兼职工作转化为全职，但并不知道这种转化如何实现。</p><p>有少数用户是大明，他有简单直接的目标，学习、考试、拿下一个学位或者证书。但是绝大部分人其实不太了解自己到底要学什么专业，具体要学的是什么课程，以及他们所学的知识能把他们带往何方。</p><p>有一个用户的故事是：一个叫Pritti的年长的巴基斯坦女士，曾经为了家庭而放弃了她的学业。现在，她想拿到她在年轻时错过的大学学位，所以她来开放大学选课。她刚开始的想法是，第一门课要选一门可以帮助她提高英语阅读能力的课，并能帮她恢复良好的学习习惯。于是她和她的朋友努力地查，最后选择了显然不适合她的高级语言学。</p><p>事后她跟产品经理讲她的选课思路，产品经理发现她点击每一个链接都有充分的理由，但是为什么选了不适合她的课呢？因为这个网站没有用Pritti女士能理解的语言表达，网站没有告诉他们应该如何选择。这个网站是给大明用户设计的，产品设计默认用户知道如何根据课程介绍选课，但其实大量来选课的人是笨笨用户，他们不知道自己要什么。</p><p>从这个故事开始，开放大学决定在学生选课之前，先向他们展示其他人上这门课的目的，把一系列用户故事放在网站的课程介绍上。比如茫然的年轻人，通过学习成功转行的故事；Pritti这种年纪比较大的人，重拾学业的故事。其中有一个人通过学习取得了法学硕士学位的故事，开放大学网站是这样描述的：“我花了整整六年的努力学习，每周超过16小时的学习时间，牺牲看电视的美好时光，然而这一切的付出绝对是值得的。我空出星期天的时间来放松，与家人相处，但是我每天晚上和周六都预留出来用于学习，以保证学习进度。这意味着为了保证学习进度我必须要工作到凌晨一点，不过这6年我坚持做到了。”下面页面上展示的，就是他的课程安排。</p><p>对于笨笨这类用户，他们先看了与自己相似的人生故事，知道了对方的困惑和付出，再看这些人选了什么课，花了多长时间完成这些课程，是不是更有感觉？</p><p>开放大学做了什么改变？从一开始，假定用户为大明用户，他们知道所有学院、课程的意义，提供干巴巴的课程信息；转化为了提供给笨笨用户可以理解的场景故事。在此之后，开放大学的宣传从“我们有什么老师和课程”，变成了“我们有什么用户”、“用户故事是什么”。这就像淘宝早期传播淘宝卖家的传奇故事一样，故事更容易在淘宝的卖家中传播。</p><p>回到我们说的用户画像中的“第一只羊”，我们刚才举例的那个大妈，Pritti，就是开放大学新版的“第一只羊”，一只笨笨羊。她自己选课的结果是选了最不合适的课程，如果真的开始学，她一定坚持不下来，这就是羊不适应，死掉了。如果我们只关注数据，而不关注用户故事，那么我们很容易做出的决策是导更多的羊进来。这批被导进来的用户肯定会有问题。如果压力过大，有人就会诡辩数字形成的原因，甚至还会对数据作弊。这就是不关心用户故事，只关心数据转化率的结果。</p><h4 id="腾讯讲用户故事的原因"><a href="#腾讯讲用户故事的原因" class="headerlink" title="腾讯讲用户故事的原因"></a>腾讯讲用户故事的原因</h4><p>我在腾讯工作的几年，每次在做工作汇报的时候，大家很少谈论数据。</p><p>我们有时间坐到一起的时候，反而会花大量时间谈感觉，谈细节体验，谈不同场景的可能性，谈不同人群模式的不同体验。这也是我在第一个模块谈的内容。几年之后，我发现故事比数据重要。因为数据是水管里流的水，是一个常态，是一个结果。用户研究，重要的不是零散地收集数据，拿数据证明自己的对错，而是建立一个有代表性的故事。</p><p>再举个简单的例子，一个女孩与一个男孩相亲，简单地收集数据的做法是问“你有多少存款啊？你有房吗？有车吗？月薪多少啊？“但这些数据只能代表这个人，作为当下这个“点”的截面特性，你能根据这些数据做决策吗？你知道这个人经历了什么，才成为今天的样子吗？每个人对这些数据的解读，肯定是不一样的，而且各有各的道理，各有各的逻辑。大家拿着数据和逻辑PK，其实很难有说服力。</p><p>为什么腾讯内部不讲数据而要讲用户故事？因为老板要观察是<strong>你对用户的感觉有多强，你跟用户的关系有多好。</strong></p><p>说到关系，量子物理中有个定义很有趣，<strong>关系＝信息</strong>。如何判断你跟一个人关系好不好，无非就是你知道多少他的信息，以及他的最新动态信息会有多少跟你同步。你掌握的信息越多，说明你们的关系越好。你对你的经典用户故事是否足够了解，足够深入，足够完整，足够洞察，是判断你跟你的用户关系的标准。开放大学的产品经理，没有把Pritti大妈当做一个选课失败的数据，而是真正了解了她的完整故事。所以一个好产品是从“第一只羊”被真正被满足开始的。我们充分认识这“第一只羊”，能够完全用他的语言说话，你需要了解他的故事。</p><p>一个好产品，是从一个好故事开始的。</p><h4 id="本讲小结-13"><a href="#本讲小结-13" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结一下，我们谈了一个概念叫<strong>用户体验地图</strong>和两个核心观点。</p><p>第一个观点：<strong>故事比数据更重要。</strong></p><p>第二个观点：<strong>一个好产品，从一个好故事开始。</strong></p><p>课后作业</p><p>这堂课最后，再留一个作业：</p><p>说一说你最近的一次产品体验，有没有哪个产品的用户体验地图做得特别好，让你的情绪在每个环节都得到了呼应？</p><h3 id="20-服务蓝图的要素终值，峰值"><a href="#20-服务蓝图的要素终值，峰值" class="headerlink" title="20 服务蓝图的要素终值，峰值"></a>20 服务蓝图的要素终值，峰值</h3><p>上一节课我们讲了用户体验地图。这节课我们讲和用户体验地图对应的另外一张图——<strong>服务设计蓝图</strong>，以及服务设计蓝图的两个核心概念——<strong>峰值</strong>和<strong>终值</strong>。</p><p>第四模块的第一节课，我们谈了用户对产品的体验，其实是从五个层次来谈的，存在战略、能力圈、资源结构、角色框架和感知层。CEO最核心的工作就是定义战略和建设能力圈。用户体验地图的价值让你真切地站在用户视角，来看自己的产品是不是满足了用户的目标。服务设计蓝图是为了解决资源结构和角色框架的问题。</p><h4 id="如何配置资源结构和角色框架"><a href="#如何配置资源结构和角色框架" class="headerlink" title="如何配置资源结构和角色框架"></a>如何配置资源结构和角色框架</h4><p>在上一课，我们说过健身应用里Keep的产品做得很好。健身这件事，用Keep和请私教都可以帮助用户达到目标，但是这两种方式的用户体验是不同的，成本当然也不一样。我很多朋友请私教的是因为人性的懒惰。私教可以通过打电话、发短信等方式，把他拉回健身房。很多动作的训练，如果不是教练监督，自己真的很难完成。教练的介入，对于控制情绪曲线，完成训练任务，有非常大的作用。你作为商家，选择提供Keep这类服务还是私教这类服务，所对应要求你拥有的系统能力、需要设置的资源结构和角色框架都是千差万别的。</p><p>这节课我们要谈的服务设计蓝图，就是介绍如何配置资源结构，以及如何在每个用户触达点上来设置角色框架。用户体验地图是讲“第一只羊”怎么在咱们设计的“草地”上玩得开心，具体在哪个点爽，哪个点不爽；服务蓝图则是站在服务提供者的立场，怎么在总体成本控制的范畴内，给这只羊核心体验，并且保证服务不崩溃。简单说，<strong>用户体验地图是以用户情绪为中心的，而服务蓝图则是以服务流程为中心的。</strong></p><p>没有任何一家公司的服务，能够完成用户所有的期待。如果每一个点都达到甚至超过用户期待，甚至超过了你的资源配置，那你的资源配置一定是超级冗余，相应的成本一定会过高。</p><p><strong>服务蓝图到底要干什么</strong></p><p>服务蓝图要做<strong>一眼、一条路、三个点</strong>。</p><p>一眼是什么？就是产品要第一时间<strong>让用户“一眼”看到自己的目标</strong>。比如，Keep会问用户，你的目标是什么？减脂、增肌还是塑形？健身本身不是目标。</p><p>一条路是什么？就是<strong>产品要有一个清晰的路径</strong>，让用户能够知道如何使用你的服务，用来达到或者接近自己的目标。用户无法走下去，就是服务流程的崩溃点。比如，我打开我朋友设计的一体App，看了一堆视频，却不知道该跟着哪个视频做多长时间可以缓解我的后背疼痛，最后我什么都没选，关掉了App，这就是一个服务崩溃点。</p><p>三个点是什么？<strong>峰值，终值和忍耐底线</strong>。</p><p>先说忍耐底线。比如，吃饭时每个桌子配一个服务员，用户体验当然非常棒，然而对于餐馆来说代价是成本过高。那么多少张桌子配一个服务员合适呢？这就需要找到用户的忍耐底线在哪里。PC时代用户等待一个页面打开的忍耐底线平均数是7秒，等了7秒还没打开，基本上99%的用户就会离开。所以，对成本的控制是本分，但是不能挑战用户的忍耐底线。</p><p>峰值和终值，是由2002诺贝尔奖得主、心理学家丹尼尔·卡尼曼提出的。他发现大家对体验的记忆由两个核心因素决定：</p><p>第一个是体验最高峰的时候，无论是正向的最高峰还是负向的最高峰，一定是能记得住的。</p><p>第二个是结束时的感觉。</p><p>这就是<strong>峰终定律</strong>（<strong>Peak-EndRule</strong>）。体验一个事物或产品之后，所能记住的就只有在峰值与终值时的体验，而整个过程中每个点好与不好，时间长短，对记忆或者感受都没那么大影响。</p><p>比如，大家都喜欢宜家，但宜家也有很多用户体验不好的地方。比如只买一件家具也需要按照路线图走完整个商场；比如宜家店员很少，因此要自己在货架上找货物并且搬下来等等。但是，宜家对顾客的“峰终值”的设置非常好。</p><p><strong>宜家的服务设计蓝图</strong></p><p>峰值是产品试用，如果拆得再详细点，就是坐在宜家样板间的沙发上，或者躺在样板间的床上，体验宜家所营造的小空间。<strong>样板间体验就是宜家服务蓝图的峰值设计。终值就是出口处**</strong>1<strong>**块钱的冰淇淋。</strong>所以我们可以发现身边有不少朋友开心地逛了一天宜家，最后什么也没有买，仅仅在3层喝了一杯会员免费的咖啡就回来了。大多数人的</p><p>心情或者对宜家评价都是不错的，因为他体验了宜家的峰值。</p><p>在迪士尼，峰值一定是某个刺激游戏。终值是累了一天，晚上坐在地上看花车游行和园区上空的烟火秀，大家一边休息，一边仰着头说：“好美啊”。所有的体验过程，肯定都会有各种小bug，但是峰值和终值好，你的回忆便是好的。</p><h4 id="为什么要讲体验的峰值和终值？"><a href="#为什么要讲体验的峰值和终值？" class="headerlink" title="为什么要讲体验的峰值和终值？"></a>为什么要讲体验的峰值和终值？</h4><p>因为<strong>平庸的用户体验无法成就你</strong>。设计服务蓝图核心就是让你在资源有限的情况下，配置你的资源，在关节点上安排角色，保证整体服务路径不崩溃，尽量不压到用户的忍耐底线。然后尽量集中资源，打造体验的峰值，最后再做一个体验终值的美好小尾巴。</p><p><strong>亚朵酒店的服务节点</strong></p><p>再讲一个例子，最近几年比较新锐的亚朵酒店。亚朵的定位是一个中高端的品牌。之前中国酒店都集中在经济连锁品牌或者五星酒店品牌的范畴，中端市场会有空白就是因为有难度。亚朵做了什么事情能在令人觉得有难度的中高端市场建立自己的品牌？</p><p>这里，我先讲亚朵如何设计服务蓝图和峰终体验的，在第五模块，我会再讲它的创新模式。亚朵酒店在设计服务蓝图的时候，是从客人第一次入住亚朵，到他再次入住亚朵的整个过程，中间有十二次端口，也就是亚朵服务的<strong>十二个节点</strong>：</p><p>​    第一个节点，预定；</p><p>​    第二个节点，走进大堂的第一面；</p><p>​    第三个节点，到房间的第一眼；</p><p>​    第四个节点，跟你联系，向酒店提供服务咨询的第一刻；</p><p>​    第五个节点，吃早餐的那一刻；</p><p>​    第六个节点，你在酒店等人或者等车，需要有个地方呆一下的那一刻；</p><p>​    第七个节点，你中午或者晚上想吃夜宵的那一刻；</p><p>​    第八个节点，你离店的那一刻；</p><p>​    第九个节点，离店之后，你点评的那一刻；</p><p>​    第十个节点，第二次想起亚朵的那一刻；</p><p>​    第十一个节点，你要跟朋友推广和介绍那一刻；</p><p>​    第十二个节点，还有你第二次再预订的那一刻。</p><p>亚朵的这十二个节点都不一样，资源配置与角色工作，都是基于这十二个节点。在亚朵入住的时候，有三项服务是为了加强第二个节点的体验强度。比如百分百奉茶，到了亚朵，先给你一杯茶；三分钟办理入住；有时候再做一个“免费升舱”，给用户惊喜。你在亚朵的终值体验是退房的时候，这时服务人员会给你一瓶矿泉水，如果是冬天就会给一瓶温热的矿泉水。亚朵给每个服务都起了个文绉绉的名字，比如临走时给你的这瓶水叫“别友甘泉”之类的。这会给当时用户有概念体验和印象留存，对用户来讲，这就够了。刚才说了亚朵服务蓝图的十二个节点，在这十二个节点配置资源的时候，亚朵采取了“与其更好，不如不同”的策略。你入住酒店时，一推门第一眼看到的是大堂。一般四星酒店装修大堂会花非常多的钱，而亚朵并没有在大堂大理石等地方上多花钱，因为花再多钱也不如五星级酒店。亚朵更愿意做一个有温度可体验的小空间，它会在大堂设一个图书馆，可以在那里看书、喝咖啡，也可以把书拿回房间看。这就是“与其更好，不如不同”。出差的人核心需求就是睡个好觉，床的体验好，对出差的人很关键。亚朵宁愿在床、床垫、枕头上花更多的钱，选更好的品质，降低地毯这类开支成本。这就是一个用户体验地图和服务蓝图的对接过程。<strong>在用户有预设的地方，不要太让用户失望。在用户没有预设的地方，给他惊喜，制造峰值。</strong>所以，亚朵每个房间的平均成本控制得很好，而且做到口碑不错。</p><h4 id="本讲小结-14"><a href="#本讲小结-14" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>我们有了用户视角的用户体验地图概念之后，需要对应做服务蓝图，来安排我们的资源，以及配置每个接触点的角色，用来完成服务。但是企业的资源是有限的，你不可能在所有点都达到用户预期。所以，你需要做的是，在服务蓝图上配置你的资源来制造用户体验，使用户拥有一个美好的峰值和令人回味的终值，并且全程不突破用户的底线。</p><p>课后作业</p><p>这堂课留一个有趣的作业：</p><p>请你按照峰终理论，设计一次约会的峰值和终值。</p><p>如果设计一场你和男朋友／女朋友的约会，你会设计一个什么样的环节，让你对方惊喜万分或者感动？约会结束时，你会设计一个什么结尾，让对方印象深刻？把自己当成导演和恋爱达人，开始设计吧。</p><p>我会挑出在体验设计上最特别的五位，送一份小礼物。</p><h3 id="21-上瘾机制：用户激励系统"><a href="#21-上瘾机制：用户激励系统" class="headerlink" title="21 上瘾机制：用户激励系统"></a>21 上瘾机制：用户激励系统</h3><p>在《来自星星的你》中，全智贤饰演的女主角千颂伊，回答记者为什么会有人喜欢自己，她说：“漂亮就行。”一时被奉为金句，成为所有卖口红、卖面膜的微商的重要依据。</p><p>产品的用户体验，视觉当然是感知层里非常重要的部分。我发现我在“黑”感知层，其实不是的，而是说除了感知层之外，其他许多工作也非常重要。比如，中国有4000个手机游戏团队，一年出1万款游戏，但是能挣钱的只有几十个而已。最后赢的并不一定是美术水平最高的那个，就好像我们最念念不忘的人，不一定是容颜最美的那个。以我的观察，我发现最火的游戏是最懂得激励用户的游戏。你内心难以忘记的人，是那个最长时间激励过你，改变你人生轨迹的人。进入本次课程的重点概念——用户激励。</p><h4 id="什么是激励"><a href="#什么是激励" class="headerlink" title="什么是激励"></a>什么是激励</h4><p>回到我们第一模块谈的生物性情绪，满足了就会感到愉悦。如果满足被阻隔，得不到满足就会难受、不爽、痛苦、不安。所以怎么激励？很简单，就是完成预定动作，给他满足。并且让他清楚，完成预定动作，就能得到满足。这就是激励。海豚顶一下球，给一条鱼吃，就是激励。</p><p>首先，在游戏的体系内，它会拉动你的需求，进而给你满足，让你爽。比如，你玩俄罗斯方块，垒了好高，一直缺一个长条的，可以用来一下子消除四排。你内心的压力就会越来越强，会在内心一直喊：“来个长条、来个长条”。这时突然间，长条来了，一下消了四排，当即画面空旷，一串加分数字。内心觉得很满足、很爽。你知道会有这种爽点，但是不确定出现在哪里。但是游戏也会给你确定性的激励。比如打超级玛丽，吃到一个蘑菇加一条命，伴随着熟悉的“叮”的一声，一个“+1”的符号飘起来，内心当即就很满足，这就是激励。</p><p>不确定的爽点与确定的爽点合在一起，就是用户的体验地图情绪曲线。制作游戏能力的高低，其实就是对用户情绪曲线把握的能力。而游戏的设计，一个非常重要的部分，就是用户的激励机制。游戏是最顶级的社区，游戏之外的所有社区类产品，或需要用户活跃度的产品，都需要把用户激励机制作为非常重要的产品机制。如果你设计一个产品，而没有激励机制，那么产品是不完整的。</p><h4 id="怎么激励用户"><a href="#怎么激励用户" class="headerlink" title="怎么激励用户"></a>怎么激励用户</h4><p>怎么激励用户，怎么激励一个人，其实是一件需要花细腻心思的事。</p><p>李学凌说，游戏中打中一架飞机，视觉做得好的游戏，会给你个很炫的效果，例如击中的声音、火花效果、爆炸的声音、视觉、加分的声音等，所有的细节都让人爽。但如果资源不够，或许做不了那么多的效果，但打中一架飞机，会看到飞机消失了，并且有一个回馈的声音，接着分被加上了。这样一来，如果你的整体游戏激励机制够好，用户依然会喜欢玩。游戏的动力，就是压力感突然被满足，压力释放的爽感、确定性的获得、激励的满足感合在一起，让一个人成瘾，停不下来。不过在游戏中，所有的资源都是虚拟的。只要系统平衡性做好，玩家只要完成动作，就会被激励，这是极其确定的事情。</p><p>现实生活，每完成一个动作，就要给他激励吗？举个例子，员工一项工作完成得很好，老板很高兴，特别做了激励，发100元红包。那么下次，这个员工又完成得不错，还特别给激励吗？那是不是如果一直做特别激励，突然不激励了，员工会不会非常失落？会的。</p><p>举个运营的例子，一个健身App，一直为完成计划并上传的达人发一分到一块钱的小红包做激励。人们健身不断感觉到自己体能和身材在改善，本身是有快感的。大家是为了这种内在激励而坚持健身，App发红包是激励的迭加。但是App自停止发红包开始，用户数据当即大幅下滑，用户研究表明，用户感觉被伤害了。</p><p>其实，停止发红包，对健身本身的快感是没有影响的。发红包明明是做加法，为什么用户却觉得自己被伤害了呢？</p><p>因为这伤害了用户预期，损害了他对确定性的感受。要知道人是非常依赖确定性的动物。确定，就是依赖；不确定，就是伤害。一个确定性的丧失，不论大小，都是非常难受的。所以，所有的改版、新包装、重新装修，都是需要非常慎重的。</p><h4 id="内在激励与外在激励"><a href="#内在激励与外在激励" class="headerlink" title="内在激励与外在激励"></a>内在激励与外在激励</h4><p>刚才我们谈了一个词——内在激励。外在激励和内在激励，是两个心理学的名词。驱使人的行为发生改变的外部因素，比如获得类似奖金、名誉等奖励，这是外在激励。而驱使一个人内心获得饥渴感、满足感、愉悦感的内部因素，就是内在激励。所以，当你要激励一个人的时候，要想想，对这件事真正起作用的是内在激励，还是外在激励。你应该重点依靠哪条线？重点设计哪条线？外在激励还是内在激励？内在激励，是让人能够找到感觉，持续深入，把事情做到位的方式。</p><p>腾讯的联合创始人张志东就专门讲过，腾讯一直非常小心地保持着让员工出于自我满足的愉悦感来做事情。为此腾讯做了大量的组织设置，来保障员工的自我感受。外在激励，则是非常强有力的短期改变用户行为的工具。打车软件的补贴大战，最好地说明了这一点。所以你想清楚，你是要用外部激励，还是要内部激励来做你的激励体系。这个时候你就可以开始设计它，并且不断优化了。</p><p>接着就是设计并不断优化你的激励系统了，激励系统的两个要素是“受激励点”和“被激励能力”。如果你要为一个人或一群人完成某个动作，或者强化某个动作，设计激励系统。那么，首先要做的是测绘用户的受激励点，就是用户会在多少个点上被激励。比如游戏，用户激励的点位，就是用户的成就体系。《王者荣耀》每次越塔强杀的感觉，每次拿到MVP的感觉，每次拿到超神的感觉，好不容易拿到个五杀什么感觉？那就是满满的成就感。勋章、小红花、奖状、奖杯、腰带，这些玩意实际上是成就象征，它们本身是虚拟物品，没有意义，但是它们代表的是人们历经千辛万苦，突破重重挑战后的成就感！</p><p>比如，我觉得Keep的成就体系还可以做得再好一点。因为练出马甲线，还是少数人可以实现的成就，而大量的人是没有成就的。这个过程中，人们如何在Keep里找到成就感，而不是中途崩溃，这是可以优化的。</p><p>公司奖励员工也是如此，不能憋大招到年底再给某个员工发个大奖。受激励点少，最后一招再大，也很难发挥作用。</p><p>刚才说的都是外在激励。我想说说内在激励，谈一谈腾讯管理的内在激励方式。</p><p>腾讯发奖金还是很大方的，这是外在激励。在腾讯公司，公司的日常氛围中，运营出的产品至上、用户体验至上的企业文化，腾讯上至高管下至员工的QQ空间、朋友圈，大家在分享的内容都是各种产品的优化细节。例如，这个按钮从闪一闪改成摇一摇，再变成摇摆15度，这样看起来会比较Q。通过一点点的优化细节，所有人都在讨论，这就是企业文化，可以影响一个人的内在激励。</p><p>你发表了一个你优化产品的小细节，一堆朋友、领导都来给你点赞。虽然这个时候没有奖金，但会形成你内心的满足感。只要你发产品优化的信息，就会有人给你大规模点赞，这也是一种确定性的满足，会让你把这个动作强化。</p><p>你想在腾讯内部刷存在感，你就得在QQ空间、朋友圈里发产品如何优化的，进而就会让一个在腾讯工作的产品经理，天天琢磨怎么优化。一个人的内在激励，不单是自己原生，还来自外部环境的激发、挤压和认同。</p><p>激励系统的第二个设计——定义获得能力并努力降低门槛。</p><p>比如，你要激励你家小孩去骑自行车，但是如果他不会骑自行车，或者他没有自行车的话，再多的激励也无法被转化为行动。激励与对方的能力不匹配的事情，就是无效激励。这种事还是很多的。新创业公司总是发展很快，需要不断有人去做新的事情。这时要非常小心，如果员工能力不匹配，而自己的意愿也不强，老板却一厢情愿地觉得给了老员工一个机会，要让他突破自己，让他试试，这其实是给自己挖坑。因为赶鸭子上架这件事，做不得。</p><h4 id="《王者荣耀》如何降低激励门槛"><a href="#《王者荣耀》如何降低激励门槛" class="headerlink" title="《王者荣耀》如何降低激励门槛"></a>《王者荣耀》如何降低激励门槛</h4><p>关于降低激励门槛，《王者荣耀》依然是个好例子。</p><p>1.两根手指就可以玩，一共就三个技能键。操作简单易上手，基本上是《王者荣耀》获得最多的评论了。对于玩过DOTA、LOL等塔防类游戏的玩家，玩《王者荣耀》会很轻松。</p><p>2.此外，《王者荣耀》对时间的要求低，6分钟就可以打一局。坐地铁、上下班路上、午休吃饭、上卫生间等，随时随地开黑。</p><p>3.同时对设备的要求不高，不管你是iPhone还是安卓，都可以在同一个大区一起玩。</p><p>4.每日任务。你不知道该怎么玩？没关系，每天上来做任务就行了，小到“每日登录”，大到“击败对方10个英雄并取得胜利”，不要让用户思考，用户不需要想他需要干什么，只需要每天打开把任务发给他。只要完成任务就送经验、活跃度、送某英雄的体验等一堆东西。</p><p>这一系列动作是什么呢？就是降低门槛，降低门槛，再降低门槛。降低动作门槛，设备门槛，思考门槛，降低时间门槛。这意味着什么呢？首先，大量的女孩开始玩了。《王者荣耀》女性玩家占比是多少？第三方的统计数据——54%。《王者荣耀》有两亿用户，超过一亿是妹子。有一亿妹子在围观，对男性玩家就是激励。</p><p>我们刚才讲了，用户内在激励，除了自己内心原生的，更多来自于外部环境的挤压、激发和认同。《王者荣耀》因为大量女用户进入、围观、激发，让男用户之间的挤压更强烈，用户的内在激励变得更强。所以如果你设计的激励系统就靠你自己发奖金，这种单点、单向的激励能力是极其有限的。比如腾讯这家公司，比如《王者荣耀》这个游戏，更强的激励是营造了一个场，让用户彼此挤压，彼此激励。</p><h4 id="本讲小结-15"><a href="#本讲小结-15" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>首先，人会上瘾，是对确定性满足感的依赖。</p><p>其实，上瘾机制的设计，就是对用户激励机制的设计。</p><p>激励用户，你需要考虑如何用外在激励和内在激励来交替地持续激励他。设计你的激励系统，设置一系列用户的受激励点给用户成就感，定义他的获得能力，并降低门槛。</p><p>课后作业</p><p>这节课的最后，我们还是通过作业互动一下。</p><p>1.我们讲了成瘾的这个机制，你自己有没有上瘾的东西？</p><p>2.游戏是怎么回事，我们都了解。除了游戏，比如说有人吸猫、吸狗成瘾，举个例子来分析一下这是为什么？</p><h3 id="22-名字是你的文化资产"><a href="#22-名字是你的文化资产" class="headerlink" title="22 名字是你的文化资产"></a>22 名字是你的文化资产</h3><p>这是用户体验模块的最后一课——名字与口碑。</p><p>为产品设计名字、口碑与社交货币，应该算是产品、营销，还是运营的工作呢？不同公司也许有不同分工。</p><p>但是从我自己的角度来讲，为产品起名字，绝对是做产品最重要也是最快乐的事情之一。</p><h4 id="名字是召唤"><a href="#名字是召唤" class="headerlink" title="名字是召唤"></a>名字是召唤</h4><p>名字是什么？名字是召唤。</p><p>《说文解字》中，对名的解释是：“名，自命也。从口夕，夕者，冥也，冥不相见，故以口自名。”意思是说，在早期的社会交往中，原始社会一个部落人不多，人人都互相认识，白天可以通过形体、面貌相互识别，而到了晚上相互看不见，就只能通过呼唤名字才能召唤一个人了。所以名字是用来叫的，不是用来看的。很多演员的名字，别人一看不会念，这人就红不了。你希望成为一个被人口口相传的人，就别起这种大家不会念的名字。所以当大家还没有接触你或者你的产品之前，他已经接触了你的名字，你的名字是先于你给到用户的体验。</p><p>名字是什么？</p><p>阴阳师安倍晴明说：“名字是最短的咒。”咒就是束缚。</p><p>《道德经》说：“无名万物之始，有名万物之母。”</p><p>像我这种对神秘事物怀有强烈好奇心和探究欲的人，对这两句话的理解是：名字是连接人和世界的渠道。我们的祖先发明语言文字的过程，就是一个给万事万物命名的过程。这个命名的过程，也是我们的祖先认知这个世界的过程。罗胖第一次跨年演讲谈新物种的时候说，“新事物出现，人们对它指指点点”。为什么只能指指点点？因为没有名字。有一种推论是，我们的祖先每认识一样新事物，就会依据它外部形态、用途来做出判断，并且固化一个符号代表它，这就是早期的象形文字，这是个很伟大的过程。</p><p>《淮南子》里说：“昔，仓颉作书，天雨粟，夜鬼哭。”天雨粟，有了名字，自然开始为我所用，从此我们可以利用自然。鬼是什么？鬼是未知，你无法描述它，只有混沌的无边想象，所以可怕。一旦你命名了它，抓住它的特征，描述了它，那你就掌握了与它连接的方式。人不怕鬼了，鬼就哭了。如果简单理解，这就是为什么名是最短的咒。你抓住它的特征，就可以与它发生连接。</p><p><strong>名字是召唤世界的咒语</strong></p><p>我曾经写过一篇文章《主观世界的破碎和重建》，讲过一些主观世界和客观世界的分别。天地万物当然属于客观世界，名字属于主观世界还是客观世界呢？当然是主观世界。名字是主观的，因此它有情感温度，有文化偏见，有文化资产。一个强大的名字是带有强烈情感的，对我们有咒语般的作用。比如，你听到一个你喜欢的人的名字，就好像中了一个微笑咒。听到一个你非常讨厌的人的名字，就好像中了一个白眼咒。所以，<strong>当你要起一个名字的时候，你要知道你是在寻找一句咒语。通过这个咒语，你和你的同伴一起召唤你的产品，把它从无到有召唤到这个世界上。</strong>就好像古人在黑茫茫的一片中，喊一个名字，就有人回应。你的所有用户都是因为这个名字，这句咒语，定义你们所有的工作，与你们发生连接。</p><p>我在给一个初中生讲物理、化学，他很不喜欢，觉得枯燥。我说主要是名字不好，如果物理改叫“大自然的秘密”，化学改叫“炼金术”，你是不是就很有兴趣了？小朋友说是啊，那为什么要叫物理、化学这么让人亲近不起来的名字呢？我说大概就是为了隔绝吧，让圈外一看就觉得难，就放弃了，这也是一种命名的意图。比如中国古代算命的书里术语很多，就是为了让你看不懂。他又问我，那语文可以叫什么？我说语文厉害啦，语文可以叫“咒语书”。我只要改改名字，就顿时让孩子对一门课的兴趣和愿望产生了变化，这就是语文的力量。</p><p>人为什么要说话？<strong>说话就是咒语</strong>。舒舒服服的，干嘛要说话？说话是为了驱动别人，驱动世界。比如，我对你说，“给我倒杯水”，你就站起来给我倒了杯水。这不和神话中驱动一块石头去做事是一样的吗？如果你不给我倒，我可以换一句咒语，比如“求求你了，我太渴了，给我倒杯水吧”，我又驱动了你。或者“给你十块钱，给我倒杯水”。用钱或者权力来做杠杆，咒语的力量就增强了。</p><h4 id="名字里的文化势能"><a href="#名字里的文化势能" class="headerlink" title="名字里的文化势能"></a>名字里的文化势能</h4><p>判断一个名字是不是有力，在于能在对方心中召唤出一种什么样的情感。</p><p>举个负面例子，丰田汽车几年前对其在中国的品牌和产品进行了全线更名：凌志改为雷克萨斯，陆地巡洋舰改为兰德酷路泽，霸道改为普拉多。我本来说“我买了个陆地巡洋舰”、“我开霸道”，是不是很有感觉？如果说“我开兰德酷路泽”，是不是完全没概念？不知道品牌公司怎么想的。</p><p>同理，麦当劳通过在中国30多年的运营，麦当劳三个汉字，已经能够在我们心中召唤出非常美好的情感了。突然改叫金拱门，丢掉了过去30多年的情感文化资产，甚至还是负分的。</p><p>阿里巴巴就是一个有文化资产的名字。念这个名字，就会想到天方夜谭的故事，一个快乐的青年，打开了宝库，成为了富翁。</p><p>百度也是一个有文化资产的名字。它们都从长久的文化情感中借了势。</p><h4 id="什么是口碑"><a href="#什么是口碑" class="headerlink" title="什么是口碑"></a>什么是口碑</h4><p>简单说了名字，我们再花一点时间谈口碑，因为它们都是你需要研究的咒语。</p><p>口碑是用户自发产生的，还是我们在做产品的时候就已经设置的呢？关于口碑，雷军和华与华创始人华杉各有一句话，都挺有意思的。雷军说：“什么是口碑？口碑就是把事情做过头。”我和一个朋友说到雷军这句话时，朋友想起了买一瓶阿芙精油的体验。买了一瓶100块钱的精油，结果收到了7件赠品。他收到包裹第一感受是一小瓶精油还寄这么大一个盒子？拆了包裹，他一件一件往外拿赠品，拿到第三件赠品的时候，他已经忍不住说：“还有？”朋友说，在淘宝买个东西有赠品，这事挺正常，买1件赠7件，这真是过头了。但<strong>真的是让人印象深刻，有一种忍不住要和人说说的感觉。</strong>这就是口碑，这里有一个<strong>净推荐值</strong>的概念。</p><p>满意与推荐是两个不同的概念。你做到100分，提供了与产品描述一致的体验，能够及时响应用户遇到的困难，完全符合用户预期。用户满意了，但是他会觉得这都是应该的、分内的、没什么可说的。用雷军的话，<strong>只有超预期把事做过头，用户才会有深刻印象，才会有口碑转化的动力，也就是要从满意变成推荐。</strong></p><p>那口碑是什么呢？</p><p>华与华创始人华杉说：“<strong>口碑叫口碑，不叫眼碑。</strong>”因为人们听说的东西，会远远大于见过的东西。所以，口号、口碑、听觉，成为了传达率的关键。你的口碑的碑文是什么，就是大家提起你的时候，那句像刻在石头上一样的话，每个人说的都是同一句，比如“怕上火就喝王老吉”。同仁堂100年重复的同一句：“<strong>炮制虽繁必不敢省人工，品味虽贵必不敢减物力。</strong>”这才叫口碑。</p><p>华杉认为“碑”本来是视觉的，口碑却成为一个符号，活在口耳之间。所以口碑一定是听觉文案，一定是一句口语，直截了当，脱口而出，不绕弯子。所以，很多产品为自己设计的slogan都是视觉文案，别人就无法口口相传。就像名字是给别人使用的一样，口碑也是替消费者设计一句他要说的话。口碑就是你把那些事情做过头，然后别人要口口相传的时候会说的话。口碑是你要替消费者说一句他要说的话，然后让他说出来。</p><h4 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h4><p>第四模块用户体验告一段落，下面总结一下：</p><p><strong>1.从甄别自己的感觉，理解他人感受开始。</strong></p><p><strong>2.我们学习价值判断，用户研究，建设系统能力。一个产品是一个系统能力的输出结果。</strong></p><p><strong>3.用户体验的要素有五个层次，就你的存在战略来规划积累自己的能力圈、资源，通过角色框架完成用户能够感知的服务。</strong></p><p><strong>4.设计用户体验的峰值和终值，不断倾听，不断优化，设置用户激励系统。</strong></p><p><strong>5.最后，给它一个名字，把它召唤出来，成为这个世界的一部分，与这个世界建立连接。</strong></p><p>到这里，怎么从无到有定义并做出一个产品就讲完了。</p><p>下节课开始，我们讲<strong>第五个模块</strong>，<strong>创新模式</strong>。</p><p>课后作业</p><p>这节课的最后，留一个作业：</p><p>1.说一个你特别喜欢的名字，你为什么喜欢？</p><p>2.这个名字会带给你一种什么样的感觉？尝试着分析一下，你为什么会有这样的感觉？</p><h3 id="模块五）-创新模式"><a href="#模块五）-创新模式" class="headerlink" title="模块五） 创新模式"></a>模块五） 创新模式</h3><h3 id="23-用“用户价值公式”衡量创新"><a href="#23-用“用户价值公式”衡量创新" class="headerlink" title="23 用“用户价值公式”衡量创新"></a>23 用“用户价值公式”衡量创新</h3><p>从这一讲开始，我们进入最后一个模块，第五模块——创新模式。</p><p>为什么要将创新模式单做一个模块？因为没有创新的产品，根本不应该去做。</p><p>我们为什么要做产品？为了帮别人、帮自己。</p><p>如果市场上已经有了同类产品，用户已经用得很好，如果你还做一样的产品，这不是为了用户，只是因为你不服或者心存侥幸。用户为什么还需要你？这个产品真的能帮助你实现自己的人生目标吗？很难。</p><p>我很佩服的产品大神俞军有个用户价值的公式，我觉得这可以很好地回答这个问题。这节课就谈谈俞军的用户价值理论，回答这个问题：为什么唯有创新一条路？</p><h4 id="在增量市场里找机会"><a href="#在增量市场里找机会" class="headerlink" title="在增量市场里找机会"></a>在增量市场里找机会</h4><p>俞军是中国的顶级产品经理之一，做了百度贴吧、百度知道等几个中国用户量最大的产品。</p><p>他对产品经理的定义是这样的：产品经理是以创造用户价值为工具，打破旧的利益平衡，建立对己方有利的新利益链，建立新平衡的过程。</p><p>他没有说做产品，而说的是创造用户价值。用户价值是一个工具，产品经理用这个工具打破旧的利益平衡，建立对己方有利的新利益链、新平衡。</p><p>所有的产品开发与使用都是一个利益链和利益平衡，就好像一条河的流动，是水追求平衡的结果。你要开一条新河，把这条河的水引到自己的河里去，就需要打破这条河旧有的水位系统。</p><p>我曾写过一篇介绍腾讯怎么运营流量的文章，叫《改变大河的流向》。<strong>互联网创业就是挖条自己的沟，抢夺别人江河里的流量，形成自己的河流与生态。</strong>QQ是一条大河，微信是一条大河，百度是一条大河，百度贴吧也是一条大河……大河所过，形成自己的生态，巩固自己的水土。大河之间，小河水也欢快地流淌。看新闻、看菜谱、做运动、听音乐、看视频、订机票、买螃蟹、聊八卦……互联网上江河纵横，8亿网民各得其所，形成了互联网的滚滚流量。</p><p><strong>如何拥有自己的河流与生态？你的水源从哪里来？</strong></p><p>地球上的水的总量是13亿8600万立方千米。这是一个固定的存量，如果你要开一条新的江河，唯有打破平衡把固定循环在某个体系中的水，引流到自己的系统中。这就是基于固定存量市场的运营争夺。</p><p>按照<strong>存量竞争</strong>的逻辑，强者为王、厚黑学、找靠山、向权力寻租、崇拜资源，这些成为了我们的成功学。</p><p>家里没什么背景，人不够狠，心也不黑，不懂办公室政治，不会抱大腿的人，在旧有的竞争模型里是没有成功的机会的。还好我们赶上了互联网代表的新经济。我有个朋友刘韧曾经说过一句话：“我们信仰互联网。”</p><h4 id="互联网不是存量竞争，而是增量竞争。"><a href="#互联网不是存量竞争，而是增量竞争。" class="headerlink" title="互联网不是存量竞争，而是增量竞争。"></a>互联网不是存量竞争，而是增量竞争。</h4><p>曾经存量里的超级大佬，在新的增量市场里可能毫无威胁。比如联想曾经风光无两，直到今天在PC制造业的存量体系里依然非常优秀，但在网络经济里完全没有竞争力，甚至不能威胁一个小创业者。</p><p>服务好你的用户，不用怕那些大佬。这就是我热爱互联网的原因。</p><p>从WPS的挑战，理解用户价值公式</p><p>俞军的用户价值公式：用户价值=(新体验-旧体验)-替换成本。</p><p>我觉得这个公式很好地解释了两个问题：</p><p>为什么在存量市场中竞争先发优势那么重要？</p><p>为什么BAT打创业者非常容易？</p><p>按照俞军的用户价值公式，你要撬动一个用户，依靠的工具是用户价值。那用户能得到的用户价值是什么呢？用户价值=(新体验-旧体验)-替换成本。用这个公式可以解释一下为什么雷军英雄盖世，但当年他带领金山的WPS打微软那么艰难。如果微软Office软件用户使用体验是90分，价格体验50分，两项相乘，微软Office软件带给用户的旧体验算45分。金山WPS软件用户使用体验70分，价格体验90分，两项相乘，金山WPS软件带给用户的新体验算63分。</p><p>用户的替换成本包括什么？品牌认知、获取成本、学习成本、使用成本，包括使用过程中遇到问题得到及时帮助的便利程度等。比尔·盖茨曾经是世界首富，微软公司的品牌、渠道、产品成熟度、客服服务系统都很成熟。网上还有随处可见的用户分享、使用小技巧。所以用户体验非常成熟，用户替换成本很高，我们算用户的替换成本是20分。用户价值＝WPS新体验63分-Office旧体验45分-用户替换成本20分＝-2分。雷军带领他的英雄团队做了一个综合体验很好的产品，但是用户几乎没有得到价值。你认为别人为用户提供了45分的东西，而你为用户提供了63分的东西，你比对手提升了40%的用户价值。可是，你别忘了用户替换是有成本的。真实情况是你付出63分，而用户得到的是-2分。你认为你做得更好，但用户视你为鸡肋。</p><h4 id="创新是小企业唯一的活路"><a href="#创新是小企业唯一的活路" class="headerlink" title="创新是小企业唯一的活路"></a>创新是小企业唯一的活路</h4><p>这是我们的血泪教训，同维度竞争，先发优势是很高的门槛。</p><p>很多朋友，包括雷军和我自己都曾经非常自负，觉得某个产品做得一般，自己可以做得比对方好，于是就杀进去。</p><p>小企业对大企业就得仰攻，那么用户替换成本极高。小企业提供的局部优化，加上用户替换成本可以忽略不计。<strong>如果没有奇招，用同样的产品，小企业仰攻大企业基本上没有赢的机会。</strong></p><p>那为什么BAT打创业企业极其容易呢？同维度竞争，体量大占优，即使它后发。从替换成本开始说，用户替换为BAT的成本几乎为零。替换成本包括哪些？用户体验、品牌认知、渠道方便、学习成本。</p><p>BAT的产品用户体验都不错；</p><p>品牌认知成本为零；</p><p>渠道畅通，用户获得成本几乎为零；</p><p>你已经把用户教育好了，用户切换成BAT产品的学习成本为零。</p><p>市面上有很多音乐软件都做得不错，腾讯出个QQ音乐，功能的使用体验完全一样。腾讯渠道强大，大家很容易知道和安装QQ音乐。腾讯使用资金资源能力，垄断版权，热门音乐“搜得到，能下载”就是核心体验。于是，音乐App就QQ音乐一家独大了。</p><p>这就是BAT的典型打法，因为用户迁移成本极低，用大公司的体量优势，一点一点地优化用户体验，一点一点地挤压你、蚕食你。一个产品，你明明可以做得更好，别人先做了，你可以比原来的产品优化20%～40％的体验，怎么办？看体量，如果对方体量远大于你，就放弃。我们得出的血泪教训——<strong>同维度竞争，体量第一</strong>。就像是两个人拼拳脚，大个子打小个子。</p><p>如果几个竞争者体量差不多呢？那就是红海战争，会有一场漫长的拉锯战。只有两种方式能终结这种同维度乱战：要么有能降维攻击的企业出现，要么是资本意志强行合并。曾经的杀毒市场，千团大战、打车大战、外卖大战，莫不如此。小企业、创业者还有什么机会呢？<strong>小企业唯一的活路就是创新</strong>。小企业想改变宿命，飞跃龙门，唯一的路就是离开存量市场，寻找增量市场。</p><h4 id="傅盛找到新机会"><a href="#傅盛找到新机会" class="headerlink" title="傅盛找到新机会"></a>傅盛找到新机会</h4><p>我再讲一个，创业公司离开存量市场，在增量市场找机会的故事——猎豹CEO傅盛的故事。我为什么喜欢傅盛的故事？因为他本来有机会在存量市场抱大腿，走上一条传统的成功之路。但是他铤而走险，放弃已知而且确认的存量市场，去完全陌生的增量市场摸索，并找到了自己的空间。</p><p>我在第三模块《系统生死线：猎豹和它的关键任务》那节中讲过，傅盛用野蛮人的姿态，甄别关键任务，在强敌大兵压境的压力下，完成了公司从软件公司向互联网公司的转型，暂时活了下来。</p><p>2012年，有人问我能不能投资傅盛，我说当然可以。原因很简单，互联网战争就是流量战争，流量资源最丰富的腾讯、百度以及新崛起的小米，三家一起扶植一个小兄弟傅盛，给的单一任务是让他替大家挡住周鸿祎。我说：“三个最牛的大哥挺一个小弟，而且傅盛本人也很厉害，当然可以投。”那个时候大家都是这么看的，他们和当时的我一样，小看了傅盛。确实，如果傅盛善于抱大腿，当年他就不会离开360。江湖上手握流量最多的三个大哥，为这个小弟安排的路，傅盛还是不会走。傅盛的动作是派了一个团队到美国，干什么？不知道。这个团队就是为了摆脱已知，把自己丢进未知里，在完全的陌生感里找方向、找空间。后来他们找到了猎豹清理大师（CleanMaster）这个项目，然后猎豹公司在美国上市了。</p><p>傅盛为什么要这么做，又为什么成功了？</p><p>傅盛自己都说和360打得非常痛苦，虽然360软件最初是他自己从零做起来的，但即便是他自己，要按照自己曾经成功的路再成功一次，已经是不可能了。360打了3Q大战，把用户数扩展到了3亿，体量已经比猎豹大太多。傅盛说：“对比360，我体量太小，正面仰攻真是不好打。”他拼命做了一堆微创新，比360提前1到2周上线。一两周之后，同样的功能360就会跟上，而用户反而会觉得是猎豹在抄360。这就是用户价值公式说的，当你正面仰攻时，微小的产品优化完全没有价值。傅盛的一个小团队，到美国做了一个之前从没有人认真做过的清理大师，并借助Google应用商店快速多语种全球化。这就是在以前没有人踏足的地方，踏上自己的足迹。在以前用户体验为零的地方，你的60分就是干干净净的60分，对于用户就是及格的。</p><h4 id="本讲小结-16"><a href="#本讲小结-16" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>存量市场，小企业正面仰攻，新体验做到80分，用户体验为零分。增量市场，在用户体验为零的地方，你只要做60分，用户就结结实实地觉得可以用了。俞军说：“当你找到蓝海，找到一块用户体验为零的领域，你需要做的是什么？你需要把用户体验做到100分再发布，还是做到60分就快速铺开市场？当然是产品做到60分就赶紧上。”<strong>速度第一，快速感染用户铺开市场，让最多的用户体验到你</strong>。这就是给后来者的壁垒，这就是蓝海的意义。就好像当年在欧洲大陆混不下去的西班牙人，到了南美所向无敌一样。那些在欧洲的宫廷里混得很好的人，当然不会冒着风险穿越大海。现有存量市场的既得利益者，也犯不着考虑创新。<strong>创新，找蓝海，找到没有大佬、用户体验为零的增量市场，是新公司唯一的改变命运的机会。</strong>这是我在最后一个模块，用一个模块讲创新的原因。</p><p><strong>你问我去向何方，我指着大海的方向。</strong></p><p>课后作业</p><p>你觉得你用过的什么产品用户迁移成本特别高？什么产品用户迁移成本很低？</p><p>说说你的体验，咱们在讨论区讨论一下。</p><h3 id="24-用“交叉视角”跨界创新"><a href="#24-用“交叉视角”跨界创新" class="headerlink" title="24 用“交叉视角”跨界创新"></a>24 用“交叉视角”跨界创新</h3><p>这是我们创新模块的第二讲，这堂课只有一句话：“未来已来，只是分布得不均匀。”这句话是什么意思？我先给大家讲个故事。这是婴儿恒温箱是怎么被发明出来，又是怎么迭代产品的故事。</p><h4 id="婴儿恒温箱的发明"><a href="#婴儿恒温箱的发明" class="headerlink" title="婴儿恒温箱的发明"></a>婴儿恒温箱的发明</h4><p>19世纪70年代后期，妇产科医生斯蒂芬·塔尼在繁忙工作之后，给自己放了个假，去巴黎动物园散步。那时候相当于中国的清朝，鸡鸭等都是动物园里的观赏动物。动物园他看到了小鸡的孵化器。斯蒂芬看到了从小鸡孵化器中刚孵出的小鸡，在温暖适宜的环境中蹦蹦跳跳，他有了一个想法。他聘用了动物园的家禽饲养员奥迪尔·马丁，两个人合作用小鸡孵化器的模式，制作出了给人类的婴儿恒温箱。19世纪末期新生婴儿的死亡率高得惊人。斯蒂芬做了统计，使用了他做的婴儿恒温箱之后，体重过轻的新生儿死亡率从66%降低为38%。每一个数字，都是一个人的生命。第二次世界大战之后，婴儿恒温箱已经成为美国的每家医院的标配，让1950年到1998年，近50年间新生儿死亡率降低了75%。研究认为，婴儿恒温箱的发明对公共健康有巨大的保护作用，超过20世纪其他任何一项发明。因为它是在生命之初提供帮助，让一个新生儿拥有了人生。这么伟大的发明，来自于一个医生去逛动物园，看到的小鸡孵化器。</p><h4 id="未来已来，只是分布不均"><a href="#未来已来，只是分布不均" class="headerlink" title="未来已来，只是分布不均"></a>未来已来，只是分布不均</h4><p>这节课的核心概念就是：“未来已来，只是分布得不均匀。”</p><p>跟这个观点意思一样，还有一本专门介绍创新的书《伟大创意的诞生》中，介绍了一个概念叫“相邻可能”。我们需要的某种能力要素，它可能已经产生并成熟了，只是它正在另外的某个领域被使用着。就看这个已经存在的未来，它会不会撞到你眼睛里，让你<strong>起心动念</strong>。这就是灵感的瞬间。所以，婴儿保温箱的发明者到底是谁？是斯蒂芬，还是动手做出了小鸡孵化器，又用同样的技术辅助斯蒂芬做了婴儿恒温箱的动物园家禽饲养员奥迪尔呢？当然是斯蒂芬，因为起心动念的人是他，定义产品的人是他，完成产品化关键环节推动的人还是他。此外，斯蒂芬还做了一个非常重要的工作。他知道法国的医疗机构对于统计数字的依赖，因此他在将婴儿恒温箱投入使用后，马上跟进数</p><p>据调查。“使用恒温箱后新生儿死亡率从66%降低为38%”，这个关键数据就是斯蒂芬给出的调研结果。这个统计结果，迅速撬动了所有的关键资源，从医疗机构、媒体，到投资大佬、慈善人士全面关注，推动了这一设备的普及。</p><p>斯蒂芬不仅完成了产品的定义，产品的实现，并且提供了产品市场化的关键动力。所以，虽然动手实现婴儿恒温箱的人是家禽饲养员奥迪尔，但是我们仍然认为这个伟大产品的发明人是斯蒂芬。</p><p>就好像第一代QQ的每一行代码，都是吴宵光写的，但是QQ之父是马化腾。因为是马化腾起心动念做了QQ的产品定义。</p><h4 id="婴儿恒温箱的迭代"><a href="#婴儿恒温箱的迭代" class="headerlink" title="婴儿恒温箱的迭代"></a>婴儿恒温箱的迭代</h4><p>婴儿恒温箱还有一个迭代的故事，也非常动人。二战后，婴儿恒温箱等技术的广泛使用，已经提高了欧美国家的初生儿的存活率。但是在很多条件不好的发展中国家，比如利比亚和埃塞俄比亚，初生儿死亡率依然很高。其实，这些婴儿中大多数都是可以存活下来的。</p><p>给这样的地方提供婴儿恒温箱的关键难点在哪里？</p><p>首先，当时的婴儿恒温箱非常复杂，而且很贵。美国医院使用的一台标准化婴儿恒温箱，售价大约是4万美金。从根本上说，贵并非是一个不能攻克的难题，总有类似比尔·盖茨的人愿意捐赠。</p><p>真正的难点在于，复杂的设备容易出现故障，而维修依赖专业的技术人员和维修备件。</p><p>2005年，就是印尼海啸发生后的第二年，一些国际救助组织捐给印尼一个城市八台婴儿恒温箱。2008年年末，也就是三年后，麻省理工学院的教授普赖斯蒂洛去访问这个城市时，发现这八台恒温箱全部出了故障，停止使用了。原因当然是各种各样的，比如当地的供电功率常常波动，电压不稳，湿度高等等。关键问题是什么呢？坏了不会修。当地的工作人员看不懂恒温箱上的英文维修手册，只能任由婴儿死去。</p><p>这八台恒温箱的故事，是一个典型的例子。很多案例表明，捐赠给不发达的发展中国家的各项技术设备中，大约有95%的设备会在前五年就因为故障而无法再投入使用。</p><p>普赖斯蒂洛就起心动念，为发展中国家研发一种新的婴儿恒温箱。他出了迭代的产品，产品需求是这样的：</p><p>这个新设备不仅应该更加可靠；</p><p>而且还要造价便宜；</p><p>最重要的事情是，一旦出现故障，这个设备不会完全瘫痪，稍加修理就可以再次投入使用。</p><p>这就是新婴儿恒温箱的产品定义。</p><p>这个产品的基础功能依然没有变：为初生婴儿提供恒温、透气的保障性空间。而这次产品迭代的核心变化，是对<strong>外协资源</strong>做了完全不同的定义：在当地的社会条件下，一定可以修。</p><p>可以修要保障两点：可以找到维修人员；找到维修备件。</p><p>普赖斯蒂洛做了这个产品定义之后，接着就发动团队开始找实现方法。找到方法的并不是普赖斯蒂洛本人，而是另外一个医生罗森。罗森是波士顿的医生，他通过观察发现，任何一个发展中国家的小城、小镇，都有汽车的维修和保养能力。这些城镇里就算缺少空调、笔记本电脑或者有线电视，也都能够确保让汽车在公路上跑。于是，罗森就向普赖斯蒂洛提议：可不可以用汽车的零部件，来改良出一种简易的婴儿恒温箱呢？</p><p>在罗森提出他的创意的三年后，普赖斯蒂洛团队，做出了新的婴儿恒温箱原型，他们给它定的名字叫育婴器。设备流线型的外观和现代的婴儿恒温箱一样，但是它的内部则是用汽车的部件来拼接完成的：</p><p>育婴器由旧车的头灯的前聚光灯提供主要的供暖；</p><p>用汽车仪表盘的风扇，用来保持空气流通，循环空气；</p><p>用车门的蜂鸣器做报警系统，在供暖设备出现问题的时候，蜂鸣器会叫，用来提醒护理人员；</p><p>它的动力主要是来自于标准的摩托车电瓶，或者一个改良的雪茄打火机。</p><p>这个利用汽车零部件做成的育婴器有双重的好处：不仅可以直接利用当地供货充足的汽车零件；同时只要是汽车维修人员，就可以来修理这个育婴器。</p><p>这就是普赖斯蒂洛和罗森的设想，如果要让发展中国家的婴儿真正被育婴器保护起来，育婴器的配件必须能够轻易在本地获得。并且维修这种育婴器的人，不用是那种所谓的高高在上的技术专家，甚至根本就不需要去阅读维修手册，他只要有能力换一个出故障的车头聚光灯，就能够轻松地胜任育婴器的维修和护理工作。</p><p>普赖斯蒂洛教授的汽车配件育婴器，造福了无数的孩子与家庭。</p><p>这是慈悲之心。这是超级伟大的产品人。</p><h4 id="本讲小结-17"><a href="#本讲小结-17" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>我觉得婴儿恒温箱的发明与迭代的故事，非常动人。</p><p>用于培育小鸡的器皿，用于汽车、摩托车的零件，用另外一个视角和用途需求去看，它们就有了新的可能，给予了数以亿计的人生命。有时候，大家想到创新会觉得高不可攀或者神秘浪漫，似乎创新就必须超越环境，横空出世。其实不是的。</p><p><strong>创新重要的是面对痛苦，起心动念。</strong></p><p>如果斯蒂芬医生，不曾为了新生儿的死亡而痛苦，他看到小鸡在孵化器中蹦蹦跳跳就不会怦然心动。如果普赖斯蒂洛教授不是痛苦于，一边婴儿死亡率高居不下，一边八台婴儿恒温箱无法运作，就不会起心动念，用发展中国家随处可得的材料重构婴儿恒温箱，就不会有之后的这一成果。所以，为某件事感到痛苦，也许就是你心念已动的时候。而要寻找解决它的创新之处，不妨到其他领域转转。也许它们就正在某个动物园，或者某个车库里，等着你的眼睛看到它们。</p><p>还是那句话：“未来已来，只是分布得不均匀。”</p><p>课后作业</p><p>你知道还有哪些这种嫁接创新的例子，欢迎跟我在留言区分享。</p><p>这节课就上到这里。</p><p>你想实现的，也许答案就在你隔壁的某个行业。</p><h3 id="25-怎样从新要素到新物种"><a href="#25-怎样从新要素到新物种" class="headerlink" title="25 怎样从新要素到新物种"></a>25 怎样从新要素到新物种</h3><p>这是创新模块的第三节课，这一课，我们谈新要素。</p><p>新要素这个概念，字面意思很普通。每个人都有这个意识，任何一个新产品，总得有新要素在里面。比如服装采用最新的面料，食物采用最新的食材配方，手机采用了最新的屏幕，这些都是新要素。</p><p>我今天想谈的是新要素与新物种的概念。</p><p>如何利用不是本行业体验迭代产生的新要素，而是引用跨行业的新要素，让你的产品看起来依然是原来的产品，但是它已经成为了一个新物种。</p><h4 id="新要素一：找到实体空间的好位置"><a href="#新要素一：找到实体空间的好位置" class="headerlink" title="新要素一：找到实体空间的好位置"></a>新要素一：找到实体空间的好位置</h4><p>我主要讲一个案例，就是“服务蓝图的核心要素：峰值、终值”那节课讲到过的亚朵酒店。</p><p>曾经大家认为，酒店行业最难做的是中档酒店。但是亚朵酒店用了不到5年时间，在全国110个城市开了150家酒店。而且，在2017年的《中国中端酒店投资报告》中，亚朵在用户满意度、投资回报率、投资人满意度三个维度上，同时位居第一。</p><p>它做了哪些不一样的事情？</p><p>我们在“服务蓝图的核心要素：峰值、终值”那节课讲了它有哪些细节做得不一样，但这些是优化前端体验的东西，而这一课我们来说它的商业模式的变化。我们把互联网商业简单地抽象为三个要素，产品、流量和转化率。那么，实体商业可以简单地抽象成四个要素：产品、空间、流量和转化率。我在准备产品课案例的时候，在空间上创新的产品，我想到过好几个，比如：亚朵、漫咖啡。在对亚朵的具体访谈过程中，我发现亚朵不仅仅在空间的定义和运营上做了创新，而且在流量和转化率方面，也有不一样的尝试。今天我谈一下，它在流量和转化率方面的一些新要素尝试。</p><p>实体经济要拼位置，为什么？因为位置即流量。所以，亚朵需要和能取得好位置商业地产的人合作。在好的地段，开一家前端服务体验不错，成本能控制的酒店，赚钱是大概率事件。在亚朵的商业体系中，有两个核心角色系统，一个是亚朵酒店管理公司，一个是房东。</p><p>在这个角色系统里，亚朵的核心工作有六项：</p><p>定义亚朵的服务品质，包括但不限于软硬件要求（空调、暖气等等）；</p><p>提供亚朵视觉系统的装修方案；</p><p>为每个酒店输出总经理和人力资源经理；</p><p>为所有员工提供培训和考核；</p><p>全网打通亚朵网络预订通道，将酒店收入项及时向房东结算；</p><p>对亚朵品牌及各店进行形象推广和公关宣传。</p><p>房东做什么呢？房东有四个核心工作：</p><p>找到当地适合开店的房子，适合开店有很多要求，地段、位置、房租价格等，这个由房东搞定；</p><p>按照亚朵提供的装修方案进行装修；</p><p>招聘该酒店除了总经理和人力资源经理外的所有员工，并按照亚朵给予的考核标准及时结算工资；</p><p>先行支付前期所有因租房、装修、雇佣人员等发生的款项。</p><p>亚朵之所以能开得这么快，是亚朵酒店管理公司与当地一个个房东一起合能的结果。合能就是把能力合起来，彼此赋能。酒店该开成什么样？人该怎么管？如何利用互联网炒作知名度？优化转化率达到用户？这些事情都是亚朵的专业。</p><p>房东的核心能力就是落地的能力，找到地段好、租金合适的房子，而且能够处理所有属于当地的消防、招聘员工等问题。当然，还有一个很重要的能力，就是房东得前期投资。大概要投多少钱？平均一个亚朵酒店前期需要投2000万。</p><h4 id="要素二：把“消费者”变成“投消者”"><a href="#要素二：把“消费者”变成“投消者”" class="headerlink" title="要素二：把“消费者”变成“投消者”"></a>要素二：把“消费者”变成“投消者”</h4><p>这时我们就要谈亚朵定位之外，第二个新要素——亚朵众筹酒店。如果我有能力搞定一个不错的房子，但是我没有2000万怎么办？亚朵推出了众筹酒店的模式，把筹备中的酒店项目作为一个项目融资，在众筹平台上发起众筹。投资人可以出资1万元到10万元不等，参与新亚朵酒店的股权融资，并获得经营分红。比如，天津小白楼亚朵发起众筹，只用了2个小时预约金额就已经达到了募资需求，5小时预约总金额超过5000万。</p><p>为什么会这么火？</p><p>第一，一个人的参与款是10万元，参与人数会更广泛。绝大多数家庭都有10万元的投资能力，但是如今10万元很难参与像样的项目。天津小白楼亚朵酒店算是个地段好的品牌项目，并且给出了较高的年回报预期，大股东还承诺分红达不到承诺值时，由特许业主补足，当然大家热情就很高。</p><p>第二，除了投资收益外，参与众筹的投资人，还可以获得对应等级的酒店消费权益。这时就可以对朋友吹牛，“我是这个酒店的股东，报我名字能打折”，这个对于中国人来说很重要。</p><p>第三，我最想强调的一个，历次亚朵酒店发起众筹时，最热烈的支持者首先是亚朵酒店的用户和忠诚会员。以小白楼项目为例，两个小时就达到了预约的募资需求。其预约的投资人65%以上都是亚朵消费者或会员。他们是亚朵产品的体验者、消费者，现在经由众筹升格为投资者。所以，亚朵的投资者也都成为了高忠诚、高黏性的消费者，最早参与亚朵众筹的7500位会员，每人每年平均在亚朵住宿15间夜（酒店行业统计所有房间出租天数的单位）以上，这些人累计贡献间夜量达15万。他们不仅仅是消费者，更是“投消者”。一方面，亚朵在授权一些特许业主投资的时候，这些人就会积极响应众筹，同时他们是亚朵最忠诚的消费者。这种“投消者”模式成了亚朵品牌扩张中最重要的盟友。</p><p>亚朵在流量方面的创新有：</p><p>第一，亚朵使用了众筹这个新要素，不但让一批有能力搞定房子和关系的房东，不会因为没有2000万启动资金而被阻止开酒店。</p><p>第二，通过众筹让上万人成为投资参与亚朵建设的小股东，这群人是亚朵真实的铁粉、死忠粉、带路粉。</p><h4 id="要素三：IP酒店亚朵在流量方面的另外一个创新就是IP酒店。"><a href="#要素三：IP酒店亚朵在流量方面的另外一个创新就是IP酒店。" class="headerlink" title="要素三：IP酒店亚朵在流量方面的另外一个创新就是IP酒店。"></a>要素三：IP酒店亚朵在流量方面的另外一个创新就是IP酒店。</h4><p>在影视行业，这两年IP特别热，为什么热？<strong>IP就是情感触发，就是场景，就是流量。</strong></p><p>什么叫情感触发，场景流量，请回头去看《设计产品时要包括产品的场景》那一讲。既然我们已经说了，实体生意就是产品、空间、流量和转化率。IP即是新流量，为什么不用呢？何况还有众筹酒店这个杠杆。他们把亚朵和吴晓波合作的亚朵·吴酒店定义为“社群酒店”。《吴晓波频道》自己介绍亚朵·吴酒店的时候说：</p><p>第一，社群活动。未来每一座城市的亚朵·吴酒店，都会成为《吴晓波频道》的线下社群场景。这里是《吴晓波频道》社群线下活动的场所，全国书友会的小伙伴都可以到亚朵酒店申请场地举办“每月同读一本书”等活动。</p><p>第二，阅读空间。在“《吴晓波频道》&amp;亚朵24小时阅读空间”活动中，你可以读到我们精心挑选的图书。旅行和读书这种场景概念便可以结合起来。</p><p>第三，场景电商。这里是场景电商的试验田，我们可以在这里看到《吴晓波频道》精选的“美好的店”产品陈列，在实际使用场景中体验到这些产品。例如，在睡前抿一口安枕的吴酒，喝一盏巴九灵茶田的茶，在猫王收音机里，听一集《每天听见吴晓波》。</p><p>利用吴晓波的品牌场景和《吴晓波频道》已经建设的社群流量，优化入住转化率。现在亚朵·吴酒店已经开了两家，北京、杭州各一家，前一段热炒的杭州网易严选酒店也是亚朵做的。亚朵的计划是未来10%的酒店是IP酒店，因为地段自带流量，IP也自带流量。</p><h4 id="要素四：场景电商"><a href="#要素四：场景电商" class="headerlink" title="要素四：场景电商"></a>要素四：场景电商</h4><p>第四个新要素，刚才介绍亚朵·吴酒店的时候带了一句，就是场景电商。你在亚朵酒店体验到的东西，例如枕头、床垫、洗发水都是可以买的。在讲服务蓝图的时候，我说过亚朵在它的床垫上比较下功夫。2016年，亚朵床垫卖了3万张，即使对于一个天猫店来说，这都是一个不小的量。亚朵创始人说到将来亚朵开到1000家店的时候，一年会有至少600万独立用户，真实体验亚朵空间的各个产品，因此亚朵有机会成为一家巨大的电商公司。</p><p>再说，亚朵创始人对亚朵空间定义的第一条，之前提到实体经济的四个重点：产品、流量、空间、转化率。亚朵的空间定义不仅是休息空间，也不仅是基于用户体验地图优化的峰终体验，而且还是用户在不同的地方体验各种生活新产品、所见即所得的电商空间。</p><p>你住亚朵酒店，不管它在用户体验地图，在你体验的峰值、终值上如何设计，从用户体验上它依然是个酒店。不像上一节课讲的小鸡孵化器变成婴儿恒温箱一样，成为了不同的东西。但是，用户体验没有很大变化的亚朵酒店从经营角度来讲，其实已经成为了一个新物种。因为它的流量模式、融资渠道、收入来源都发生了变化，使它与传统酒店业有了完全不同的腾挪空间和借力点。别人只能收房费，但它至少有三种利润来源：房费、商品的展示费、电商的利润。所以亚朵才会在过去几年，呈现出如此强大的生命力和扩张态势。</p><h4 id="本讲小结-18"><a href="#本讲小结-18" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结一下，<strong>新产品一定要有新要素，否则没有竞争力。</strong></p><p>新要素有两种：</p><p>第一种，在现有体验的基础上，运用最新科技等新要素，提升用户体验，或者改变成本结构。</p><p>第二种，用整个社会经济升级、产业升级所产生的其他领域新要素，变革内在的商业逻辑。也许用户的前端体验，依然是那个产品、那个服务，但公司背后的商业运作，已经成为了完全不同的新物种。</p><p>课后作业</p><p>在这节课的结尾，给你留一个作业：</p><p>1.你现在做的产品使用了什么样的新要素呢？</p><p>2.或许你自己的公司，就是一个传说中的新物种，不妨在留言区给大家介绍一下。</p><h3 id="26-三级火箭：深度讲解互联网降维打击"><a href="#26-三级火箭：深度讲解互联网降维打击" class="headerlink" title="26 三级火箭：深度讲解互联网降维打击"></a>26 三级火箭：深度讲解互联网降维打击</h3><p>这是第五模块的第四节课，这节课咱们谈三级火箭。三级火箭是互联网圈一个特别容易被提起的概念词。我们在《机会判断：点线面体的战略选择》那节课讲了360的三级火箭。</p><p>360的第一级火箭是免费杀毒工具，利用这级火箭打破了持续10年的杀毒软件市场三国鼎立的局面，成为用户量最大的安全工具。</p><p>360的第二级火箭是从免费杀毒工具变为安全网络平台，进而推出360安全浏览器和360安全网址导航。</p><p>360的第三级火箭就是它最终承载的商业闭环，从安全浏览器和网址导航的广告收入，获得企业的经营利润。</p><h4 id="搜狗的三级火箭"><a href="#搜狗的三级火箭" class="headerlink" title="搜狗的三级火箭"></a>搜狗的三级火箭</h4><p>2017年上市的搜狗，也是三级火箭模式的受益者。</p><p>2003年，张朝阳委任王小川开发搜狗搜索引擎，制衡百度，现在来看搜狗的起步相比较而言是较早的。搜狗开始的时候，Google、百度都还没有上市，Google是2004年上市的，百度是2005年上市的。</p><p>百度在做自有品牌的搜索之前，一直运营着两大业务。第一是为门户网站做搜索服务提供商。2000年，新浪就是中国的互联网，新浪的搜索是百度在背后提供服务。百度的第二个业务是做机房，也就是服务器托管服务。百度的强，不仅强在搜索技术优于当时的对手，它对流量的理解也远远优于其他对手，包括在中国开展业务的Google。百度有机房在手，哪台服务器上流量高，这个服务器上跑什么业务，百度再清楚不过了。蔡文胜说过，百度早期最重要的一笔交易就是收购了hao123网址大全，这笔交易为百度奠定了核心流量和利润。</p><p><strong>互联网商业就是产品、流量、转化率三个词。</strong></p><p>2003年，搜狗的产品技术不如百度，对流量的理解更不如百度，做不起来是必然的事。但王小川是天才少年，并且韧劲儿十足，居然没有放弃。</p><p>2005年，他做了搜狗输入法。我们说一个搜狗的秘史——搜狗输入法是如何快速达到市场占有率70%以上的份额的。</p><p>360免费杀毒的动力是来自于传统杀毒软件都是收费的，而且价格不菲。输入法一直都是免费的，那么搜狗应该怎么做？</p><p>搜狗输入法的流量获取依然很有中国的风格。当时“番茄花园”、“雨林木风”这类盗版系统非常受欢迎，搜狗就请他们帮助做了内置。就是这样一个简单的渠道，一年的时间搜狗输入法达到了70%的市场占有率。十几年后，搜狗上市了，曾经做盗版系统的天才少年都陨落了。如果搜狗输入法是搜狗的第一节火箭，那么这些产品就是它的燃料。搜狗的二级、三级火箭和360是一样的，利用一个大流量工具，推浏览器和搜索，再用这两个模式的商业变现。今天搜狗的模式又有了变化，为什么？大家的网络场景已经变成了手机。iPhone有内置输入法，安卓也有输入法。如果这时依旧用输入法再做头部流量，显然不够健壮。这时我们发现，王小川在股东选择上的智慧。回到“点线面体”的第二讲，谁是最有能力给你赋能的那个“面”。搜狗是互联网的万人迷，一堆老大都想做搜狗的股东。王小川做了什么？王小川拒绝了周鸿祎，清退了阿里，这并不是容易做到的事。拥抱了腾讯作为股东，并且两次让腾讯增加对搜狗的持股。这就形成了今天搜狗搜索的新三级火箭。</p><p>第一级火箭：头部流量。今天搜狗在移动搜索方面80%～90%的流量来自腾讯，其中从QQ浏览器导入的流量占到70%。</p><p>第二级火箭，内置搜索。用户在微信内、QQ内等不同的场景里的诉求，在浏览器之外通过庞大的使用场景去释放更多搜索的需求。搜狗内部称之为智慧战略。</p><p>第三级火箭，商业变现。</p><p>理解互联网公司的三级火箭</p><p>总结一下，三级火箭是什么意思？</p><ul><li><p><strong>第一级，头部流量。</strong></p></li><li><p><strong>第二级，沉淀某类用户的商业场景。</strong></p></li><li><p><strong>第三级，完成商业闭环。</strong></p></li></ul><p>举两个例子，第一个先讲一下罗辑思维。</p><ul><li><p><strong>第一级火箭是罗振宇坚持了多年的免费脱口秀。现在做知识付费的平台很多，只有得到App是有头部流量的。</strong></p></li><li><p><strong>第二级火箭，就是沉淀用户的商业场景，得到App。</strong></p></li><li><p><strong>第三级火箭，你今天付费听我讲课，这就是第三级火箭。</strong></p></li></ul><p>小米公司也是如此。</p><ul><li><p><strong>一级火箭是手机。</strong>手机对于vivo、OPPO是利润中心，对于小米是头部流量。所以为什么业界很多人批评小米价格低、利润薄，搞得行业都不好做，其实是因为对产品的战略定位不一样。</p></li><li><p><strong>二级火箭是它的一系列零售场景</strong>，小米商城、米家、小米之家、小米小店。我和雷军说，等你开了1000家小米之家，100万个小米小店，那真是插根扁担都能开花。</p></li><li><p><strong>三级火箭是一个高利润的产品</strong>。现在雷总还是不愿意说出来，但最后一定是一个利润非常高的项目，能扛住整个小米的财报。</p></li></ul><p>为什么要把三级火箭当一节课来讲？</p><p>我们上节课讲了新要素、新物种。你以为亚朵在做酒店，其实亚朵在做社群共创的实景电商。你以为你在和雷军比手机，其实他只是拿手机做头部流量。你要赚利润的东西，并非是他人要赚钱的地方。面对这样的竞争者，传统的生意套路会失效。</p><p>什么人能玩三级火箭？</p><p>玩三级火箭，如果去掉三个字，就是玩火。</p><p>要玩三级火箭，有几个必要条件。</p><p><strong>第一，第一级火箭一定要高频应用。三级递推一定是高频推低频，没有低频推高频的。</strong></p><p>比如招商银行App用户量很大，但是它能做第一级火箭吗？它太低频了，只能推更低频的产品，比如出国、理财等。但陌陌是个高频应用，陌陌推直播，直播变现，这就是陌陌的三级火箭。斗鱼是个非常火的直播平台，它能推短视频吗？不行，短视频比直播高频，它难以作为一个高频应用的一级火箭，但是如果它做游戏分发，也许可以。因为大家下游戏，一两个月才下一个，比看游戏直播低频。<strong>总原则就是一级比一级低频。</strong></p><p><strong>第二，通过第一级火箭获得大量用户之后，要快速展开一个能够沉淀用户的商业场景。</strong></p><p>比如，共享单车看上去是一个非常好的头部流量，用户量大，又足够高频。但是在这样一个头部流量很大的基础上，如何顺滑地建设出能够沉淀用户的商业场景？这是共享单车的运营企业需要面临的考题。</p><p><strong>第三，操盘三级火箭的人，一定是个势能积累到一定程度的人。</strong></p><p>为什么？首先，他要有强大的融资能力。一级火箭是不赚钱的，你需要用免费来支撑一个庞大的用户服务系统，还要保障用户满意，这是一笔很大的钱。没有势能的人，很难募到这个规模的钱。其次，当一级火箭铺开头部流量，他需要快速张开，短时间聚拢资源的能力是要有一定的势能积累才能做到的。得到App快速扩展了这么多的好老师，这并不是随便可以做到的事。</p><p><strong>第四，操盘三级火箭的人，一定是个狠人。</strong></p><p>因为你的一级火箭就是抢流量的，就是把别人河里的水都抢到自己的水渠里，成就自己的河流生态。你想想，这得多少人恨你。所以，干三级火箭，不是偶然干成的，而是一开始就想着颠覆现有的行业，干掉现有的企业。所以如果不是狠人，不是积蓄已久的人，不是有高频应用场景的人，不是能承受指责的人，三级火箭还是没法轻易玩。</p><h4 id="三级火箭的原理"><a href="#三级火箭的原理" class="headerlink" title="三级火箭的原理"></a>三级火箭的原理</h4><p>我们一直在说三级火箭，火箭为什么是三级的？</p><p>因为火箭和汽车、飞机目的不一样，所以动力原理不一样。汽车、飞机一节燃料就够了，但只有一节燃料，火箭没办法突破大气层。火箭是靠自己把自己推起来，这就跟咱们这些没有靠山的创业者一样。你凭什么有势能，其中一点就是靠割让自己的利益。别人挣钱，我不挣钱，我获得的用户多一点，我才拥有了势能。</p><p>火箭如果只有一节，里面又装燃料，又装要发射的卫星，会怎样？结论是，按照传统模式，火箭是飞不起来的，它无法突破大气。二战时，德国研制的火箭，不能突破到外大气层，飞不到地球同步轨道，只能在大气层里飞。解决方案就是做一个动态系统，喷射燃料，抛出火箭壳，降低负载。</p><p>如果火箭只有二节，飞一块丢掉一块，第二块再飞上去，需要多重呢？以1吨重的卫星为例，需要149吨燃料，三级需要77吨，四级65吨。<strong>火箭级数越多，需要的燃料越少。但每增加一级，不可控程度越高。</strong>就好像咱们做商业，模型过于复杂，变现链条过长，就容易玩脱了。如果只做二级火箭，149吨才能推1吨，三级只需要77吨。如果三级火箭能够省一半的重量，危险程度也提升一倍。然而到了四级火箭，燃料重量可以省10吨，危险程度却变成了四倍。所以，<strong>三级火箭是一个成本和可控性平衡后的选择。</strong></p><h4 id="在人类的天空放上星星"><a href="#在人类的天空放上星星" class="headerlink" title="在人类的天空放上星星"></a>在人类的天空放上星星</h4><p>我还想说两件事：</p><p>第一件事，火箭是自己把自己推起来的，它的一级就是一个巨大的燃料堆，目的是给自己制造势能。但火箭的目的不是飞得越高越好，而是为了放卫星，是为了把一颗星星放到星空上。</p><p>无数有权力、有钱的人，都拥有巨大的势能，就好像拥有一级火箭。但很多人只是享受无限上升的乐趣，完全没有概念要把一颗星星放到人类文明的天顶上，所以当他们势能耗散，也会被快速遗忘。</p><p>我想说说我崇敬的一个人，就是诺贝尔。诺贝尔奖发了100多年，其实没多少钱。中关村有很多比诺贝尔奖基金更有钱的基金、企业，但中关村的那些故事早就消失了，或者10年后20年后就消失了。分析一下诺贝尔奖，他一生的财富、心愿是一级火箭；忠实执行的管理机构是二级火箭；而一次次发放的奖金，往人类的天顶上安放的星星，这才是真正有价值的三级火箭。终我们的一生，追逐金钱、创建人脉、获得权力、积蓄势能，一切其实成就了你的势能，打造了你的一级火箭。但是你的一生是无限享受上升的乐趣，还是有一颗星星想放到人类的天顶上，这是一个问题。</p><p>另外，需要说的是，关于三级火箭的事，是张云帆给我讲的。张云帆是完美世界控股集团董事、纵横文学CEO。他给我讲了他对三级火箭模式的完整理解，我觉得非常棒。我就问他能不能把他的三级火箭模式，放到得到App里来讲，他同意了。感谢张云帆。</p><h4 id="本讲小结-19"><a href="#本讲小结-19" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>这节课就到这里，总结一下，商业模式的三级火箭：</p><p><strong>第一级，搭建高频头部流量；</strong></p><p><strong>第二级，沉淀用户的商业场景；</strong></p><p><strong>第三级，完成商业闭环。</strong></p><p>课后作业</p><p>留一个作业互动一下：</p><p>火箭是自己把自己推起来的，它的第一级是给自己建立势能。</p><p>你觉得你身边的谁，或者你知道的谁，特别擅长给自己去建设势能？</p><p>欢迎在讨论区跟我分享一下。</p><h3 id="27-颠覆式创新：成败价值网"><a href="#27-颠覆式创新：成败价值网" class="headerlink" title="27 颠覆式创新：成败价值网"></a>27 颠覆式创新：成败价值网</h3><p>这是我们创新模块的最后一讲，我们讲颠覆式创新。</p><p>讲创新不能不谈颠覆式创新，颠覆式创新5年前还是非常新的概念，现在已经成了一个互联网的热词了。马克思说：人的本质在其现实性上是一切社会关系的总和。你不是一个孤立的个体，你是你一切社会关系的总和。企业是其赖以生存的价值网的某一节点。不管人还是企业都生活在一个网里。</p><h4 id="价值网与颠覆式创新"><a href="#价值网与颠覆式创新" class="headerlink" title="价值网与颠覆式创新"></a>价值网与颠覆式创新</h4><p>什么叫价值网？《创新者的窘境》里有这样一段话：</p><p>真正决定企业未来发展方向的是市场价值网，而非管理者；真正主导企业发展进程的是机构以外的力量，而非机构内部的管理者。管理者只是扮演一个象征性的角色。企业真正的管理者，就是识别自己赖以生存的价值网。这个管理者应该建立一个组织，与这个价值网进行资源对接。一个好的组织结构，它的每一个组织部门，都是为了和某一个社会价值网的分支进行对接而设计的。<u>一个失败的企业的组织结构，是管理者按照自己需求设置的。</u></p><p><strong>谈颠覆式创新，为什么要先谈价值网？</strong></p><p>因为很多没落的企业，在自己的价值网上依然是优秀的，只是它依附的价值网过时了；搭载在新的价值网上的企业，实现了自己的颠覆式创新。就好像你是你社会关系的总和，你的社会关系哺育塑造了你，同时他们也锁定、限制和束缚了你。一个企业成就于自己不同部门和它依附价值网之间，资源与资金的输入输出。但它赖以存在的价值网，也会锁死这家企业。马化腾说：“也许你什么错都没有，只是老了。”很多没落的企业，也是什么错都没有，只是它的价值网过时了。</p><p><strong>计算机行业的价值网更迭</strong></p><p>我先讲一个古老的故事，其实是一连串古老的故事。</p><p>1940年代，世界第一台计算机UNIVAC(通用自动计算机)被研制出来。这一伟大产品被认为是专为科研工作而设计的，因此对企业级商业市场毫无兴趣。1950年左右，UNIVAC的公司市场调研结论：到2000年，电脑的销售量将达到1000台。为什么会出现这样的市场预判？因为它是基于自己的价值网做的预判，而UNIVAC的公司的价值网就是为顶级科研服务，从这个角度而言，他并没有错。IBM和其他早期的美国计算机一样，也是专门为科研设计的。但是不同的是，IBM积极拥抱了企业对计算机的强烈需求。它其实用的就是UNIVAC的技术，但是为会计工作做了优化，所以IBM公司叫国际商业机器公司，靠着服务会计起家。</p><p>10年以后，UNIVAC仍然拥有当时最先进的计算机。但是，IBM却几乎拥有了整个计算机市场。因为大家选择了不同的价值网，你可以认为IBM颠覆式创新，颠覆了UNIVAC的市场。UNIVAC的价值网在科研，而IBM公司的价值网在商业企业。80年代，有句话说，“任何公司向IBM业已占据的领先地位直接发起挑战都无望获得成功。”</p><p>然而PC出现了，苹果电脑诞生了，联想诞生了。后来的故事，就是我自己亲身经历的故事了，中国出了联想。1997年联想电脑在中国市场打败IBM、惠普、康柏位列中国市场占有率第一的时候，乔布斯刚返回苹果不久。2004年，联想收购了IBM的PC业务，成为了全球PC的老大。IBM曾经是神一般的存在，而PC行业皇冠上的明珠ThinkPad，被联想摘下了。苹果手机现在是手机行业皇冠上的明珠，如果有一天，小米把iPhone买了，一举成为全球手机行业老大，那成就和2004年联想收购了IBM的PC业务是类似的。2004年，联想的杨元庆做到这件事的时候，只有40岁，雷军是40岁才刚刚创办了小米。所以杨元庆在40岁就已经取得了一个较高的成就。但是之后的十几年，他一直被牢牢地锁死在PC的这张价值网里，错过了移动互联网。</p><p>大家都说雷军是劳模，极其勤奋，如果说我还见过一个勤奋程度不逊于雷军的人，就是杨元庆。杨元庆以一个中国本土企业，去整合高贵傲慢的IBM全球资源，两年的时间，持续两个星期飞3个洲，睡觉都在飞机上，下了飞机就开会，还练好了英语，用英语直接管理IBM分布在全球的经理人。可见价值网的力量多么强大，即使像杨元庆这样超级优秀的人都难以挣脱。</p><h4 id="价值网的三大要素"><a href="#价值网的三大要素" class="headerlink" title="价值网的三大要素"></a>价值网的三大要素</h4><p>混沌大学的李善友教授是专门讲颠覆式创新的，他对价值网的解释是：</p><p><strong>价值网里，至少有三个角色：一是客户，二是对手，三是投资人。</strong></p><p>就是这三个核心力量，加上其他千丝万缕的牵制，牢牢地捆住一个大企业。为什么IBM没有推出小型计算机？因为它的客户是大型机构的核算和数据处理部门，不需要小型计算机。他们因为服务客户而错过了另外一个大的增长。IBM没有进入小型机，因为背后的价值网是顾客决定的。企业第一目的是生存，生存必须获取资源，而资源是顾客提供的。<strong>客户是我们最重要的资产，但也可能是我们最主要的创新盲区。</strong>所以资源分配流程其实不是管理者定义的，而是来自价值网中的客户需求与对手挤压。并不是有技术、有人才就什么都能做。</p><p>价值网里的第二个要素，是对手。在江湖里做企业，很多时候对手对你的刺激是直接刺激。生物学说共同进化，两个人与其说是相互竞争，不妨说是跟竞争对手构成一个网，我恨你，你恨我，互相作为参照物，谁也离不开谁，眼里全是竞争对手。比如360公司2011年上市，2012年全力以赴做搜索，在这之前是周鸿祎与李彦宏十一年的缠斗，这在周鸿祎最近出的自传中有提到。但事实上，其实我们应该警醒。我们会被思维遮蔽，真正缠住你视野的，有时候不是客户，而是你的对手。所以，<strong>放下贪婪、愤怒</strong>，这也许真的要靠智慧。</p><p>价值网里的第三个要素：是投资人。我想所有的创业者尤其是上市公司，对此深有体会。这也是为什么窝窝团要上市的时候，美团说谁先上市谁就输了。因为资本所要求的增长是个魔咒。联想2014年财务报告很漂亮，但是之后股价就大跌，为什么？因为没有达到分析师预测的增长。股市是一个很丑陋的游戏，增长是一个魔咒，所有企业都丧失在里边，只有10%的企业能够维持良好的增长势头，而只有2%的企业长期超过市场绩效。</p><p>在资本的增长压力下，大公司很难进入小市场。李彦宏说过，对于百度来讲，低于1%收入比例的市场是不看的。</p><p>埃隆·马斯克做特斯拉的时候，电动车的销售额占据大型汽车厂商销量的不到1%。所以，大型汽车厂商会因增长魔咒的控制而眼睁睁地放任了特斯拉的崛起。而小市场一旦启动指数级的爆发增长，大公司就再也追不上了。</p><h4 id="组织心智"><a href="#组织心智" class="headerlink" title="组织心智"></a>组织心智</h4><p>很多极其优秀的公司为什么失败了？</p><p>管理的书一定会告诉你是管理出问题了。但是写《创新者的窘境》的克里斯坦森的说法是，良好的管理恰恰是他们未能保持行业领先地位的最重要的原因。所以，所谓管理得好的公司，往往是与现有价值网的紧密对接。响应现有客户需求，紧盯对手，满足投资人。所有的弦都绷得高效、流畅，没有冗余和浪费，管理得无比完美。整个公司的管理设计，都是为了高效服务现有价值网。公司的资源配置如此，公司组织流程的设计也是类似，公司财务评估的方式更是如此。然后就这样长期循环下去。资源要这样安排，组织流程必须这样才合理，财务评估要按照这种价值判断，以上因素加在一起，这是什么？</p><p>这就形成了“组织心智”！虽然一般说用感叹号很粗鲁，我忍不住用了感叹号，这也是这门课唯一一次使用感叹号的地方。</p><p>联想是我的第一份工作，我19岁就在联想上班，我对这家公司有强烈的情感。当年它要做手机的时候，我就知道没戏，因为我了解这家公司的“组织心智”。一系列在这个组织里无比合理的决定，让这家曾经伟大的企业，无法从现有的PC价值网中逃出来。</p><p>一个组织的心智模式定下来就真的很难以改变，像我们的基因一样看不见，但决定组织的整体思考方式。这也是为什么新经济给了我们这些没背景，只会琢磨用户体验的人机会。我们的机会就是看到新崛起、新展开的价值网。因为如果是一个新的增量市场，意味着这是一个新的价值网。传统老企业，它的组织心智不一样，所以它没有办法和你一样去做出反应，因此我们创业者充满机会。</p><p>iPhone开启了移动互联网，iPhone是第一台智能手机吗？当然不是。诺基亚早就开始了开发智能手机，并且智能心智开发的很好。但是诺基亚对手机的定义是通信产品，iPhone对手机的定义是互联网手机，是移动互联网的终端。看上去是一样的产品，但代表了完全不同的两张价值网。</p><p>联想从PC到移动互联网叫做遇到了非连续；诺基亚曾经是手机霸主，遇到了苹果也叫遇到了非连续。<strong>什么是非连续？就是整个社会在发展，整体社会能力升级，新的需求被释放催生新的价值网。</strong>传统企业在它传统的价值网里依然可以生存，例如联想依然是PC价值网的霸主，但它在新的价值网里是边缘企业。新崛起的价值网，才是新大陆。</p><h4 id="什么是颠覆式创新？"><a href="#什么是颠覆式创新？" class="headerlink" title="什么是颠覆式创新？"></a>什么是颠覆式创新？</h4><p>颠覆式创新最重要的标准就是，是否开启了一个新的价值网？你是不是到了“新大陆”？也许它刚一开始很小，不到传统企业的1%。</p><p>1990年新浪来跟联想谈合作，我们会感到奇怪，当时它显然不如《计算机世界》《计算机报》，但是它是新的价值网。特拉斯刚启动，不到传统汽车厂商的1%。iPhone一代刚发布，包括微软的鲍尔默在内的整个硅谷，都对它冷嘲热讽。但是，它一旦开始，就不可逆。</p><p>我之前讲的产品方法，都是教你怎么从零到一做一个产品，安身立命赚点钱，继续服务、迭代。</p><p>颠覆式创新是屠龙术，是产生新帝国的机会。概率非常之小，但我希望听我课程的你，有机会做这样的事。</p><h4 id="本章小节"><a href="#本章小节" class="headerlink" title="本章小节"></a>本章小节</h4><p>我们的创新模块就到此结束了。总结一下：</p><p>第一节课，我们谈了用户价值公式。用户价值＝新体验－旧体验－用户迁移成本，存量市场的打法就是拼体量，创业公司唯一的机会就是创新、去增量市场。</p><p>第二节课，我们谈了未来已来，只是分布得不均匀。根据小鸡孵化器，可以做出人类婴儿的恒温箱。其实我们需要的很多解决方案，就在你旁边已经出现了，需要的是你的思考和洞察。</p><p>第三节课，我们谈了新要素、新物种。所有的新产品，都会有些新要素，有些是产品本身的升级，有些是把整个社会升级的新能力纳入企业，使企业看上去在提供原来的服务，但它的内在商业运作机理已经非常不同，甚至已经变成了一个新物种。</p><p>第四节课，我们谈了互联网圈很爱使用的三级火箭模型。第一级火箭是头部流量，第二级火箭是沉淀用户的商业场景，第三级火箭是交易变现。</p><p>最后这节课，我们讲创新模式的帝王术——颠覆式创新，开启新的价值网。</p><p>课后作业</p><p>这节课就到这里，我们还是留一个作业互动一下。</p><p>到这节课，我们创新的这个板块就讲完了，不管是个人还是公司，你有没有在做创新呢？</p><p>欢迎把你所做的创新，在留言区分享给我。</p><h3 id="28-看产品的微观、中观与宏观视角"><a href="#28-看产品的微观、中观与宏观视角" class="headerlink" title="28 看产品的微观、中观与宏观视角"></a>28 看产品的微观、中观与宏观视角</h3><p>前面五大模块，我就<em>同理心</em>、<em>机会判断</em>、<em>系统能力</em>、<em>用户体验</em>和<em>创新模式</em>，把做一个产品五大块的思考框架介绍了一遍。</p><p>有人问我，你怎么判断一个人是不是产品高手？怎么评估这个人厉害在哪里，不厉害在哪里？我把好产品体系用三个层次再总结一下，分别是：<strong>中观</strong>、<strong>微观</strong>、<strong>宏观</strong>。你可以对照看一下自己，或者你要评估的人，在这个三个层面水平如何？</p><h4 id="中观套路：学习招数"><a href="#中观套路：学习招数" class="headerlink" title="中观套路：学习招数"></a>中观套路：学习招数</h4><p>什么叫中观？就是套路。第二模块之后的内容，有大量的套路：用户画像、痛点和痒点、整体流程图、用户体验地图和服务蓝图。书店里有很多讲套路的书：用户需求、产品策略、功能定义、流程图制作、产品原型制作、项目管理、数据分析、产品运营……</p><p>大公司是学习套路的好地方。一家公司能系统培养某一类人，说明这家公司在这个领域有与众不同的套路，比如：联想出销售、腾讯出产品经理、阿里出运营、百度出技术。</p><p>所以大学毕业去大公司是有价值的，因为套路有价值。套路像武功招数一样，是前人总结的有效经验。比如用户体验，如果你不懂用户画像、用户体验地图、用户体验这些套路性动作，按照自己的模糊感觉做，也许也能接近用户体验的完整。但练好套路可以自我排查问题，便于和团队沟通。</p><p>除非你打算在大公司呆一辈子，否则最好不要超过5年。</p><p>为什么？因为大公司教你套路，同时也会深深地把你角色化，让你只能作为系统的一个角色，习惯系统内的生存。</p><p>创业企业也不要迷信大公司的套路，最典型的就是从腾讯挖个产品经理，创业者就觉得可以把自己的产品交给他。甚至与这个产品经理PK的时候，还不自信，觉得对方是大公司出来的更专业。</p><p>因为，靠套路成不了高手。套路可以让你更有章法地展现自己，更容易搞定面试官，成为系统内按指令行事的公司中层。如果你为既定资源，既定需求的系统服务，套路足以胜任。因为一件事做到什么程度，多一点少一点的刻度，有领导控制，有系统控制。</p><p>但是如果你想依靠这门手艺，自立门户，博得名利，那么你面对的是整个市场的竞争与用户的分流。你每时每刻，都需要面对每一个细节的取舍。没有人告诉你“可以了”，没人告诉你对与错，甚至用户给你的反馈都是混杂的。</p><p>你如何做出每一个微小的决策，持续迭代，持续优化？</p><h4 id="微观体感：成为高手"><a href="#微观体感：成为高手" class="headerlink" title="微观体感：成为高手"></a>微观体感：成为高手</h4><p>要成为能够自我决策的好手，我们就需要产品经理能力的第二个维度：微观体感。</p><p>每一个微小的动作选择叠加起来，就是你拿出来的产品，就是你活出来的样子。那么日常中，我们做每一个细小选择，靠的是什么？靠微观体感，就是真实地感知每一个微小瞬间。前面的课程很多是讲微观体感的，尤其是开篇的第一模块。</p><p>产品是一种被动的艺术。一个产品只能在被动中，默默把握每一个微小的主动机会，在每一个接触的瞬间，每一次的交互里，让用户顺畅地深入下来。用户动力不足，要放弃这个产品，你是没有任何办法的。最挑剔的人，其实就是最有防御意识的人。如果产品突然碰触用户的某个意识神经，让用户产生防御，那流失的几率就会加大。</p><p>举一个并不新鲜的例子，日本一位做寿司的师傅叫小野二郎，一部有关他的纪录片叫《寿司之神》。</p><p>小野二郎做寿司时间超过55年，直到70多岁，他还对寿司有很多新想法。纪录片里讲小野怎么带徒弟：</p><p>在小野二郎的店里做学徒，首先必须学会用手拧毛巾，毛巾很烫，一开始会烫伤手。没学会拧毛巾，就不可能碰鱼；然后，要学会用刀、料理鱼。十年之后，徒弟才能煎蛋。纪录片里的学徒说：“我练习煎蛋很久了，以为自己没问题，但在实际操作时，却不断搞砸。他们一直说‘不行，不够好’。”</p><p>十年的基础训练完毕，一名学徒终于够格煎蛋，却发现自己似乎永远无法满足师傅们的标准。他又花了4个月，经历200多个失败品后，做出了第一个合格的煎蛋。小野二郎说：“这才是应该有的样子”。终于承认这名学徒为“职人”时，他高兴哭了。</p><p>如果是你，你能清晰地说出那200个失败品的不同吗？能说出那200个失败品和唯一的合格品之间，微妙的临界点在哪吗？小野二郎可以真切地判断——来自他的微观体感。</p><p>为什么花10年学习拧毛巾、用刀和料理鱼？为了建立精微的微观体感。</p><p>达·芬奇为什么要练习画鸡蛋？为了建立精微的观察和手感。</p><p>用普通人的视角来看，鸡蛋都一样。但要是成为一个伟大的画家，就要不断练习，在最不容易建立观察的地方，建立每一个微小处的觉察。</p><p>反思什么样的设计才能让用户满足？复盘用户是否产生了防御心？为什么会在这里卡顿？产品应该怎么做才自然？成为天才的一万小时都干了些什么？大量的时间都是在建立细微的微观体感，建立长在自己身体上的真实感觉，眨眼之间的好恶判断。</p><p>很多爱好者、发烧友是有微观体感的，他们需要补中观的套路，才能够有系统、有层次地释放他的感受。而在大公司也好，看书纸上谈兵也好，拥有了中观套路的人，一定要补微观体感。否则，说起来都对，做事却都不到位。</p><p>如果能够同时拥有微观体感和中观套路，那就是一个产品好手了。</p><h4 id="宏观能力：打大仗"><a href="#宏观能力：打大仗" class="headerlink" title="宏观能力：打大仗"></a>宏观能力：打大仗</h4><p>那什么是宏观能力？就是打大仗的能力。</p><p>你说锤子手机的微观体感和中观套路如何？很好啊。比起小米手机，差在宏观能力。</p><p>你说易到用车当时的用户体验和口碑如何？很好啊。比起滴滴，差在宏观能力。</p><p>在这套课里的<strong>点线面体、创新模式都是宏观能力</strong>。</p><p>几家定位相似、体验相似的产品，靠优化用户体验，其实是无法终结战争的。大仗拼胜负，靠的是宏观能力。</p><h4 id="本讲小结-20"><a href="#本讲小结-20" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>练好套路，在大公司做到中层没问题。要想自己为结果负责，开门立户创业，必须有长在自己身上的微观体感。没有微观体感，靠套路判断，就是自欺欺人。但打大仗，做顶级高手，其实宏观能力也要强。</p><p>这是我们对之前的内容，用微观、中观、宏观三个层级做的一个小小的总结。</p><h3 id="29-人生逻辑大于商业逻辑"><a href="#29-人生逻辑大于商业逻辑" class="headerlink" title="29 人生逻辑大于商业逻辑"></a>29 人生逻辑大于商业逻辑</h3><p>这是我这套课的倒数第二讲。一晃到了尾声，我还有点不舍的感觉。</p><p>产品能力是现实的、功利的能力。做产品要求你判断客观条件和机会、盘点资源、按照用户体验的方式，有层次地整合起来，向世界交付价值获得报偿。</p><p>在这一节课的时间，我想和你分享一下我的一些观察和感受，就是：<strong>人生逻辑大于商业逻辑。</strong></p><p>我为了把课串起来，做了一套扑克牌。那就会面临问题是谁是大王、小王？刚一开始，我想用“点线面体”做大王，“依赖”做小王。“点线面体”的战略选择，属于宏观能力，打大仗，靠的得是宏观视野、势能的使用和趋势的把握。但心里还是有些不确定，和很多朋友沟通后，最后选择“确定性”做大王，“依赖”做小王。</p><h4 id="雷军和“风口论”"><a href="#雷军和“风口论”" class="headerlink" title="雷军和“风口论”"></a>雷军和“风口论”</h4><p>为什么次序是这样的？</p><p>不得不提雷军那句广泛传播的名言：“只要站在风口，猪也能飞起来。”这些年，风口论成了最著名的成功学。抢风口几乎成了创业的规定动作，你在不在风口上成了所有资源方判断你的标尺，成了社交场面里介绍每个人必须有的一个标签。</p><p>不过，我给我的女性朋友们创业建议时，我的说法是：“女性创业，不要抢风口。”</p><p>抢风口，背后的一个核心能力是<strong>抢资源</strong>的能力：争夺最好的团队，争夺最大笔的投资，争夺公众最大化的关注，争夺合作伙伴最优质的资源与配合……</p><p>争夺这件事上，基本上女性的能力是弱于男性的。男生从小就会有推推打打的游戏，踢足球、打篮球，与人协作去争抢一个东西，甚至经常磕蹭受伤，所以从小就习惯争夺。而女生从小玩的是安安静静的游戏，对如何主动去争夺，如何组织团队去集体争夺，甚至在争夺过程中，自己与队友如何应对有意无意的碰撞与伤害，几乎是完全没有概念的。</p><p>很多人看到一个资本的风口，觉得自己有认知能力，有一些所谓的资源，有不甘心于人后的心气，就冲上去。但其实对“争夺”这件事，无论是历史训练，还是心理准备其实都是不足的，很难不败下阵来。2014年到现在，咱们看到了几次风口，O2O上门服务、打车大战、外卖大战、网络金融、共享单车……所有的“风口争夺战”挺到最后并飞上天的那个，其实真没有谁是碰了运气的猪，全部是创业了好久，磨炼了好久的老手。</p><p>雷军会说这句话，其实是因为他曾经是个内心非常骄傲的人。如果你当自己是一只雄鹰，就不需要依赖风，不论自己做什么随时随地都可以成功。但是，2007年金山上市，对一般人来讲已经非常成功了，而雷军却郁闷得要死，因为这不是他要的大成。所以他做小米时谈飞猪理论，把自我矮化成一头猪，时刻提醒自己：我个体能力只能达到这个点，如果我想大成，需要依赖机会、环境、势能。</p><p>我们上一课谈了中观、微观、宏观能力，就能否大成要靠宏观能力，个体的能力之于机遇其实微不足道。</p><h4 id="确定性和不确定性"><a href="#确定性和不确定性" class="headerlink" title="确定性和不确定性"></a>确定性和不确定性</h4><p>宏观能力、点线面体的战略选择当然很重要。但是它是最重要的吗？</p><p>当你对自己根据“点线面体”做了一个宏观判断，是否真的能不论自己准备是否成熟，内心是否确定，就冲到那个风口去？</p><p>我想讲一个我自己的故事。熟悉我的一些朋友都了解，2016年我差点和一个投资界的大佬一起做一个母基金。折腾了近一年，连第一笔钱都筹齐了，最后我还是选择不做了。这个过程很狼狈，算我人生的教训之一。我选择做母基金肯定是点线面体的战略选择，合作伙伴T先生是业界资深人士，我们之间有很多共同的朋友。母基金又很高端，算是一个上流社交圈，客观来讲我应该做这件事。</p><p>接着，就要抛出这副扑克牌的王牌“确定性”和作为红桃k的“不确定性”。</p><p>说“确定性”和“不确定性”之前，我说一下马云的组织观：</p><ul><li><p>三级组织是共同规则。一般的公司职员、学生、生产线的工人、军人、犯人都是共同规则管理。</p></li><li><p>二级组织是共同利益。平时管士兵是共同规则；打仗要攻城了，谁先进城有赏，这算一种共同利益。老板和员工之间，是共同规则；和股东之间是共同利益。</p></li><li><p>一级组织是共同信仰。共产党早期的故事，就是有信仰的组织。</p></li></ul><ul><li>顶级组织呢？是至情至性。桃园结义是中国最美的图景之一。我算了一下时间，他们三个人从公元184年起兵征讨黄巾军，到公元214年入蜀建立了自己的稳定地盘，整整30年一直在四处征战，没有根据地。刘备三顾茅庐去请诸葛亮是公元207年，隆中对的重要性在于确定了天下三分的战略。刘关张三个人在没有清晰战略，一直辗转征战的情况下合作了23年。23年，一直都在不确定、受挫的状态里，核心团队没有散，我们扪心自问一下这有多难？这真是至情至性。</li></ul><p>所以我为什么没和T先生做母基金？因为母基金周期较长，至少10年。我和T先生至情至性肯定谈不上，共同信仰好像也没有，剩下的就只有共同利益。10年，充满了各种不确定的冲击，我们对彼此的价值和利益的认定，一定会有分歧。这就是一个极其脆弱的合作。我知道母基金是符合点线面体的好选择，但是我对我和T先生的关系没有确定感。于是我没有办法因为一瞬间看到了一件事的好，就把自己交给这个很脆弱的关系，一起面对未来10年的不确定。<u>这其实是我把“点线面体”变成了黑桃K，而把“确定性”做成了大王的原因。</u></p><p>世界是多维的，到处是此起彼伏的点线面体，各种机会呈现出的就是各种变幻，各种不确定。你会因为对于机会和利益的判断，而在各种不确定中坚持多久呢？那什么样的人、东西、感觉会给你确定感，让你觉得可依赖，其实是极其重要的。</p><p>为什么有人画秘密花园填色图会觉得治愈？有人做饭会觉得治愈？因为这些都是有确定感的东西。对一个产品的使用，对一个人的关系，持续收到确定感的反馈，就会觉得安全，觉得可以依赖。如果突然变得不确定，就会有被伤害的感觉。这也是网站不要轻易改版的原因。</p><p>我们的课是产品课，是否符合点线面体的大趋势，固然是大成的标准；但如果你无法持续输出确定感，无法让人依赖，其实连小成都达不到。</p><h4 id="点线面体VS确定性依赖"><a href="#点线面体VS确定性依赖" class="headerlink" title="点线面体VS确定性依赖"></a>点线面体VS确定性依赖</h4><p>说完确定性，那什么是依赖呢？依赖是一种真实的长期关系。</p><p>你观察你的父母，你身边的伴侣，你认识的创业合伙人，谁是完美的？他们之间有没有抱怨、不满？肯定的。他们之间有依赖吗？有的。</p><p>所谓“完美的产品”“极致的产品”就像“完美的人”一样，只是一种追求，但世上并不存在。</p><p><strong>重要的不是完美，而是对方要的那个确定性你是否还能提供，对方是否还依赖你，这才是关系的关键。</strong>就好像我们对我们的父母，当我们不依赖他们，即使千恩万谢，也是会离开。产品和用户之间也是如此。所以，红桃K是“不确定性”，它是生活的一部分，是我们不能畏惧，需要勇敢拥抱的东西。黑桃K是“点线面体”，是宏观格局的判断，是你做人生选择题时可以采用的思考框架。而大王是确定性，小王是依赖。这就是我们最后确定的4张牌。</p><p>如果你内心没有“确定感”，如果没有人依赖你，你也没有人可以依赖，点线面体、价值网、三级火箭这些创新战略，即使你看到了也是空无而不可持续的。</p><h4 id="本讲小结-21"><a href="#本讲小结-21" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>所以，为什么会有很多企业家，很多事看上去可以做、应该做，但没有做，这就是“非不为也，是不能也”。成功学给出的逻辑虽都很对，但是我实在是干不来。</p><p>其实正确的做法就是，自己真实能做到的。商业是以利润为中心，人生是以意义为中心。商业并非人生的全部。人死前盘点自己的一生，其实没有人看这一生赚了多少利润。</p><p>做你有内心确定感的事，人生逻辑大于商业逻辑。</p><h3 id="30-产品连接客观世界、过去与将来"><a href="#30-产品连接客观世界、过去与将来" class="headerlink" title="30 产品连接客观世界、过去与将来"></a>30 产品连接客观世界、过去与将来</h3><p>一晃到了最后一节课，我们聊聊天吧。</p><p>我的好朋友李学凌曾经有个签名档，是“make things，change things”，简单可以翻译为“做东西，改变东西”。另外一个好朋友王兴也曾经有个签名档，“create as god，work as slave”可以翻译为“像奴隶一样去工作，像上帝一样去创造。”这都是他们很久很久以前的签名档，但是因为我非常喜欢，所以一直记得。因为这两句话，“做东西，改变东西”，“像奴隶一样去工作，像上帝一样去创造”就是一个产品经理的人生。</p><p>应罗胖和脱不花之邀，很高兴在得到上做这套产品课，讲了作为一个产品经理，应该具备的概念点和思考框架。但可能我个人的心愿还不止于此。我希望中国有更多产品经理，有更多动手工作，改变现实、优化世界的人。</p><h4 id="海中之盐"><a href="#海中之盐" class="headerlink" title="海中之盐"></a>海中之盐</h4><p>我讲一个盐的故事。1914年冬天，有个年轻人叫范旭东，他独自一个人到了天津塘沽。塘沽靠海，海滩上一片白，但那不是冬天的冰雪，而是盐。你想象一下那个景象：无人的海边，海里的盐一坨一坨凝结在沙滩上，放眼望去白茫茫一片。范旭东是湖南人，他看到这一幕非常激动。日后他对伙伴说：“一个化学家，看到这样丰富的资源，如果还没有雄心，未免太没有志气了。”咱们国家有漫长的海岸线，但是几千年来咱们的祖先一直都没盐吃。古代盐就是钱，钱镠、程咬金都贩过私盐，《金瓶梅》中西门庆赚的最大一笔钱是从盐上来的。但是这些盐，这些钱，就这样像冰雪一样堆在沙滩上。为什么面对资源却不能处理？任何一个学过高一化学的人，如果穿越回古代，都可以找个无人的海岸，从大海里取出盐。而就生活在海边的渔民，是古代最惨的人，他们只认识鱼，而不知道在身边滚滚而来的海浪里，就有盐，就有资源的本身。缺乏专业化视角和专业化能力会导致什么呢？仅从产品结果看，我们中国人一直吃土法制作的粗盐，盐氯化钠含量不足50%。当时西方发达国家已经明确规定，氯化钠含量不足85%的盐不许拿来做饲料。因此，有西方人讥笑我们是“食土民族”。直到1915年范旭东开办久大精盐公司，中国才做出了95%以上纯度的盐。中国人吃到像回事的盐，才刚刚100年。今天我们中国人对自己美食真实的自信，但是100年前连像回事的盐都没有，更谈何自信。所谓自信是在不断的创造与反馈中建立的。盐是如此。互联网也是如此。</p><h4 id="产品能力，大海取盐"><a href="#产品能力，大海取盐" class="headerlink" title="产品能力，大海取盐"></a>产品能力，大海取盐</h4><p>我们不谈过去60年或者20年，互联网对这个世界的优化，只谈最近7年。7年前的2011年，有两个重要的产品，微信和小米手机。微信的意义是什么，对于每个人都有体会。</p><p>小米手机有两个意义：</p><ul><li><p>它开启了低端智能手机的市场，直接推动了中国智能手机的普及。之后的一年2012年，被定义为中国的移动互联网元年。</p></li><li><p>小米的极致化单品。创始人社会化网络粉丝经济的系列爆发，开启了中国的新品牌浪潮。</p></li></ul><p>这7年，因为智能手机的普及，微信这种超级应用的拉动，中国8亿人成为了高频的网民。</p><p>基于移动场景的商业O2O、新闻、娱乐都在重构。很多人学习小米的爆品策略，推出的网红品牌层出不穷，例如社会化营销的网红奶茶、网红洗发水、网红内衣、网红面膜等。</p><p>今天你已经习以为常，成为生活依赖的应用，放到7年前，其实统统都是还没有的。你有专业化视角，你有专业化能力，你可以从大海里取出盐，你可以在一间会议室里做出微信，你可以在一个小屋子里定义出小米手机。自此，无数人有了不同的机会，无数人的生活因此改变。这就是一个产品经理的荣耀。</p><h4 id="中国产品的大航海时代"><a href="#中国产品的大航海时代" class="headerlink" title="中国产品的大航海时代"></a>中国产品的大航海时代</h4><p>前一段我和雷军、曾鸣都做了深度沟通，大家的共识是：互联网时代结束了。</p><p>2018年以后，新公司应该是以互联网为基础设施的科技公司，新品牌公司。这些年，新品牌已经冒出来很多了，但是一定还会更多，还会更强。我坚信下一个时代，由中国原生的品牌一定会像宝洁、雀巢一样走向全世界。</p><p>为什么我有这个信心？大家有没有注意，美国网红品牌没有中国多，因为美国没有消费升级。美国的消费升级，是由现在已经成为国际大牌的这些企业主导完成的。它们借助了美国的内需和工业能力，建设了企业对用户的服务能力，借助资本能力、设计能力、心理优势，快速实现全球化。在上一时代，国际大品牌碾轧中国消费品、快消品、日化品的时候，因为我们资本能力、设计能力、心理优势、产业链掌控度全面低微。但是今天时代变了，整个中国商业的基础能力，发生变化了。淘宝一个90后女孩创立的网红女装，一个公司400人，充分使用社会化网络协同，一年可以做到20亿的交易额。雷军、杨元庆、余承东这些国际化先行者的竞争擂台，已经到了在印度市场论输赢，在印尼市场较高低，在巴西在北美分胜负。今天的中国不少领域的产品人，在中观套路、在微观体感、在宏观视野，都已经不输于那些国际大厂的产品经理。</p><p>如果你抛开惯性化的仰视和妄自菲薄，我们客观评估一下，曾经横吞了整个中国日化、消费品类的那些国际大牌，你会感受到中国还在孕育奇迹。我们一定会孕育出下一个宝洁，下一个雀巢，下一个ZARA。这是我为什么要分享这个课程的原因。</p><p>不管是20年前我在联想，亲历联想如何同时打败四五十个国内品牌和十余个国际大牌，成为中国第一的过程。还是今天我站在这里讲，怎么从零做一个产品，怎么拥有第一个用户，怎么与用户连接，怎么在用户驱动里迭代。20多年来，我从来都没有改变过，对我们自己的创造力，对我们自己做东西能力的信心。100年前中国人对中国美食有自信吗？那会儿连像样的盐都没有。就好像1997年，或者2007年一样，站在一个新的机会窗口，我相信这又是一个中国原生品牌井喷的时代。</p><h4 id="愿你伟大时代，置身局内"><a href="#愿你伟大时代，置身局内" class="headerlink" title="愿你伟大时代，置身局内"></a>愿你伟大时代，置身局内</h4><p>这是另外一个伟大的时代，你我，都不应该置身局外。</p><p>愿你拥有专业化视角和专业化能力。看到时代的浪潮，不再抱怨波涛滚滚的凶险，而能看到大海的本身就是资源。不需要哀怨自己没有出身背景，没有干爹，在这个时代，只要你拥有一个用户，你就拥有了一个开始。</p><p>愿你能够使用这套方法，建立自己的动手能力。动动手，你所在的小世界就会优化一点点。</p><p>愿你在这个时代，把握真正属于你的那个机会。把你一生积累的认知、审美、好恶全部用上，为这个世界提供一个不一样的产品，向世界交付你的价值。</p><p>愿你拥有自信、财富与荣耀。</p><p>让我们相信，明天会更好。</p><h3 id="结课辞-我想跟你继续的事"><a href="#结课辞-我想跟你继续的事" class="headerlink" title="结课辞 我想跟你继续的事"></a>结课辞 我想跟你继续的事</h3><p>亲爱的你，</p><p>一晃《产品思维30讲》到了结课的时候，此刻的心情很轻松，有点开心，还有些意犹未尽。</p><p>表扬学完每一课的你，其实每一课知识点都挺硬的，岁末又是极忙的时刻，每天跟上进度，要付出很大努力，真心赞一个。</p><p>这些知识点，是过去20年我们互联网圈一仗一仗打出来的真功夫，所以如果你能领会，与你的实际工作和生活对照，一定不白学。</p><p>表扬认真写作业的你，后台留言作业数量和质量让我惊到，很多作业都非常棒。也许是得到已经形成了良好的学习气氛，也许是因为你信任我，愿意把自己的真实感受告诉我。</p><p>表扬认真写作业的你，得到的同学的作业数量和质量，让我惊到。也许是得到已经形成的学习气氛，也许是因为你信任我，愿意把自己的真实感受告诉我。很多作业都非常棒。因为篇幅有限，非常多的好内容没有办法放出。但是可以保证的一件事是，每一篇作业，每一条留言，我都读了。</p><p>感谢在后台留言中给我肯定的你。“产品思维”是互联网经济快速崛起的重要思考框架，但放在得到这样的一个广众平台，受众面还是太窄了。曾经担心会不会没有人来学，或者听不懂。你们的肯定，很大地安慰了我，让我觉得半年的打磨，还是值得的。谢谢。</p><p>很多同学问到第二季，我想如果在得到平台的订阅超过10万，我就做第二季。</p><h4 id="等你“泄密”"><a href="#等你“泄密”" class="headerlink" title="等你“泄密”"></a>等你“泄密”</h4><p>做完这30讲，我和你一样意犹未尽。</p><p>从2018年3月开始，我想继续与你保持线上的互动，为期三个月。</p><p>我和你一起按照《产品思维30讲》的思考框架，分析一些正在运营中的真实产品，包括但不限于互联网产品、餐饮、日用消费品、电子科技产品、影视娱乐等。</p><p>具体分析什么产品？我希望是：你“泄密”，我分析。</p><p>如果你是一个产品的参与者，你可以把你观察到的，这个产品的优秀点、成功之处或者经验告诉我。你可以选择匿名，也可以选择公开。你可以告诉我这是什么产品，也可以保密。但是，你一定要讲被验证的干货经验。</p><p>只要你的内容被选中，大礼奉上。</p><p>我会不定期汇总，在课程内更新。</p><p>课程的部分，暂时就到这了。后面案例分析的部分，就等你的“泄密”啦～</p><p>梁宁2018.2.3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;01-产品能力是每个人的底层能力&quot;&gt;&lt;a href=&quot;#01-产品能力是每个人的底层能力&quot; class=&quot;headerlink&quot; title=&quot;01 产品能力是每个人的底层能力&quot;&gt;&lt;/a&gt;01 产品能力是每个人的底层能力&lt;/h3&gt;&lt;p&gt;你好，欢迎来到《梁宁·产品思
      
    
    </summary>
    
      <category term="产品运营" scheme="http://gnbyj.cn/categories/%E4%BA%A7%E5%93%81%E8%BF%90%E8%90%A5/"/>
    
    
      <category term="产品思维" scheme="http://gnbyj.cn/tags/%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
</feed>
