<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BiuBiu</title>
  
  <subtitle>GOOD IS GOOD, BUT BETTER CARRIES IT.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gnbyj.cn/"/>
  <updated>2018-10-14T16:10:24.760Z</updated>
  <id>http://gnbyj.cn/</id>
  
  <author>
    <name>Gavin Gao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>将本地项目上传到Github</title>
    <link href="http://gnbyj.cn/2018/10/13/Git/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github/"/>
    <id>http://gnbyj.cn/2018/10/13/Git/将本地项目上传到Github/</id>
    <published>2018-10-13T06:50:00.000Z</published>
    <updated>2018-10-14T16:10:24.760Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>进入Github首页，点击New repository新建一个项目</strong> </p><p><a href="https://github.com/new" target="_blank" rel="noopener">https://github.com/new</a> </p><p>Create a new repository</p></li></ol><ol start="2"><li><p><strong>点击Clone or dowload会出现一个地址，copy这个地址备用</strong> </p><p>Clone or download –&gt; copy “xxx.git”</p></li></ol><ol start="3"><li><p><strong>把github上面的仓库克隆到本地</strong></p><p>git clone <a href="https://github.com/xxx/xxx.git" target="_blank" rel="noopener">https://github.com/xxx/xxx.git</a></p></li></ol><ol start="4"><li><p><strong>将项目上传到github</strong></p><p><strong>git add .</strong>        （注：别忘记后面的.，此操作是把文件夹下面的文件都添加进来）</p><p><strong>git commit  -m  “提交信息”</strong>  （注：“提交信息”里面换成你需要，如“first commit”）</p><p><strong>git push -u origin master</strong>   （注：此操作目的是把本地仓库push到Github上面，此步骤需要你输入帐号和密码）</p><p>或者：</p><p>在项目文件夹输入“git init”，将当前文件夹加入git管理；</p><p><strong>git add .</strong>（不要漏了“.”，或文件名），将文件夹全部内容添加到git；</p><p><strong>git commit -m “first commit”</strong>（“git commit -m “提交信息”” ）；</p><p><strong>git remote add origin <a href="https://github.com/xxx/xxx.git" target="_blank" rel="noopener">https://github.com/xxx/xxx.git</a> </strong> 连接你的Github仓库；</p><p><strong>git pull origin master</strong> 把本地仓库的变化连接到远程仓库主分支；</p><p><strong>git push (-f) -u origin master</strong> 上传项目到Github，或要求输入Github的账号密码。-f 强制推送，-u初次推送使用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;进入Github首页，点击New repository新建一个项目&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/new&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https
      
    
    </summary>
    
      <category term="Git" scheme="http://gnbyj.cn/categories/Git/"/>
    
    
      <category term="Java Web" scheme="http://gnbyj.cn/tags/Java-Web/"/>
    
      <category term="Git" scheme="http://gnbyj.cn/tags/Git/"/>
    
      <category term="Github" scheme="http://gnbyj.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>面向对象六大原则</title>
    <link href="http://gnbyj.cn/2018/07/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://gnbyj.cn/2018/07/25/设计模式/面向对象六大原则/</id>
    <published>2018-07-25T04:45:00.000Z</published>
    <updated>2018-07-25T04:50:30.472Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章主要讲的是面向对象设计中，我们应该遵循的六大原则。只有掌握了这些原则，我们才能更好的理解设计模式。</p></blockquote><p>我们接下来要介绍以下 6 个内容。</p><ol><li>单一职责原则——SRP</li><li>开闭原则——OCP</li><li>里式替换原则——LSP</li><li>依赖倒置原则——DIP</li><li>接口隔离原则——ISP</li><li>迪米特原则——LOD</li></ol><h2 id="一、单一职责原则"><a href="#一、单一职责原则" class="headerlink" title="一、单一职责原则"></a>一、单一职责原则</h2><p>单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。如果一个类负责了方法 M1，方法 M2 两个不同的事情，当 M1 方法发生变化的时候，我们需要修改这个类的 M1 方法，但是这个时候就有可能导致 M2 方法不能工作。这个不是我们期待的，但是由于这种设计却很有可能发生。所以这个时候，我们需要把 M1 方法，M2 方法单独分离成两个类，让每个类只专心处理自己的方法。</p><p>单一职责原则的好处如下：</p><ol><li>可以降低类的复杂度，一个类只负责一项职责，这样逻辑也简单很多；</li><li>提高类的可读性，和系统的维护性，因为不会有其他奇怪的方法来干扰我们理解这个类的含义；</li><li>当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。</li></ol><h2 id="二、开闭原则"><a href="#二、开闭原则" class="headerlink" title="二、开闭原则"></a>二、开闭原则</h2><p>开闭原则和单一职责原则一样，是非常基础而且一般是常识的原则。开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。</p><p>当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题。</p><p>这个准则和单一职责原则一样，是一个大家都这样去认为但是又没规定具体该如何去做的一种原则。</p><p>开闭原则我们可以用一种方式来确保他，我们用抽象去构建框架，用实现扩展细节。这样当发生修改的时候，我们就直接用抽象了派生一个具体类去实现修改。</p><h2 id="三、里氏替换原则"><a href="#三、里氏替换原则" class="headerlink" title="三、里氏替换原则"></a>三、里氏替换原则</h2><p>里氏替换原则：所有引用基类的地方必须能够透明地使用其子类的对象。</p><p>里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能。他包含以下几层意思：</p><ol><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li><li>子类可以增加自己独有的方法。</li><li>当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。</li></ol><p>里氏替换原则之所以这样要求是因为继承有很多缺点，他虽然是复用代码的一种方法，但同时继承在一定程度上违反了封装。父类的属性和方法对子类都是透明的，子类可以随意修改父类的成员。这也导致了，如果需求变更，子类对父类的方法进行一些复写的时候，其他的子类无法正常工作。所以里氏替换法则被提出来。</p><p>确保程序遵循里氏替换原则可以要求我们的程序建立抽象，通过抽象去建立规范，然后用实现去扩展细节，这个是不是很耳熟，对，里氏替换原则和开闭原则往往是相互依存的。</p><h2 id="四、依赖倒置原则"><a href="#四、依赖倒置原则" class="headerlink" title="四、依赖倒置原则"></a>四、依赖倒置原则</h2><p>依赖倒置原则：一种特殊的解耦方式，使得高层次的模块不应该依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。</p><p>这也是一个让人难懂的定义，他可以简单来说就是</p><ol><li>高层模块不应该依赖底层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ol><p>在 Java 中抽象指的是接口或者抽象类，两者皆不能实例化。而细节就是实现类，也就是实现了接口或者继承了抽象类的类。他是可以被实例化的。高层模块指的是调用端，底层模块是具体的实现类。在 Java 中，依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的。这就是俗称的面向接口编程。</p><p>示例代码——工人用锤子来修理东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hammer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"用锤子修理东西"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(Hammer hammer)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工人"</span> + hammer.function());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Worker().fix(<span class="keyword">new</span> Hammer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是一个很简单的例子，但是如果我们要新增加一个功能，工人用螺丝刀来修理东西，在这个类，我们发现是很难做的。因为我们 Worker 类依赖于一个具体的实现类 Hammer。所以我们用到面向接口编程的思想，改成如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的 Worker 是通过这个接口来于其他细节类进行依赖。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(Tools tool)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工人"</span> + tool.function());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Worker().fix(<span class="keyword">new</span> Hammer());</span><br><span class="line">        <span class="keyword">new</span> Worker().fix(<span class="keyword">new</span> Screwdriver());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 Hammer 类与 Screwdriver 类实现这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hammer</span> <span class="keyword">implements</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"用锤子修理东西"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screwdriver</span> <span class="keyword">implements</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"用螺丝刀修理东西"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过面向接口编程，我们的代码就有了很高的扩展性，降低了代码之间的耦合度，提高了系统的稳定性。</p><h2 id="五、接口隔离原则"><a href="#五、接口隔离原则" class="headerlink" title="五、接口隔离原则"></a>五、接口隔离原则</h2><p>接口隔离原则：客户端不应该依赖他不需要的接口。换一种说法就是类间的依赖关系应该建立在最小的接口上。</p><p>我们通过一个例子来说明。我们知道在 Java 中一个具体类实现了一个接口，那必然就要实现接口中的所有方法。如果我们有一个类 A 和类 B 通过接口 I 来依赖，类 B 是对类 A 依赖的实现，这个接口 I 有 5 个方法。但是类 A 与类 B 只通过方法 1，2，3依赖，然后类 C 与类 D 通过接口 I 来依赖，类 D 是对类 C 依赖的实现但是他们却是通过方法 1，4，5 依赖。那么是必在实现接口的时候，类 B 就要有实现他不需要的方法 4 和方法 5 而类 D 就要实现他不需要的方法 2，和方法 3。这简直就是一个灾难的设计。</p><p>所以我们需要对接口进行拆分，就是把接口分成满足依赖关系的最小接口，类 B 与类 D 不需要去实现与他们无关接口方法。比如在这个例子中，我们可以把接口拆成 3 个，第一个是仅仅由方法 1 的接口，第二个接口是包含 2，3 方法的，第三个接口是包含 4，5 方法的。</p><p>这样，我们的设计就满足了接口隔离原则。</p><p>以上这些设计思想用英文的第一个字母可以组成SOLID ，满足这个5个原则的程序也被称为满足了SOLID准则。</p><h2 id="六、迪米特原则"><a href="#六、迪米特原则" class="headerlink" title="六、迪米特原则"></a>六、迪米特原则</h2><p>迪米特原则，也被称为最小知识原则，是指一个对象应该对其他对象保持最小的了解。</p><p>因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，所以这也是我们提倡的软件编程的总的原则：低耦合，高内聚。</p><p><strong>迪米特法则还有一个更简单的定义：只与直接的朋友通信。</strong></p><p>首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><p>这里我们可以用一个现实生活中的例子来讲解一下。比如我们需要一张 CD，我们可能去音像店去问老板有没有我们需要的那张 CD，老板说现在没有，等有的时候你们来拿就行了。在这里我们不需要关心老板是从哪里，怎么获得的那张 CD，我们只和老板（直接朋友）沟通，至于老板从他的朋友那里通过何种条件得到的 CD，我们不关心，我们不和老板的朋友（陌生人）进行通信，这个就是迪米特的一个应用。说白了，就是一种中介的方式。我们通过老板这个中介来和真正提供 CD 的人发生联系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章主要讲的是面向对象设计中，我们应该遵循的六大原则。只有掌握了这些原则，我们才能更好的理解设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们接下来要介绍以下 6 个内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单一职责原则——SRP&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://gnbyj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://gnbyj.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="http://gnbyj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="OOP" scheme="http://gnbyj.cn/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>8张图理解Java</title>
    <link href="http://gnbyj.cn/2018/07/25/Java/8%E5%BC%A0%E5%9B%BE%E7%90%86%E8%A7%A3Java/"/>
    <id>http://gnbyj.cn/2018/07/25/Java/8张图理解Java/</id>
    <published>2018-07-25T04:43:00.000Z</published>
    <updated>2018-07-25T04:48:33.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、字符串不变性"><a href="#1、字符串不变性" class="headerlink" title="1、字符串不变性"></a>1、<a href="http://www.programcreek.com/2009/02/diagram-to-show-java-strings-immutability/" target="_blank" rel="noopener">字符串不变性</a></h2><p>下面这张图展示了这段代码做了什么</p><p><a href="http://www.importnew.com/11725.html/string-immutability-650x279" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2014/06/866816a69119a9ca24232d753ef537b8.jpeg" alt="string-immutability-650x279"></a></p><h2 id="2、equals-方法、hashCode-方法的区别"><a href="#2、equals-方法、hashCode-方法的区别" class="headerlink" title="2、equals()方法、hashCode()方法的区别"></a>2、<a href="http://www.programcreek.com/2011/07/java-equals-and-hashcode-contract/" target="_blank" rel="noopener">equals()方法、hashCode()方法的区别</a></h2><p>HashCode被设计用来提高性能。equals()方法与hashCode()方法的区别在于：</p><ol><li>如果两个对象相等(equal)，那么他们一定有相同的哈希值。</li><li>如果两个对象的哈希值相同，但他们未必相等(equal)。</li></ol><p><a href="http://www.importnew.com/11725.html/java-hashcode-650x369" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2014/06/0954391ddfaad41dd3ead5037bfdc1eb.jpeg" alt="java-hashcode-650x369"></a></p><h2 id="3、Java异常类的层次结构"><a href="#3、Java异常类的层次结构" class="headerlink" title="3、Java异常类的层次结构"></a>3、<a href="http://www.programcreek.com/2009/02/diagram-for-hierarchy-of-exception-classes/" target="_blank" rel="noopener">Java异常类的层次结构</a></h2><p>图中红色部分为受检查异常。它们必须被捕获，或者在函数中声明为抛出该异常。</p><p><a href="http://www.importnew.com/11725.html/exception-hierarchy-diagram" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2014/06/fbddd02451798ed512e142809d02bc0c-498x1024.jpeg" alt="Exception-Hierarchy-Diagram"></a></p><h2 id="4、集合类的层次结构"><a href="#4、集合类的层次结构" class="headerlink" title="4、集合类的层次结构"></a>4、<a href="http://www.programcreek.com/2009/02/the-interface-and-class-hierarchy-for-collections/" target="_blank" rel="noopener">集合类的层次结构</a></h2><p>注意Collections和Collection的区别。（Collections包含有各种有关集合操作的静态多态方法）</p><p><a href="http://www.importnew.com/11725.html/collectionvscollections-2" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2014/06/647d134fddb1872cf1f5a8facbb41557.jpeg" alt="CollectionVsCollections"></a></p><h2 id="5、Java同步"><a href="#5、Java同步" class="headerlink" title="5、Java同步"></a>5、<a href="http://www.programcreek.com/2011/12/monitors-java-synchronization-mechanism/" target="_blank" rel="noopener">Java同步</a></h2><p>Java同步机制可通过类比建筑物来阐明。</p><p><a href="http://www.importnew.com/11725.html/java-monitor" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2014/06/b8d387a03337e0a37f0df743507c5f26.jpg" alt="Java-Monitor"></a></p><h2 id="6、别名"><a href="#6、别名" class="headerlink" title="6、别名"></a>6、<a href="http://www.programcreek.com/2012/12/how-does-java-handle-aliasing/" target="_blank" rel="noopener">别名</a></h2><p>别名意味着有多个变量指向同一可被更新的内存块，这些别名分别是不同的对象类型。</p><p><a href="http://www.importnew.com/11725.html/javaaliasing" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2014/06/5ff0d9d66dd85d01cee8a423544d3b21.jpeg" alt="JavaAliasing"></a></p><h2 id="7、堆和栈"><a href="#7、堆和栈" class="headerlink" title="7、堆和栈"></a>7、<a href="http://www.programcreek.com/2013/04/what-does-a-java-array-look-like-in-memory/" target="_blank" rel="noopener">堆和栈</a></h2><p>图解表明了方法和对象在运行时内存中的位置。</p><p><a href="http://www.importnew.com/11725.html/java-array-in-memory" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2014/06/cc55bbfe947afccc45c18dee9cbb8112.png" alt="Java-array-in-memory"></a></p><h2 id="8、Java虚拟机运行时数据区域"><a href="#8、Java虚拟机运行时数据区域" class="headerlink" title="8、Java虚拟机运行时数据区域"></a>8、<a href="http://www.programcreek.com/2013/04/jvm-run-time-data-areas/" target="_blank" rel="noopener">Java虚拟机运行时数据区域</a></h2><p>图解展示了整个虚拟机运行时数据区域的情况。</p><p><a href="http://www.importnew.com/11725.html/jvm-runtime-data-area" target="_blank" rel="noopener"><img src="http://incdn1.b0.upaiyun.com/2014/06/80c7346c554563d5738537a353f2bc0b.jpg" alt="JVM-runtime-data-area"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、字符串不变性&quot;&gt;&lt;a href=&quot;#1、字符串不变性&quot; class=&quot;headerlink&quot; title=&quot;1、字符串不变性&quot;&gt;&lt;/a&gt;1、&lt;a href=&quot;http://www.programcreek.com/2009/02/diagram-to-show
      
    
    </summary>
    
      <category term="Java" scheme="http://gnbyj.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://gnbyj.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式系列（一）单例模式</title>
    <link href="http://gnbyj.cn/2018/07/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://gnbyj.cn/2018/07/24/设计模式/Java 设计模式系列（一）单例模式/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2018-07-24T12:27:38.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>保证一个类只有一个实例，并且提供一个访可该实例的全局访问点。</p></blockquote><h2 id="一、饿汉式单例"><a href="#一、饿汉式单例" class="headerlink" title="一、饿汉式单例"></a>一、饿汉式单例</h2><p>关键字：线程安全/占内存/调用速度快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例类：在类初始化时，已经自行实例化</span></span><br><span class="line"><span class="comment">// 非延迟加载单例类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton single = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="comment">//静态工厂方法   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> single;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。</p><p>饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。</p><h2 id="二、懒汉式单例"><a href="#二、懒汉式单例" class="headerlink" title="二、懒汉式单例"></a>二、懒汉式单例</h2><p>关键字：线程不安全/调用速度慢/省内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例类：在第一次调用的时候实例化自己</span></span><br><span class="line"><span class="comment"> * 1. 构造器私有化，避免外面直接创建对象</span></span><br><span class="line"><span class="comment"> * 2. 声明一个私有的静态变量</span></span><br><span class="line"><span class="comment"> * 3. 创建一个对外的公共静态方法访问该变量，如果没有变量就创建对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">//静态工厂方法   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123;    </span><br><span class="line">             single = <span class="keyword">new</span> Singleton();  </span><br><span class="line">         &#125;    </span><br><span class="line">        <span class="keyword">return</span> single;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多线程下不安全，可以看到 Singleton 不是同一个对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Singleton.newInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Singleton 通过将构造方法限定为 private 避免了类在外部被实例化，在同一个虚拟机范围内，Singleton 的唯一实例只能通过 newInstance() 方法访问。（事实上，通过 Java 反射机制是能够实例化构造方法为 private 的类的，那基本上会使所有的 Java 单例实现失效。此问题在此处不做讨论。）</p><p>但是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个 Singleton 实例，要实现线程安全，有以下几种方式：</p><p><strong>(1) 同步延迟加载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">//静态工厂方法   synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123;    </span><br><span class="line">             single = <span class="keyword">new</span> Singleton();  </span><br><span class="line">         &#125;    </span><br><span class="line">        <span class="keyword">return</span> single;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟 99% 的情况下是不需要同步的；</p><p><strong>(2) 双重检测同步延迟加载 </strong></p><p>为处理同步延迟加载方式瓶颈问题，我们需要对 instance 进行第二次检查，目的是避开过多的同步（因为这里的同步只需在第一次创建实例时才同步，一旦创建成功，以后获取实例时就不需要再获取锁了），但在 Java 中行不通，因为同步块外面的 if (instance == null) 可能看到已存在，但不完整的实例。JDK5.0 以后版本若 instance 为 volatile 则可行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;<span class="comment">// 1  </span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     <span class="comment">// 2  </span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">// 3  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 newInstance 中做了两次 null 检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗。</p><blockquote><p>可以看到里面加了 volatile 关键字来声明单例对象，既然 synchronized 已经起到了多线程下原子性、有序性、可见性的作用，为什么还要加 volatile 呢？双重检测锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是失败的一个主要原因。</p><p><strong>无序写入</strong>：<br>为解释该问题，需要重新考察上述清单中的 //3 行。此行代码创建了一个 Singleton 对象并初始化变量 instance 来引用此对象。这行代码的问题是：在 Singleton 构造函数体执行之前，变量 instance 可能成为非 null 的，即赋值语句在对象实例化之前调用，此时别的线程得到的是一个还会初始化的对象，这样会导致系统崩溃。<br>什么？这一说法可能让您始料未及，但事实确实如此。在解释这个现象如何发生前，请先暂时接受这一事实，我们先来考察一下双重检查锁定是如何被破坏的。假设代码执行以下事件序列：</p><ol><li>线程 1 进入 getInstance() 方法。</li><li>由于 instance 为 null，线程 1 在 //1 处进入 synchronized 块。 </li><li>线程 1 前进到 //3 处，但在构造函数执行之前，使实例成为非 null。 </li><li>线程 1 被线程 2 预占。</li><li>线程 2 检查实例是否为 null。因为实例不为 null，线程 2 将 instance 引用返回给一个构造完整但部分初始化了的 Singleton 对象。 </li><li>线程 2 被线程 1 预占。</li><li>线程 1 通过运行 Singleton 对象的构造函数并将引用返回给它，来完成对该对象的初始化。</li></ol><p>为展示此事件的发生情况，假设代码行 instance =new Singleton(); 执行了下列伪代码：</p><p>mem = allocate();             //为单例对象分配内存空间.<br>instance = mem;               //注意，instance 引用现在是非空，但还未初始化<br>ctorSingleton(instance);    //为单例对象通过instance调用构造函数</p><p>这段伪代码不仅是可能的，而且是一些 JIT 编译器上真实发生的。执行的顺序是颠倒的，但鉴于当前的内存模型，这也是允许发生的。JIT 编译器的这一行为使双重检查锁定的问题只不过是一次学术实践而已。</p><p><strong>在JAVA2(以jdk1.2开始)以前对于实例字段是直接在主储区读写的</strong>，所以当一个线程对resource进行分配空间，初始化和调用构造方法时，可能在其它线程中分配空间动作可见了，而初始化和调用构造方法还没有完成。</p><p><strong>但是从JAVA2以后，JMM发生了根本的改变，分配空间，初始化，调用构造方法只会在线程的工作存储区完成，在没有向主存储区复制赋值时，其它线程绝对不可能见到这个过程。</strong>而这个字段复制到主存区的过程，更不会有分配空间后没有初始化或没有调用构造方法的可能。在JAVA中，一切都是按引用的值复制的。向主存储区同步其实就是把线程工作存储区的这个已经构造好的对象有压缩堆地址值COPY给主存储区的那个变量。这个过程对于其它线程,要么是resource为null，要么是完整的对象，绝对不会把一个已经分配空间却没有构造好的对象让其它线程可见。</p><p>《单例模式与双重检测》：<a href="http://www.iteye.com/topic/652440" target="_blank" rel="noopener">http://www.iteye.com/topic/652440</a></p></blockquote><p><strong>(3) 静态内部类</strong></p><p>为了做到真真的延迟加载，双重检测在Java中是行不通的，所以只能借助于另一类的类加载加延迟加载： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 外围类能直接访问内部类（不管是否是静态的）的私有变量</span></span><br><span class="line">       <span class="keyword">return</span> SingletonHolder.INSTANCE;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种比上面 1、2 都好一些，既实现了线程安全，又避免了同步带来的性能影响。利用了 classloader 的机制来保证初始化 instance 时只有一个线程，所以也是线程安全的，同时没有性能损耗。</p><p><strong>(4) 使用ThreadLocal修复双重检测</strong></p><p>借助于ThreadLocal，将临界资源（需要同步的资源）线程局部化，具体到本例就是将双重检测的第一层检测条件 if (instance == null) 转换为了线程局部范围内来作。这里的ThreadLocal也只是用作标示而已，用来标示每个线程是否已访问过，如果访问过，则不再需要走同步块，这样就提高了一定的效率。但是ThreadLocal在1.4以前的版本都较慢，但这与volatile相比却是安全的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal perThreadInstance = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton ; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (perThreadInstance.get() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 每个线程第一次都会调用  </span></span><br><span class="line">            createInstance();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">createInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        perThreadInstance.set(perThreadInstance);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、登记式单例-可忽略"><a href="#三、登记式单例-可忽略" class="headerlink" title="三、登记式单例(可忽略)"></a>三、登记式单例(可忽略)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似Spring里面的方法，将类名注册，下次从里面直接获取。  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Singleton&gt; map = <span class="keyword">new</span> HashMap&lt;String,Singleton&gt;();  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        Singleton single = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        map.put(single.getClass().getName(), single);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//保护的默认构造子  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="comment">//静态工厂方法，返还此类惟一的实例  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            name = Singleton.class.getName();  </span><br><span class="line">            System.out.println(<span class="string">"name == null"</span>+<span class="string">"---&gt;name="</span>+name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(map.get(name) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                map.put(name, (Singleton) Class.forName(name).newInstance());  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> map.get(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//一个示意性的商业方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">about</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, I am RegSingleton."</span>;      </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Singleton single3 = Singleton.newInstance(<span class="keyword">null</span>);  </span><br><span class="line">        System.out.println(single3.about());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个 Map（登记薄）中，对于已经登记过的实例，则从 Map 直接返回，对于没有登记的，则先登记，然后返回。</p><p>这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的 static 方法块，它的单例在类被装载的时候就被实例化了。</p><h2 id="四、饿汉式和懒汉式区别"><a href="#四、饿汉式和懒汉式区别" class="headerlink" title="四、饿汉式和懒汉式区别"></a>四、饿汉式和懒汉式区别</h2><p>从名字上来说，饿汉和懒汉，饿汉就是类一旦加载，就把单例初始化完成，保证 newInstance 的时候，单例是已经存在的了，而懒汉比较懒，只有当调用 newInstance 的时候，才会去初始化这个单例。</p><p>另外从以下两点再区分以下这两种方式：</p><p>1、线程安全：</p><p>饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，</p><p>懒汉式本身是非线程安全的，为了实现线程安全有几种写法，这三种实现在资源加载和性能方面有些区别。</p><p>2、资源加载和性能：</p><p>饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成；</p><p>而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;保证一个类只有一个实例，并且提供一个访可该实例的全局访问点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、饿汉式单例&quot;&gt;&lt;a href=&quot;#一、饿汉式单例&quot; class=&quot;headerlink&quot; title=&quot;一、饿汉式单例&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://gnbyj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://gnbyj.cn/tags/Java/"/>
    
      <category term="Singleton" scheme="http://gnbyj.cn/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>认知升级</title>
    <link href="http://gnbyj.cn/2018/07/18/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/%E8%AE%A4%E7%9F%A5%E5%8D%87%E7%BA%A7-%E6%88%90%E8%B4%A5%E5%8F%96%E5%86%B3%E4%BA%8E%E8%A7%81%E8%AF%86/"/>
    <id>http://gnbyj.cn/2018/07/18/自我管理/认知升级-成败取决于见识/</id>
    <published>2018-07-18T01:00:00.000Z</published>
    <updated>2018-07-18T01:06:12.273Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读吴军的《谷歌方法论》和《见识》，结合自己的理解分享一下里面的观点。一本书其实观点也就一页纸这么多，其他的内容都是在举例子证明这些观点。不同的人在不同的年龄段对书中观点的理解会不一样，因为观点的理解和自己的经历有关，经历和观点产生共鸣才能有所收获。所以我并没有把书中全部的观点总结出来，而是结合自己的经历来做一次分享。</p><h3 id="人生学会做减法"><a href="#人生学会做减法" class="headerlink" title="人生学会做减法"></a>人生学会做减法</h3><p><strong>生有涯，知无涯</strong>。如果做得事情不对，就算提高了效率也是徒劳，事情多效率也很难提升，所以人生要学会做减法，要学会少做事，甚至不做事，意思是自己要能识别重点做哪些事，哪些事可以不做，这些事不做天不会塌下来。因为如果把时间集中起来将事情做的比别人好，会带来十倍的收益。比如你在学习架构，可以花一个月的时间来系统化学习写一篇长篇文章，价值一定远大于你一晚上写出来的短文。人在工作中容易捡芝麻丢西瓜，喜欢做简单的事情，真正有创造性的工作做不来，捡几百个芝麻不如一个西瓜。我们需要能够跳出思维定式，换一个角度来判断一件事情的重要性，需要舍弃很多利益。能力晋升一个台阶，职责影响力增加一个数量级。大家可以思考下自己在工作中哪些是在捡芝麻，哪些是在做西瓜。</p><h3 id="幸福是目的，成功是手段"><a href="#幸福是目的，成功是手段" class="headerlink" title="幸福是目的，成功是手段"></a>幸福是目的，成功是手段</h3><p>幸福感的本源是基因的传承和影响力。还有三个具体的维度，第一个是爱情和婚姻，第二个是对未来的期望，明年比今年更好， 第三个是生活的态度。做到责任，荣誉，从容，优雅，镇定。</p><ul><li><strong>婚姻：</strong>人生最重要的投资是婚姻。巴菲特对女生择偶的建议是趁自己年轻找一个比自己更聪明的人嫁出去<strong>。</strong>这点我比较认同，就像同事说的嫁得好可以少奋斗二十年。</li><li><strong>影响力</strong>。一个人的影响力和河流一样由三个因素决定，分别是长度、深度和宽度。比如你在写技术文章有深度就会像河流一样绵绵流长。深度需要靠自己的修行和提升对世界的理解。宽度需要和志同道合的人一起共同做些事情。</li></ul><p><strong>社会分层</strong>。任何社会都是分层的，假如这个社会有100层，如何逆袭呢？做正确的事情，并付出比上层更多的努力，把注意力放在最该关注的位置，但是要承认能逆袭几层已经很不错了。</p><h3 id="浅谈见识"><a href="#浅谈见识" class="headerlink" title="浅谈见识"></a>浅谈见识</h3><p>一个人看问题和做事情的方法决定了他的命。比如某个投资人投资的方法是看这家公司是否有独一无二的价值，眼界低只能赚小钱。加盟一家公司也是一种投资，在工作中分配时间也是一种投资。</p><p><strong>我们和天才的差距</strong>。聪明是成就大事的必要条件，但是不是决定因素。爱因斯坦的三个优点是善于提出问题、善于想象并总结规律和有恒心。善于提问是一个很重要的能力，找到最重要的问题并解决就是一个非常大的突破。善于想象。不要被思维定势和身边人的约束。有恒心。最后的赢家不是跑得最快的，而是能坚持跑下来的人。比如并发网的活跃作者加多坚持每周写技术文章，这样的量变一定会引起质变。</p><p><strong>成败取决于见识，见识取决于环境</strong>。很多时候成败与否取决于见识的高低，而不是自己简单的努力。见识的高低，取决于我们的环境。我们觉得很大的东西放在更大的环境中显得渺小，放在历史长河中，不过是一瞬间。很多事情跳出自己的认知局限是可有可无的。要承认运气成分，时间是你的朋友，而时机不是，耐心是成功的第一要素，人在运气不好的时候，要慢下来思考，有耐心的做事。父母的见识和格局是孩子的第一起跑线。</p><h3 id="拒绝做伪工作者"><a href="#拒绝做伪工作者" class="headerlink" title="拒绝做伪工作者"></a>拒绝做伪工作者</h3><p>伪工作者是每天很忙，只会应付事务性工作，但是拿到的结果却很少，在竞争中处于下风。要分清工作和职业的区别，公司给了我们一份工作，完成了任务就是工作。职业是我们一辈子从事的事业，比如医生提升自己的医术，治病救人成为名医这是职业。所以绩效和工作有关，晋升和职业能力有关。</p><p><strong>效率的高度不是做了多少工作，而是完成了多少工作</strong>。有经验的员工善于找到最重要的工作，并优先完成他们，这正是新员工都欠缺的技能。重新梳理下工作，站在公司业务帮助最大的角度，站在提升自己能力的角度，把那些重要的工作找出来并完成他们。掌握的方法，做什么都是一流水平。</p><p>OKR谷歌的目标管理方法。可以给自己的工作制定OKR目标，可以找一个Excel来做OKR， 列分别是目标，关键结果，正常进度（得分和备注），落后于计划或修改的内容（得分和备注），已经完成（得分和备注）。</p><p>做好最后的1%。把事情做完美，世界上做的还算过去的人与前1%比可能差几步路，但是收入、社会地位和发展机会差距却很大，就是因为他们没有想把事情做完美。在谷歌强调以质取胜，做事达到“瑞士制造”的质量。</p><p>成功除了努力（10000小时练习），还依赖智商、运气和家庭环境。我觉得还依赖每个人认知的提高。</p><h3 id="大家的智慧"><a href="#大家的智慧" class="headerlink" title="大家的智慧"></a>大家的智慧</h3><p>吴军分析了一些大师的智慧。</p><p>莎士比亚的交友准则，第一个：凡事三思而行，不要想到什么就说什么。第二个是对人要和气。第三个是相知有素的朋友。人一辈子做事情不可能没有人帮忙。对所有朋友一直同仁的人，很难有至交，好的朋友是笔财富。</p><p>谷歌创始人佩奇经营管理的三个智慧。第一个是好的品牌产品首先功能好，其次是得到用户认可。第二个是从本质上寻找商业模式，比如互联网中<strong>连接比拥有更重要</strong>。第三个是薪尽相传，把目光往前看，努力寻找下一次机会，而不是守着自己的一亩三分地。</p><p>巴菲特的投资智慧。第一：不要做自己不懂的事情。第二个是不要做空股票。第三个是永远不要用杠杆投资。少犯错误比多几次成功重要。不要做一次输满盘输的事情。类比下自己时间的投资，不要把时间投资在自己不擅长领域，因为这样会收获甚微。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在读吴军的《谷歌方法论》和《见识》，结合自己的理解分享一下里面的观点。一本书其实观点也就一页纸这么多，其他的内容都是在举例子证明这些观点。不同的人在不同的年龄段对书中观点的理解会不一样，因为观点的理解和自己的经历有关，经历和观点产生共鸣才能有所收获。所以我并没有把书中全
      
    
    </summary>
    
      <category term="自我管理" scheme="http://gnbyj.cn/categories/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="认知" scheme="http://gnbyj.cn/tags/%E8%AE%A4%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>产品思维30讲</title>
    <link href="http://gnbyj.cn/2018/07/18/%E4%BA%A7%E5%93%81%E8%BF%90%E8%90%A5/%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B430%E8%AE%B2/"/>
    <id>http://gnbyj.cn/2018/07/18/产品运营/产品思维30讲/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2018-07-18T01:08:41.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="01-产品能力是每个人的底层能力"><a href="#01-产品能力是每个人的底层能力" class="headerlink" title="01 产品能力是每个人的底层能力"></a>01 产品能力是每个人的底层能力</h3><p>你好，欢迎来到《梁宁·产品思维30讲》。</p><p>我在IT和互联网行业工作了20多年，写过代码，做过销售，当过高管，创过业，卖过公司，也做过投资。如果问我做过这么多的事，最喜欢哪一样？我会说，做一个产品人，做产品。</p><p>为什么呢？</p><p>因为我觉得<strong>产品能力是人生的一个底层能力</strong>。拥有产品能力，能让你有一种踩在地上的自信和踏实感。我们大家都是从一无所有走过来的，我还记得那种茫然无措的感受，因为没有<strong>认知框架</strong>，所以每天面对着各种正面、负面的信息，任其冲击情绪，却不知道如何处置。<strong>这些信息到底什么重要，什么不重要，应该如何识别？</strong>同时，我们害怕自己的才华得不到赏识；自己努力了，却总是被diss；没有得到正面的反馈，得不到回报。还会有人自怨自艾，没有家庭背景，没干爹，没靠山。还好，在今天这个时代，如果让我给一个建议，那就是培养自己的产品能力。以上这些都不重要，<strong>产品能力会给你自信</strong>。</p><p>为什么呢？</p><p><strong>产品能力就是训练一个人：判断信息，抓住要点，整合有限的资源，把自己的价值打包成一个产品向世界交付，并且获得回报。</strong>别怕茫然，别怕被diss，别怕推倒重来。因为从一个普通人，到成为一个产品人的过程，其实就是<strong>一个人学习建立认知框架的过程</strong>，<strong>先建立信息的秩序，再建立自己内心的秩序。</strong>在一片纷杂里，你会知道<strong>自己该放弃哪些点，抓住哪个点，慢慢建立起掌控。</strong>这个过程里，你会碰到数不清的diss，被各种吐槽，被指着脸批评，还有数不清的推倒重来，这就是一个产品人生活的常态。丘吉尔说：<em>如果你到了地狱，那就继续保持前行。</em>产品的人生就是天天被打击。既然这就是生活的常态，放下担心，你会在打击中变得健壮。所以，你就会拥有产品人的一项<strong>基础能力</strong>：<strong>抗挫折、抗打击的能力。</strong></p><p>另外，别怕没有家庭背景，别怕没靠山、没干爹。</p><p>因为做一个产品人，我们只认一条“<strong>用户驱动</strong>”，从第一个用户走向第一桶金。今天，全球市值最高的7家公司，美国有微软、苹果、Google、Facebook，中国有腾讯、阿里、百度……这些企业，在他们刚开始的时候，没有矿产土地资源，没有高官权贵加持，就一帮年轻人，在租来的办公室，靠自己的大脑，靠自己的创造力，在互联网的空间里，“无中生有”地创造了以前没有的空间与体验，改变了我们的生活，也改变了世界的面貌。不到20年的时间，他们生长成当今世界上，拥有最多财富和社会影响力的个体。一无所有的年轻人，从一个用户开始，拿到人生的第一桶金，然后建立自己的世界。马化腾、马云、李彦宏、刘强东、王兴、李学凌、姚劲波等等，几乎都是这样从普通人，变成了行业大佬。</p><p>他们是怎么做到的呢？他们是如何拥有用户？如何建立“用户驱动”的呢？这就是我这套课程要讲的内容。</p><h4 id="产品思维，到底讲什么内容"><a href="#产品思维，到底讲什么内容" class="headerlink" title="产品思维，到底讲什么内容"></a>产品思维，到底讲什么内容</h4><p>我会用5大模块一共25讲：</p><ol><li>教你怎么看到用户、倾听用户、判断用户，怎么能够与用户建立连接，并且在用户的交互反馈中去迭代和优化；</li><li>教你怎么去观察，怎么判断；</li><li>如何建立一种系统能力，以此去向用户交付一种确定性；</li><li>如何建立交互能力，接着在不断的连接与迭代中，深化你和用户的关系。</li></ol><p>你可以说我这套课是讲产品的，你也可以说我这套课是讲人的，或者说，这套课是从产品的专业视角，来看人和人关系的，或者说，基于对人和人关系的感知，来讲怎么做产品的。都对！因为产品只是你用来服务用户的介质。随着科技会进步，产品会迭代，公司的形态、组织的形态都会发生变化。但是你最终要服务的对象，那个人，他未被满足的需求、人的心与人性并没有那么大变化。</p><p>感性一点说，通过这30讲，我希望帮助你拥有三个东西：</p><ol><li>第一是一双眼睛，是发现痛点、找到破局点的敏锐之眼；</li><li>第二是一双手，是动手优化、着手改变的行动之手；</li><li>第三是一颗心，是洞察人性的同理心，懂得自己，懂得用户，懂得一个产品上，每个细微的小点给到人的满足感、确认感和依赖感。</li></ol><h4 id="新年第一课，你能从这门课收获什么？"><a href="#新年第一课，你能从这门课收获什么？" class="headerlink" title="新年第一课，你能从这门课收获什么？"></a>新年第一课，你能从这门课收获什么？</h4><p>作为得到的新年第一课，<strong>我希望这门课能够帮到</strong>以下几类朋友：</p><ul><li>我希望这些课程能够帮到<strong>那些曾经像我一样茫然的年轻人</strong>。产品能力是动手能力、是掌控能力，希望通过这30讲的课程和练习，你能够到找到与现实世界真切连接的踏实感，知道如何分辨要点，找到抓手，建立掌控感，不再茫然和被动。</li><li>我希望这些课程能够帮到<strong>那些希望自己有一技之长，踏实地生活的人</strong>。相信自己的双手，相信自己的动手能力，比什么都踏实。</li><li>我希望这些课程能够帮到<strong>那些在世界上感到孤独的人</strong>。世界是如此的不可知、不确定，但是通过我们的系统能力，我们可以应对和消化这种不确定。为他人的生活中，提供一点小小的确定，一点小小的依赖，通过产品与人对话，与人连接，其实也是一种温暖。</li><li>我希望这些课程能够帮到<strong>那些立志优化这个世界，在这个世界上留下痕迹的人</strong>。</li></ul><p>世界如此精彩，我们当然不能置身局外。</p><p>很高兴在这一年的开始之际与你相遇。</p><p>希望这一年，世界在你眼前展开，希望一切清晰与分明起来。</p><p>愿你能够在这个不确定的世界，建立自己的确定性，并与人彼此依赖。</p><p>愿你向这个世界交付你的价值，并且获得回报。</p><p>谢谢，2018，我们一起加油。</p><h3 id="02-案例：用户体验与结婚教练"><a href="#02-案例：用户体验与结婚教练" class="headerlink" title="02 案例：用户体验与结婚教练"></a>02 案例：用户体验与结婚教练</h3><h4 id="用产品经理的视角来看人"><a href="#用产品经理的视角来看人" class="headerlink" title="用产品经理的视角来看人"></a>用产品经理的视角来看人</h4><p>今天我想讲一个结婚教练的故事。</p><p>她是我的一个朋友，现在做的工作就是指导30多岁下定决心要结婚的女生，如何能够在一年半之内搞定结婚。</p><p>她的方法已经帮助了30多个30多岁的女生完成了结婚。这个结婚教练以前是干什么的呢？她以前是一个互联网公司的产品经理。她的这一套结婚的体系内容挺多的，这堂课我想把她最重要的一个环节拿出来分享。</p><p>这个环节就是如何观察和判断一个人。因为结婚也好，创业找合伙人也罢，都是非常重要的长期关系。改变一个人，那是非常难的事情。<strong>在开始长期关系之前，如何有框架地去观察一个人，进行是否适配的判断，是更关键的</strong>。结婚教练，就是用产品经理的专业视角，来训练用户如何去看一个人。</p><p>因为任何一个人，任何一个产品，大家都会有自己的感受。但是如果没有经历过专业的训练，那么所有的感受是混杂的，是混沌的。你的情绪，一定会被你最有感觉的那个点牵制住，所以就<strong>会有强烈的认知偏差和情绪偏差</strong>，并且在你没有强烈感受的那些地方，还会有大面积的<strong>认知盲点和思维遮蔽</strong>。</p><p>产品经理则是有一个完整的框架体系来看一个产品，不管你的第一直觉是喜欢还是不喜欢，其实你都可以用这套框架，相对完整地度量你对一个人的认识到底有多少。</p><h4 id="人和产品的五个层次"><a href="#人和产品的五个层次" class="headerlink" title="人和产品的五个层次"></a>人和产品的五个层次</h4><p>下面我就简单介绍一下，如何用一个产品经理看产品的专业化方法，去指导一个女孩儿去判断她的相亲对象。其实，就是从外到内的五个层次，我来一一介绍一下。</p><p><strong>第一层——感知层</strong></p><p>一个产品，你拿到它，它设计的美不美，质感怎么样。</p><p>一个人，你看到他的第一眼，这个人的身材、相貌，说话什么口音，穿衣服怎么搭配，这个就是最外层的感知层。</p><p><strong>第二层——角色框架层</strong></p><p>角色是很重要的一个词，我们会专门在第一模块用一课的时间来讲。</p><p>简单来讲就是，我们每个人都生活在角色里，并且被角色驯化。比如说你遇到一个银行职员，一个军人，或者是一个公务员，你在和他打交道的时候，你就能明显看到他身上角色的痕迹。你在办公室和你的公司的同事交往，其实大家的相处首先就是角色的对接。我们谈什么内容，我们知道哪些东西，都会被你的角色所控制。所以，基于表面的感知，基于角色化的接触，都是非常浅层的关系。也就是说，咱们日常和人的接触多半都是浅层关系，因为大家上班都是基于角色在做彼此的交流。大家在接受各种服务，为你提供服务的那个人，其实也都是角色所设定好的沟通方式和交付内容，然后再与你进行沟通、交割和讨论。</p><p>如果你和别人在角色扮演里对接，你就会被牢牢地捆在设定的角色中。其实两个人只是角色的对接关系，是没有办法达到彼此的深入了解和深层关系的。什么是深层关系？那就要走到这个角色之下的下一层，第三层。</p><p>从第三层开始就是一个人的深层部分了。</p><p><strong>第三层——资源结构层</strong></p><p>它可能会包括了一个人的财富资源、人脉资源、精神资源，每个人其实都是不一样的。就是我们人生的历程，其实大概在很多时刻，很多人都会处在同一个角色里，比如说我们都曾经是学生，或者是说毕业刚工作的时候，我们都是小职员。但是接下来，因为每个人的资源不一样，大家的精神资源不一样，出身背景、家庭的人脉资源不一样等等。<strong>资源结构会推动每个人，去往不同的地方</strong>。我们可能都曾处在某一个角色中，但未来会进入到不同系统的不同角色中。所以其实到了资源结构的这个层面，好多姑娘已经不会观察，不会判断了。她会看一个人的外表、穿着，或者问一些非常表面化的问题，比如你存款有多少钱？你有房有车吗？如果用我们产品经理的专业术语，这个叫做只抓表面数据，这种用户研究行为其实是非常低级的。如果是只能抓表面数据的产品经理，肯定不可能成为一个优秀的产品经理。就好像是说一个女生，如果她只能基于一个人的感知层、角色层进行交流，或者基于表面数据的存款和房车去对一个人进行判断，那这个人也是没有办法和别人建立深度关系的。</p><p>一个人的内核，就是他的存在感在这个深度关系之外，再往下一层是什么？这个才是一个人真正的内核。下面还有两层，我把它放在一起讲。</p><p><strong>第四层是人的能力圈。</strong></p><p><strong>第五层是一个人的内核，就是他对自己存在感的定义。</strong></p><p>就是他对他自己为什么而存在，到底是怎么感知的。什么状态下，他的存在感得到了充分的满足？什么时候他让他不爽或者烦躁？<strong>存在感之于人就好像生存之于动物一样，是触发情绪和推动行动的开关。</strong></p><p>你观察一个动物，它的状态、情绪，其实都是关乎它的生存需求是不是被满足。狮子为什么要去咬长颈鹿，其实狮子也很吃力、很勉强，但是必须厮杀下去。因为饿，因为生存条件不满足，生存的需求在驱动它。如果它吃饱了，它才不这么费劲呢。所以一个人为什么奔波、焦虑、不安，机关算尽，上窜下跳？其实是因为他的存在感还没有被满足。动物其实只要生存条件满足，它就很愉快了。但是人和人又是不一样的。有的人只要能够在一段关系里，比如说我在一个家庭中，我在和我的爱人的关系中，只要我的存在感是清晰的，对方给了我足够的确认感，我就能够满足。其实很多女孩儿都是这样的。但是有的人，如果只能够在一段关系中找到自己的存在感，是远远不能满足自己的。他需要在职场、在行业中、在社会影响力中，看到自己的存在感，看到别人的重视。其实很多男人是这样的。所以，就像是生存在驱动动物奔波撕咬一样，对存在感的寻求，以及不安全感，也在驱动男人、女人思前想后、废寝忘食、找人找事找钱，去满足自己，去确认自己的存在感。动物其实是在奔波和厮打中强健了自己的肌肉，一个人是为了不断地强化自己的存在感，在左冲右突里扩充了自己的能力圈。</p><p>这就是我们刚才说的最内核是存在感，它的外面一层是能力圈。如果一个人的存在感满足了，其实他的能力圈就不会再扩充了。就好像说好多女人结了婚就不化妆了，男人满足了就不奋斗了是一样的。因为<strong>扩充能力圈其实是一件很痛苦的事情</strong>，你想狮子为了吃饭去杀长颈鹿，其实它挨打也是极其痛苦的。</p><p>五个层次，层层深入。</p><p>现在，我们再把一个人从外而内的五层再拎一遍。</p><p>最外层是感知层，是你看到的一个人的样子，他的相貌、举止、着装。其实当你看到这个人的时候，你要知道有一部分是天生的，有一部分其实是角色化的产物。</p><p>在感知层之内的第二层是角色框架层。</p><p>在角色框架层的再往里的第三层是资源结构层，资源不只是大家一般都会认为的人脉和财产，还包括了一个人的精神结构和他的精神资源。关于这个，我写过一篇文章，我把它整理成了彩蛋，会晚一点放出来，感兴趣的同学可以去看一下。</p><p>在这个资源结构层再往后的一层就是能力圈，在能力圈的里面就是这个人对自己存在感的感知。所以，如果你明确知道自己想成为一个什么样的存在，你就会不断地改变自己的能力圈，改变自己的资源，然后甚至改变自己外在的样子。比如说，在2005年，我同时认识了做豆瓣的阿北、做抓虾的徐易容和做校内网的王兴。其实当时你会发现这三个人很像，都是外表很斯文的文艺男青年，做的都是Web2.0的网站。十几年过去了，这三个人的能力圈和资源结构都发生了非常大的变化，他们的公司也成了完全不同的三个企业。王兴做了美团，徐易容从抓虾做了美丽说，再到现在在做HIGO，而阿北一直在做他的豆瓣，已经快14年了。如果你可以进入到这三个人的内心，你就会发现说，即使是在2005年，在他们外表看上去很像的时候，其实他们内心自己的存在感就是不一样的。</p><p>以上我简单介绍了如何用产品经理看产品的认知框架，一层一层地去观察和分析一个人。对于浅层关系，最表层的感知层就够了。就像你只是打算购买一个产品，那你只要看到最表层就够了。如果你只是想谈个恋爱，并不打算和任何一个人的命运去深入勾连，那你看到最表层也就够了。但是如果你追求的是深度关系和长期关系，那你需要看到的就绝不仅仅是表面上已经呈现出来的结果。</p><p>没有任何一个人是完美适配另一个人的成熟产品，你需要看到的是一个人能够持续让自己变化的内在的动力。然后在漫长的不确定的未来里，明确你们<strong>两个人是不是能够一起拥抱不确定，拥抱变化，在变化中变得成熟，彼此适配，其实这个才是更关键的东西</strong>。所以，如果你只是做用户，想短期关系、捡现成的，那你看到一个人的感知层和角色层就够了。但如果你是要结婚，你要投资一个人，或者你要选择和某个人成为长期的合伙人，那这个人对自己的存在感到底是一种什么样的自我设定和感知，他对自己的能力圈的建设和经营，他对自己的资源的建设和管理才是更重要的。</p><p>到这里，如何用产品经理看产品的认知框架来看一个人就基本上讲完了。</p><h4 id="乔布斯和他的三个女人"><a href="#乔布斯和他的三个女人" class="headerlink" title="乔布斯和他的三个女人"></a>乔布斯和他的三个女人</h4><p>因为我们讲到了用户体验和结婚，这两个话题连在一起，我就实在是忍不住想讲一讲我们产品经理的大神——乔布斯和他的三个女人的故事。</p><p>乔布斯的三个女人，第一个就是布伦南。布伦南17岁读高中的时候，就认识了乔布斯，两人分分合合大概5年。18岁，布伦南第一次怀孕，但是根据两个人当时的协议，她去做了流产。23岁，布伦南再次怀孕，就生下了乔布斯的第一个女儿丽萨。2005年，50岁的布伦南给乔布斯写信，希望乔布斯给她一些钱，乔布斯没理她。2009年，布伦南疾病缠身、穷困潦倒，借住在朋友家，她给乔布斯写邮件说：我病了3年，已经别无选择，我最后一次请求你，请考虑一下为我提供1万美金，帮我度过几个月的时间。2009年那个时候iPhone已经发布了，乔布斯再次封神，我们都对他崇拜得无以复加，这样的大神当天就回复，说：“我不会被要挟。”你听上去，这个回复感觉怎么样？</p><p>接着我们讲他第二个女人，他的第二个女人叫蒂娜。在人生最后的日子，乔布斯和自己的传记作者谈到蒂娜的时候，当时就潸然泪下，他说：她是我见过的最美的女人，她是我真正爱的第一个人，我们是那么的心意相通，我不知道谁还能比她更理解我。你要知道，那个时候其实他和他太太已经结婚二十多年了。当然，他是向蒂娜求过婚的，在1989年的时候，乔布斯向蒂娜求婚，她当时就拒绝了。她说：“爱上一个以自我为中心的人，这种痛苦令人难以置信。”蒂娜曾经在他们的卧室墙上写了一句话：“忽视是一种虐待。”乔布斯肯定觉得自己很爱蒂娜，但是蒂娜显然觉得用户体验实在太差了，没有办法坚持下去。当然你也可以说，其实蒂娜没有那么爱乔布斯。</p><p>第三个女人，其实就是我们都知道乔布斯的太太，劳伦•鲍威尔。劳伦她自己其实说过一句话：“他像激光那么专注，当他的光芒照耀到你身上，你就会沐浴着他的关爱。但是，当他的光芒转移到其他关注点的时候，你就会觉得人生非常黑暗。”我觉得她这句话其实很真实。因为她几乎是用另外一种方法解释了，蒂娜为什么要在墙上写“忽视是一种虐待”。但区别是什么？区别就是蒂娜没有办法忍受，而劳伦找到了消解这种体验的方法。并且她陪乔布斯27年，给了乔布斯稳定的情感支撑，陪乔布斯度过了重返苹果前后的那段很艰难的时日——与癌症作战的最后人生时光。</p><p>所以今天，当我们谈到这位乔布斯的遗孀时，我们更愿意谈，她继承了乔布斯100亿美元的遗产。但如果你听了第一个和第二个女人的故事，你是不是可以想一下，劳伦曾经经历过什么？她承受了什么？又消化了什么？这个女人本身是非常强大的。</p><h4 id="本讲小结"><a href="#本讲小结" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>今天，我们把一个人由表及里的五层讲了一遍，然后又顺便八卦了乔帮主的三个女人，由表及里的对乔帮主的不同体验和感受。这个时候，我们再想一想，你对人的这五层：</p><p><strong>感知层</strong>、<strong>角色层</strong>、<strong>资源层</strong>、<strong>能力圈</strong>和<strong>存在感</strong>。</p><p>你最在意哪一层，你最不能忍哪一层？如果在生命中，你遇到乔布斯，你能和这样的人长相厮守吗？给你个乔布斯你接得住吗？你要不要？八卦就讲完了，我自己非常开心，希望你也喜欢。</p><p>从下节课开始，我们进入正式的课程。</p><h3 id="模块一）-同理心"><a href="#模块一）-同理心" class="headerlink" title="模块一） 同理心"></a>模块一） 同理心</h3><h3 id="03-同理心训练：怎样理解愉悦与不爽"><a href="#03-同理心训练：怎样理解愉悦与不爽" class="headerlink" title="03 同理心训练：怎样理解愉悦与不爽"></a>03 同理心训练：怎样理解愉悦与不爽</h3><p>今天开始，我们进入到第一个模块，<strong>同理心</strong>。</p><p>我们的第一堂课为什么从情绪开始说起？如果把人想象成一部手机，情绪就是底层的操作系统，有的人是iOS，有的人是安卓，大家版本号都还不太一样。你后天学习的知识技能，都是安装在底层操作系统上的，一个一个的App。有人说：“学了很多道理，但还是过不好这一生。”其实我们后天学习的东西，都是理性，理性是把人往回拉的力量。但是驱动一个人的，其实是他的内在感受、他的情绪、他的底层操作系统。我们都会有情绪冲动的时候。你陷入爱情了，你被愤怒、被恐惧控制了，就好像手机系统崩溃了，所有的App全废了。你所有的后天学的知识、技能、理性都不能说服你。知识的调用需要时间和思考，情绪却是一瞬间的体验。</p><p>我们作为一个产品人，为什么要对情绪这么重视？因为用户是无法像专业的产品经理那样，分层次说出他的体验的，他能展现的就是用户情绪。所以我们从一开始，就要学会读懂用户情绪。</p><h4 id="生物性情绪"><a href="#生物性情绪" class="headerlink" title="生物性情绪"></a>生物性情绪</h4><p>怎么分析用户情绪？</p><p>我们从所有生物都一致的底层情绪——“生物性情绪”开始说。</p><p>所谓生物性情绪，就是所有的动物一出生就有的情绪，从你养的小猫小狗，到动物世界里的野生动物，再到咱们人类都有。</p><p>这一课和下一课，我们就来讲讲四种最基础的生物性情绪，他们分别是：</p><p><strong>愉悦、不爽、愤怒、恐惧</strong>。</p><p>今天这一课，我们先说愉悦和不爽这两个情绪。</p><p>在介绍这两种情绪前，我们必须先提出来一个很重要的词。我们的产品工作，以及我们很多的重要观察与洞察，几乎都是围绕这个词展开。这个很重要的词是什么？其实你早就非常熟悉了，这个词就是“<strong>满足</strong>”。</p><p>满足是一个非常重要的词，它也是你可以用来衡量很多东西的刻度：</p><ul><li>一个产品好不好</li><li>你和一个人的关系好不好</li><li>你对你自己的认识</li></ul><p>我们会在这节课的每一个层次里，依次展开这些话题。</p><h4 id="“满足”和“愉悦”的关系"><a href="#“满足”和“愉悦”的关系" class="headerlink" title="“满足”和“愉悦”的关系"></a>“满足”和“愉悦”的关系</h4><p>我们讲第一个情绪词——愉悦。</p><p>什么叫愉悦？</p><p>直接来说，<strong>愉悦就是被满足</strong>。我们知道，生物的本能就是生存，所以它的操作系统，驱动它一切行为，都是为了满足自己的生存。动物的生存条件被满足，比如，一只虫子，一只鸟，一只猫，温度、湿度适宜，有充足的食物，它就会愉悦。而我们人类，不单纯作为生物性的存在，更是社会性的存在。我们不仅需要生存条件被满足，我们还需要在社会关系中被确认。比如度假，住得舒适、吃好吃的，你会愉悦。读喜欢的书，精神上被满足，你会愉悦。你感受到别人的善意，自己被理解，自己被接纳，自己被尊重，自己被重视。这些都是存在感被满足，都会愉悦。</p><p><strong>需求被满足，这种感觉叫愉悦</strong>。</p><p>一种绷了很久的需求，突然间被满足了，这种感觉叫“爽”。大家肯定都玩过俄罗斯方块的游戏吧？下来一个你需要的形状，消掉一行，消掉两行，伴随着消除的音乐，这种感觉叫愉悦。你摞了很高一列，就等一个四格的长条，越等越危险，越等越焦灼。突然，长条下来了，一下子，四行消掉了，这种感觉叫爽。</p><p>拉动你玩游戏的，就是微小的愉悦感，和绷了很久的需求，突然被满足的爽感，加在一起，这种<strong>确定性的满足就会成瘾</strong>。</p><p><strong>微信红包和支付宝红包</strong></p><p>2015年春节，微信和春晚合作，摇一摇有红包，一举让微信支付的用户量过亿。除夕一晚，微信红包的用户量达到1.04亿人。摇一摇，摇红包的互动，一亿人摇了100亿次。送出微信红包1.2亿个，基本上人人有奖。看着别人摇到了红包，自己跟着也摇，摇了几十次，突然间得了一个红包。这感觉，就是爽。</p><p>2016年春节，阿里砸2.69亿元夺下猴年春晚的合作资格，推支付宝红包。阿里肯定不能和腾讯一样啊。阿里怎么干的呢？大家都记得，他干得是，集齐5福，分2亿现金。然后呢？我想你还有印象，一堆人都集了四福，差最后一个敬业福。数据：支付宝发出了82万多张敬业福。集齐五福的有多少呢？79万。如果去年微信红包有1亿人参加，就算参与支付宝活动的用户最少有2000万。如果照2000万用户参与抢支付宝红包，爽的人不到4%，不爽的人大于96%。这就叫有钱任性啊，花5个亿，让96%的人不爽。没关系，阿里爽就行。</p><p><strong>“不爽”与不“满足”</strong></p><p>既然说道了不爽这个词，我们就再把这种感受细致地说说。</p><p><strong>满足就愉悦，不满足就不爽。</strong></p><p>比如，一只虫子，本来温度适宜。突然，温度大幅提升，它就会瞬间不爽。动物是这样，人也如此。如果我没有满足预期，或者我本来在一个满足状态，突然被剥夺了，这也是不爽。而人类呢，用了一堆词来形容不爽的感觉。比如：生气、烦躁、痛苦、厌倦、悲伤、烦恼、茫然等等。但是本质上，这些不爽的感觉，都是某个点没有被满足。</p><p>做产品，是通过产品建立与人的关系，通过产品来服务人，本质就是用户是否通过你的服务得到了满足。</p><p>一个湖畔大学的工作人员和我说，她希望湖畔是一个人EMBA类学习的最后一站，上完了湖畔，就再也别去其他的商学院学习了。我说，这取决于对方内心是不是被满足。对于他是否被满足，你其实是没有办法的。</p><p><strong>满足是度量产品、人与人关系的刻度</strong></p><p>为什么开篇第一课要研究“<strong>满足</strong>”“<strong>愉悦</strong>”“<strong>不爽</strong>”这三个词？</p><p>因为就用这三个词，你可以<strong>度量一个产品到位不到位</strong>。</p><p>当你做一个产品，或者用一个产品，自己有没有被满足的感觉？你基本可以凭此判断，这是个非常好的产品，还是一个勉强的产品。你也可以度量，你和一个人的关系。对方是不是懂得你的满足与不爽，你是不是懂得对方的满足与不爽。如果彼此都不懂，又无法给予对方的满足和不爽，其实，这就是一段勉强的关系。</p><p>此外，你还可以用这三个词“满足”“愉悦”“不爽”来深入探索你自己，认识你自己。你就想想为什么每个人不一样？为什么让你照着PPT练习3次，你就会痛苦。而乔布斯为了苹果大会对着PPT练习100次，依然乐此不疲。为什么你打扫卫生很痛苦，而有人视打扫房间不厌其烦，一天扫三次？为什么同一个点上，有人痛苦，有人愉悦？所以，觉察一下自己，是不是有一件事，你可以不厌其烦地一直做下去？这就是上帝给你初始化的操作系统的密码，你不厌其烦的地方，就是你的天分所在。</p><h4 id="发现你天分的密码"><a href="#发现你天分的密码" class="headerlink" title="发现你天分的密码"></a>发现你天分的密码</h4><p>我们一般认为的天分是显性天分，比如长得漂亮、身体协调、唱歌好听、智商高。</p><p>其实还有一种天分，是隐性天分，他不会两三岁展现出来，让别人看得到。你会对某些东西感到愉悦，这个东西持续给你满足感，你可以一直花时间在这里，不厌其烦。时间久了，其实你就会与众不同。我们都知道天才的1万小时理论。问题来了，一个人为什么会在一件事上花一万小时呢？有些人是不得已。但是多半人，是在深入体验中，找到了满足，找到了愉悦感。持续的满足和愉悦，才能支撑一个人持续投入一万小时。</p><p>最后，我们再谈谈如何理解“满足”“愉悦”“不爽”这三个词，以及怎么通过这三个词，看到自己的天分，看到别人的天分。我们看到优秀的人才会有几个特性：<strong>敏感、不能忍、有动手优化的能力。</strong></p><p>比如，我妈是一个非常优秀的家庭主妇。她一到我住的地方，马上就尖叫：“你住的地方怎么这么乱啊。”——敏感。接着，她不能忍。她其实就在我这儿呆半天，但她不忍，她马上开始收拾。2、3个小时之后，家里顿时就桌明几亮，井井有条，水果洗了摆桌子上。她不能忍，马上就要动手优化。驱动我妈不能忍，马上动手优化的原因是：整洁让她愉悦，乱她就不爽。</p><p>驱动我妈收拾屋子，和乔布斯把一个图标改100遍的驱动力，其实没什么不同。乔布斯改来改去，朝同事发脾气，不是因为他要追求卓越，而是不改到让他满足，他就不爽。他因为极度不爽、不能忍才不停地改来改去。所以，你吸收谁的营养，你就变成谁。你靠什么满足你，你就会成为它的样子。</p><p><strong>什么东西持续满足你，什么东西永远让你不爽，这就是你的命运</strong>。</p><p><strong>本讲小结</strong></p><p>这一课，我们讲了三个重要的词：“满足”“愉悦”“不爽”。三个词很普通，但是我希望你能够发现很普通的词的深意：</p><ul><li>你可以量度，一个产品到位不到位；</li><li>你可以量度，你和一个人的关系；</li><li>你还可以看到，自己的天分和命运。</li></ul><p><strong>课后作业</strong></p><p>好，这一节课的最后，我给你留一个作业：</p><p>其实我们一开始就是讲情绪和感受，你需要体察自己的情绪和感受，并且做出判断。</p><p>我希望你能够再分享一下，你使用产品的真实体验：</p><ul><li><p>你觉得即使吹得天花乱坠，也用起来感受不好，很勉强的产品。</p></li><li><p>当然也欢迎你分享，你用起来很爽，每一点需求都能够得到满足的产品。</p></li></ul><p>非常欢迎把你的感受，在留言区跟我分享，谢谢。</p><h3 id="04-同理心训练：怎样理解愤怒与恐惧"><a href="#04-同理心训练：怎样理解愤怒与恐惧" class="headerlink" title="04 同理心训练：怎样理解愤怒与恐惧"></a>04 同理心训练：怎样理解愤怒与恐惧</h3><p>上一课我们讲了愉悦与难受。这一课我们讲愤怒和恐惧。就好像愉悦与难受是一对感觉，满足就愉悦，得不到满足就难受。愤怒和恐惧也是同生的一对感觉，都是来自于<strong>被侵犯</strong>。但是因为个体不同，对侵犯者的体量判断不同。所以，有时是愤怒，有时是恐惧。</p><h4 id="什么是愤怒？"><a href="#什么是愤怒？" class="headerlink" title="什么是愤怒？"></a>什么是愤怒？</h4><p>愤怒，就是感觉到自己的边界被侵犯。</p><p>动物都有自己的边界。我们都见过，一只狗、一只猫都会用尿液划定自己的领域。如果一只猫在自己划定的领域里，来了另外一只猫，自己的边界被侵犯，这只猫就会愤怒。</p><p>人的边界呢？就是自己的存在感的边界。比如职场上，一个人去抢另外一个人的工作，就是侵犯边界。比如两个女的，开车刮蹭，不一定愤怒。但是如果对方坐她老公大腿上，这个女的肯定就愤怒了，因为边界被侵犯。</p><h4 id="什么是恐惧？"><a href="#什么是恐惧？" class="headerlink" title="什么是恐惧？"></a>什么是恐惧？</h4><p>一只猫在自己的领域里，来了另外一只猫，边界被侵犯，这只猫就会愤怒。但如果来的不是另外一只猫，而是一只老虎，猫就不愤怒了，它会恐惧。</p><p>几个人要来拆你家房子，你可能是愤怒。但如果龙卷风来了，你就不愤怒了，你就恐惧了。</p><p>如果你仔细去分辨，不同的人，愤怒和恐惧的点也不一样。你会发现英雄人物，在常人会恐惧的点，他体现为愤怒。</p><p>比如，有人侵犯你，比如，被偷，被抢，被打。有人呈现愤怒，有人呈现恐惧。比如《勇敢的心》里的华莱士，面对苏格兰统治者的残酷，99%的人都恐惧了，而他是愤怒，所以他是英雄。所以，本质上，愤怒其实是一种恐惧。</p><p>焦虑呢？焦虑也是恐惧。它来自对恐惧的想象。因为是想象，所以无从逃避，所以是一种持续的恐惧，就会内化为焦虑。</p><p>羞耻感呢？羞耻感也是一种恐惧，它来自对社会评论的恐惧。这个我们会在下一课讲。</p><p>这一讲，我想和你认真地谈一下恐惧。为什么？<strong>因为恐惧很重要。是我们观察人和做产品，非常重要的点。</strong></p><p><strong>一、恐惧是边界</strong></p><p>看到火，你就不会伸手，因为有恐惧。看到风高浪大，你就不会出海，因为有恐惧。所以，恐惧会困住一个人的手脚。</p><p>两个朋友，约我去给一个很大的上市公司CEO去讲互联网，还说，如果可以，是不是可以一起帮他做战略规划什么的。我们聊了一下，我就放弃了。我和朋友说：帮这位大佬做互联网战略的这事，我做不了，你也做不了。因为他根本不是看不到互联网的重要和强大，而是他的恐惧，把他在现有的位置、现有的业务里捆的死死的。除非他能卸下恐惧。如果他能卸下恐惧，很多事，他自己就做了，因为他其实都懂。而能帮他卸下恐惧的人，既不是我，也不是你。所以呢？算了吧。这也是我在讲产品之前，要先讲同理心的原因。</p><p>当你很努力地想说服一个人，去做一件你看来非常正确的动作时，对方不动，不是道理他不懂，而是他内心有恐惧，但他不愿意告诉你。在我少不更事的时候，经常几小时几小时地劝别人干这干那。我劝过别人辞职，劝过人分手，劝过人转行，劝过人创业。我一直觉得自己道理讲的可对了，对方也全听明白了，但之后大家多半还是会选择在原地受苦。</p><p>后来，我明白了，劝人就5分钟。5分钟没说动的事，就不再劝了。而是应该想想，捆住他手脚的是什么。是什么把他压在那里，让他没办法往前走。所以，我看到有人在一个没啥前途的公司岗位上待着不辞职不转行，在一段没有爱的关系里呆着被折磨，而不离开，不是对方对她好，有承诺，而是对方抓住了她的恐惧。所以，知道道理，依然过不好这一生。</p><p>就像我上节课讲的，后天的知识技能道理逻辑都是一个一个的APP，而你内在的愉悦、恐惧才是操作系统。有时候你不是缺某个APP，而是你的操作系统，只能支撑你到这里了。</p><p>看到一个人的恐惧，你就基本上知道他的边界在哪里。很多人，我都知道他的恐惧是什么。但是，好像马云没有恐惧，罗振宇好像也没有恐惧。所以，暂时，我还看不到他们的边界。</p><p><strong>二、恐惧是动力</strong></p><p>我们第一节课说，愉悦和满足感会支撑一个人在一个地方投入一万个小时，从而使这个人成为天才。其实恐惧是另外一种动力。甚至比愉悦的动力更为强大，或者说更强劲。</p><p>有时候，你看到一个人兢兢业业，完全忽略自我的身体感受和家庭体验，一切以这件事为核心，彻底忘我。他是因为愉悦吗？很多时候，是因为恐惧。所以，面对一个年轻人，如果他在工作中，既没有愉悦，也没有恐惧。你基本上可以判断，他在这件事上，不会有什么成就。</p><p><strong>三、恐惧是痛点</strong></p><p>做产品就要抓痛点，我们都了解。但是什么是痛点？</p><p>很多人会把“难受”当痛点。生活中确实有很多不爽，我们已经说了很多词了，生气、烦躁、不爽、痛苦、厌倦、悲伤、烦恼、茫然。所以，要么做一个让人愉悦到爆爽的产品，要么做一个可以帮人抵御恐惧的产品。</p><p>如果做一个看上去可以某种程度帮人不再难受，而在“爽”和“恐惧”无所作为的产品，那就是一个不痛不痒的产品，也许也有人会买单，但绝不会大火。</p><p>每个人的痛点都是他的恐惧，恐惧是痛点。人们会为了解决恐惧，毫不犹豫地花钱。所以中国的医疗和教育，是最大的市场，为什么？对生存的恐惧。为什么医美产品比普通化妆品贵那么多？对青春流逝的恐惧。听罗辑思维、用得到，为什么啊？认知焦虑，还是恐惧嘛。</p><h4 id="本讲小结-1"><a href="#本讲小结-1" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结这节课的内容，就是如何找产品的接入点或者怎么改变自己的人生。</p><p>其实就是四个字：<strong>直面恐惧</strong>。</p><p>课后作业</p><p>我们需要体察自己的情绪，然后在这种情绪中看到产品的机会。</p><p>你可以分享一下：</p><p>你最近看到了什么样的产品，是在力图帮你抵御恐惧？</p><p>哪些产品对你的恐惧，解决得很好？</p><p>哪些产品是想解决你的恐惧问题，但其实效果很勉强？</p><p>欢迎你在留言区写下答案。</p><h3 id="05-同理心训练：产品要顺应用户潜意识"><a href="#05-同理心训练：产品要顺应用户潜意识" class="headerlink" title="05 同理心训练：产品要顺应用户潜意识"></a>05 同理心训练：产品要顺应用户潜意识</h3><p>这节课我们来讲<strong>潜意识</strong>、<strong>防御</strong>与<strong>说服</strong>。</p><p>三大产品经理做出了全世界最大的三个社交网络产品，他们分别是：</p><ul><li><p>做出了Facebook的扎克伯格</p></li><li><p>做出了QQ的马化腾</p></li><li><p>做出了微信的张小龙</p></li></ul><p>这三个人有一个共同点，就是性格内向、不爱社交。</p><p>为什么性格内向，甚至有社交障碍的人，却会做出亿万人依赖的社交产品？</p><h4 id="一次失败的用户调研"><a href="#一次失败的用户调研" class="headerlink" title="一次失败的用户调研"></a>一次失败的用户调研</h4><p>我先不回答这个问题，而是谈我的另外一个观察：大量沟通能力强、长袖善舞的人，比如优秀的销售人员、BD人员，很难成为优秀的产品经理，比如马云校长。</p><p>我给你讲一个沟通的场景。</p><p>我和同事曾经让一个原先做销售做得很优秀的女孩尝试做产品。这个女孩长得漂亮，沟通能力强，擅于在公司抢资源。她自己申请转行做产品经理。我们就让她试试。先让她拿着我们产品的交互稿，去跟几个抽样用户沟通，做她的第一次用户研究。我在之前讲到过，用户就是普通人，他们不会像产品经理一样，有一个思考框架，知道如何有层次地表达感受和体验。作为一个用户，他的表达是混沌的、完全没条理的。在这个女孩的沟通现场，大家乱糟糟地发言，有人讲自己的观察，有人讲自己的感受，有人讲自己的评判，有人讲自己的需要，有人说自己的请求和愿望，有人则直接开始讲故事。这个女生越听越觉得乱，最后终于忍不住了，说：“要不还是我先来给大家介绍一下，我们产品的设计想法。”于是她施展销售的说服功夫，把所有人都说服了。大家认为我们设计得很好，很有道理。于是用户沟通会友好地结束。</p><p>这是什么？这就是一次失败的用户调研。</p><h4 id="为什么用户会口是心非？"><a href="#为什么用户会口是心非？" class="headerlink" title="为什么用户会口是心非？"></a>为什么用户会口是心非？</h4><p>我再举一个正确的用户研究场景。</p><p>Sony准备推出Boomboxes音箱，他们召集了一些潜在的消费者，组成焦点小组，来讨论这个新产品应该是什么颜色：黑色还是黄色。经过这一组潜在购买者的讨论，每个人都认为消费者应该更倾向于黄色。这次会议后，组织者对小组成员表示了感谢，并告诉他们，在离开时，每个人可以免费带走一个Boomboxes音箱作为回报。他们可以在黄色和黑色之间任意挑选，结果每个人拿走的都是黑色音箱。</p><p>人为什么口是心非？用户研究到底要怎么做？</p><p>因为人会基于自身所处的角色、所在的场景和个人的认知判断，选择性地说一些他觉得正确的话。但是，我认为在这个场景中所谓“正确的话”，并不代表这个用户真实的选择。所以，如果我不是在公开的角色中，或特定的场景下，我回家自己看个影片、选个产品，还是会按照自己的真实需求来。</p><p>所以不要被言辞迷惑，而要想办法看到用户的真实选择。</p><h4 id="好销售和好产品经理的区别是什么"><a href="#好销售和好产品经理的区别是什么" class="headerlink" title="好销售和好产品经理的区别是什么"></a>好销售和好产品经理的区别是什么</h4><p>这也是为什么明明我的课是产品课，但是开篇的前五讲，完全不谈产品本身，而是讲情绪、讲潜意识、讲集体人格。</p><ul><li><p>体会各种人的情绪与潜意识；</p></li><li><p>不被一个人基于角色化交流而说出的言辞所迷惑；</p></li><li><p>看到人基于潜意识流露的真实选择。</p></li></ul><p>只有当你能做到以上几点，你才有了做一个好产品经理的开端。</p><p>一个好销售擅长的就是打破防御，因为任何一个人对销售人员一定是防御的。销售人员要充分调度自己可以呈现的所有资源：自己的外貌、仪态，产品包装、价格折扣。从用户意识层面，让用户认为自己获得了专业服务，而且赚了便宜。从用户潜意识层面，再抓住用户心理上小小的满足或不安，打破用户的防御，说服用户，促成用户的选择。这是一个好销售干的事。</p><p>一个好产品经理，则是根本不让用户启动防御。因为一个产品没有表情，没有声音，无法拉住用户的衣服苦苦哀求，甚至不能让用户多注视一会儿。一个产品如果引发用户启动意识，让用户思考，某种意义上，就是在推开用户。为什么？因为，意识即防御。</p><p>所有的思考，其实都会让你产生顾虑。你让用户思考，就是让用户戒备。一个不会说话的产品，根本没有消解戒备的机会，所以马化腾非常推崇的一本书叫《Don’t Make Me Think》，翻译成中文核心意思就是“别让我思考”。对用户防御的态度和敏感度，也是一个好销售和一个好产品经理的区别。你会发现好的销售人员都是有攻击性的。为什么呢？因为他的工作就是要突破别人的防御，他们对突破别人的防御是有成就感的。好的销售非常懂得在与人直接沟通中，如何适当地给对方压力，抓住对方意识与潜意识的抓手，说服对方。在这个过程里，他自己也会获得足够的快感和红利。</p><h4 id="产品是被动的艺术"><a href="#产品是被动的艺术" class="headerlink" title="产品是被动的艺术"></a>产品是被动的艺术</h4><p>但是像扎克伯格、马化腾和张小龙，他们为什么不爱社交？本质是因为在社交中，如果碰到别人对你建立防御的情况，你就手足无措。你不愿意突破别人的防御，也就没办法在社交中获得快感，长此以往就越来越不爱社交。快手的创始人宿华，其实也是这样。</p><p>这些优秀的产品经理退到网络背后，根据数据看到了人们在独处时，在没有压力的状况下，潜意识流露而做出的自然选择。他们对用户的行为不评判、不教育，最多就是柔性地引导，多半的时候只是默默响应和持续地服务。快手的宿华曾经说：“让产品自然生长，不要去碰用户，不要去打扰他们，让他们自然地形成一种互动关系。”这个说法有点玄，但是很真实。作为静态的产品，其实是没有机会说服用户的。所有让用户思考、琢磨一下的产品，其实都是给自己抬高门槛，降低转化率。</p><p><strong>一个产品要做到的就是迎合用户潜意识下的选择</strong>。所以我的一个朋友，烟酒营销大师李克，他说包装的经验，最核心的一条就是——规模感。明明是烟草新品，但是包装一定要让用户觉得很熟悉。<strong>熟悉的感觉就是潜意识里觉得安全的感觉，这样就不会触发防御。</strong></p><h4 id="潜意识是如何形成的"><a href="#潜意识是如何形成的" class="headerlink" title="潜意识是如何形成的"></a>潜意识是如何形成的</h4><p>说了这么多潜意识，潜意识是心理学里非常重要的词，有志于做产品的同学一定需要花时间去研究。这个产品课只能强调它的重要性，不展开讲。我们潜意识里已经存在的东西，是什么时候被放进我们的潜意识中去的呢？简单说，有两种情况。</p><p><strong>一种是在你童年的时候</strong></p><p>因为那个时候什么都不知道，还没有建立意识和防御去辨别。这时的观念就会直接进入你的潜意识，成为你最内在的感知、你本能情绪的一部分。所以为什么说要了解一个人，需要了解他的童年。你想了解一个人的关系模式，最好是了解他童年时与亲近的人之间的互动模式，这几乎就是一个人一生的模式。</p><p><strong>另外一种情况，是一个听上去很玄的词——催眠</strong></p><p>“催眠”这个词其实是来源自一个德语词汇，本意是“绕过防御”。但是让中国人一翻译，就搞得很玄乎。那催眠怎么做呢？本质就是绕过防御。讲催眠的书有一大堆，做产品的人应该系统地学学。微笑是一种催眠，因为它会让你放下防御。重复，是非常重要的催眠，这是我们生活中使用的最重要的方法。所以李开复讲，重要的话要讲30遍。比如雷军是个催眠大师。我们经常听说他劝人，能一劝8个小时、10个小时。从心理学来说，这其实也是一种催眠策略。这么高强度的疲劳战术，对方总有意识松懈的时候，只要一松懈，重复的想法瞬间就被植入他的潜意识中了。所以大家都说雷军给别人刷ROM的能力很强。另外，“送礼要送脑白金”，这种持续重复的广告也是催眠。一些社会观念无孔不入的传播也是催眠。</p><p>如果我们有共同童年，曾经在同一个单位里，在同一个文化场景中，被反复灌输一些观念，其实我们就被共同催眠了。我们会有相似的观念，被类似的观念束缚，有了共同的样子，这就是集体人格。比如湖南人有湖南人的样子，东北人有东北人的特点。从公司来讲，联想人有联想人的样子，腾讯人有腾讯人的特征，阿里人的特点又和这两家公司的人不一样。所以如果你为一个集体做产品，需要研究集体人格。</p><p>关于集体人格我们会在下节课具体介绍。</p><h4 id="本讲小结-2"><a href="#本讲小结-2" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结一下这堂课：</p><p>与人交往，或者做一个产品让别人用，怎么能够突破防御，让对方接受你，说服别人、驱动别人，其实都是一回事。人做一个动作，也许是意识判断，但是70%是潜意识的选择。</p><p>基于意识与人交流，其实是高防御模式。基于意识清醒的交流，达成交易的唯一方式，就是让对方清晰地感觉到一点——“我占了便宜”。小米手机重复性价比的宣传口径，是一个基于意识判断的沟通策略。但更多的时候，在意识没有启动之前，人已经基于潜意识建立了判断，并做出了行动准备。所以，如果你不能用持续高压灌输、高频重复的方法，改变对方的潜意识，那么就要放下自己的主观愿望和判断，放下显示自己高明、教育用户、说服用户的念头。</p><p>作为一个产品经理，要做的事就是不让用户启动防御。主观愿望过强的产品经理，非常容易犯想当然的错误。如果要做一个拥有大用户量的产品经理，你会看到的是“人欲即天理”，要尊重人欲。</p><p>所谓的用户调研，就是清空自己，接纳别人的世界观。</p><p>课后作业</p><p>在这节课的结尾，给你留一个作业：</p><p>你最近用到什么产品，几乎你是不加思考就完成了使用，使用过程感觉很熟悉、很自然？</p><p>你接触到了什么产品，乍一看觉得这个东西得琢磨一下，然后想了想就放弃了？</p><p>回忆一下，自己的潜意识里那些说服和防御的过程，在下面跟我分享一下。</p><h3 id="06-认清人的本性，理解角色化生存"><a href="#06-认清人的本性，理解角色化生存" class="headerlink" title="06 认清人的本性，理解角色化生存"></a>06 认清人的本性，理解角色化生存</h3><p>我养了五只寄居蟹。寄居蟹是一种外形又像螃蟹、又像虾，寄居在其他壳里的小螃蟹。像我这种做事特别认真的人，养个寄居蟹也得记日记。所以，我按照每一只寄居蟹的壳的形状，给它们分别起了名字。但我后来发现，养了它们这么久，我却根本不认识这几只寄居蟹，我只认识它们的壳。比如有一个白壳的寄居蟹死了，壳就留在缸里。过几天我发现，这个白壳又在缸里四处活动。原来是其他的寄居蟹钻进了这只壳里，顶着这个白壳继续生活了下去。我觉得这就像是皇帝死了，很快又有其他人穿上龙袍，坐在龙椅上，继续当皇帝。皇帝谁来当其实对于老百姓来讲都一样，我也不认识皇帝这个人，我只认识这个角色。</p><p>就好像生活中，你会认识一个张处长、一个李局长。但你其实根本就不认识这个人，你认识的只是他的壳、他的角色而已。所以，当你初步去接触一个人或者一群人时，你一开始看到的其实也只是他（们）的角色。就好像你看一只寄居蟹，你只看到它的壳一样。</p><h4 id="集体就是一堆角色"><a href="#集体就是一堆角色" class="headerlink" title="集体就是一堆角色"></a>集体就是一堆角色</h4><p>这节课我们讲的是集体人格，首先我们来讲什么是集体？</p><p>集体其实就是一堆角色。咱们从小的教育其实就是角色化教育，<strong>角色化教育的目的</strong>是什么？就是要训练你成为我需要的那个角色。你要成为好学生，好学生是个角色；你要成为好孩子，好孩子是个角色；好儿子是角色；好女儿也是角色。所以，为什么孔子对于中华民族是非常重要的人，因为他给我们整个民族都写了角色说明书：君君臣臣、父父子子、夫妇。两千多年以来，我们一直在用孔子定义的角色和角色关系来安放自己，来处理我们的关系。</p><p>你会发现中国人和外国人，在很多地方的心理预期是不一样的，比如对自我的感受、对关系的预期。为什么？因为角色说明书不一样。所以在角色里，你是什么样的人，你的感受是什么，这些是不重要的。重要的是，壳是什么样子的，角色要求你成为什么样子。当我们都被角色训练好，收敛自我，钻进一个同质化的壳里，我们就成为了一个集体。这群钻进了同质化壳里的人，就会呈现出来一种集体人格。</p><h4 id="集体人格是怎么形成的"><a href="#集体人格是怎么形成的" class="headerlink" title="集体人格是怎么形成的"></a>集体人格是怎么形成的</h4><p>集体人格是怎么形成的？我们是怎么被训练成为角色的？在回答这个问题之前，我先说说怎么得到一只听话的小狗。这个过程大概是这样的。</p><p>首先，你要给狗狗准备一个垫子。刚一开始它肯定是什么都不懂，在屋子里随便到处小便，这个时候你就要呵斥它。肯定会有一次，它偶然地做对了动作，尿在了垫子上，你就要立刻奖励、反馈——抚摸它、夸奖它、给吃的。然后不断重复，你就会得到一只在垫子上尿尿的狗了。</p><p>这其实也就是我们被教育的过程。这个过程我们稍微拆解一下，一共有五个关键动作：</p><ul><li><p>第一个，<strong>确定目标</strong>。</p><p>你要知道这一次教育或者培训的目标是什么，要树立一个什么样的观念。我们给狗狗的观念就是说不能随便尿尿，只能尿在垫子上。</p></li><li><p>第二个，<strong>建立恐惧的边界</strong>。</p><p>你需要让狗狗知道，它没有做被希望的事情就会被呵斥，甚至惩罚。这时候狗狗就会建立恐惧，它知道自己的行为会被惩罚。</p></li><li><p>第三个，<strong>放入清晰的标的</strong>。</p><p>正确的动作只有一个，就是在垫子上尿尿。</p></li><li><p>第四个，<strong>给予红利</strong>，然后让它产生路径依赖。</p><p>尿在垫子上就被奖励，听话的孩子就有糖吃。</p></li><li><p>第五个，<strong>不断重复</strong>。</p><p>重复是动作的关键，重复还可以树立榜样。</p></li></ul><p>于是，小狗就会产生角色化的行为，尿尿只尿在垫子上，因为不尿在垫子上就会被惩罚。</p><p>好，我们再来问，为什么要训练小狗，让一只狗狗产生只能尿在垫子上的观念？为了便于管理。也就是说，我们从小所受的教育，工作之后所受的培训，目的只有一个，就是为了便于被管理。如果说尿尿只能尿在垫子上是违反狗性的，那么其实<strong>教育是违反人性的</strong>。</p><h4 id="教育是反人性的"><a href="#教育是反人性的" class="headerlink" title="教育是反人性的"></a>教育是反人性的</h4><p>暴风影音的冯鑫给我们分享过他读《道德经》的心得。他用理工男擅长的归纳法，把《道德经》里所有的高频词全都数了一遍。《道德经》里出现最多的一个字，你猜是什么？是“反”，这个“反”字一共出现了12次。冯鑫说：“你看《道德经》是讲自然规律的，但是你认真读完以后，你会发现其中所讲的大量规律，与我们的认知是相反的。”我当然认同，其实教育就是反人性的。如果一个人没有被教育过，那他就是没有羞耻心的，就是懒惰的。但是我们为什么要受教育？教育是按照人类对社会的美好期望来教育你，换句话来讲，所有的教育都是理想化的。如果人本身就是这个样子，也就没必要教育了。</p><p>比如我们小时候看《梁祝》里那种至死不渝的爱情、《三国演义》里“刘关张结义”那种同生共死的友谊，你就会以为爱情、友谊就应该这样。在人世活了半生以后，你才会发现真实的人世间不这样，这样的友谊与爱情真是少之又少的小概率事件。所以这样的友谊和爱情才会成为传奇，才会被传颂。如果满地都是这样的友谊和爱情，大家就不传颂了。书读得越多的人越容易理想化，说得俗一点，就是不接地气。</p><h4 id="产品经理应该如何看待角色"><a href="#产品经理应该如何看待角色" class="headerlink" title="产品经理应该如何看待角色"></a>产品经理应该如何看待角色</h4><p>明明这是产品课，为什么要谈角色化和集体人格呢？</p><p>我经常遇到一些很初级的产品经理，讨论过程中他们特别喜欢用一个词：“应该”。他们认为用户应该这么做。</p><p>比如一个母亲就应该如何，她就应该具备某种能力、某些认知，因此她选择时的权重次序就应该是这样。但你凭什么这么认为？母亲其实只是一个角色。只有在很大的压力下，人才会按照角色行事。一个人忙了一天回到家，坐在沙发上，掏出手机想休息一会儿的时候，凭什么你认为她“应该”继续完成角色，并且按照角色的设定点点戳戳你的产品呢？</p><p>我补充正反两个例子：</p><p>第一个，举一个正面例子。</p><p>微信之父张小龙认为：“<strong>好的用户体验，目标就是做到自然。</strong>”</p><p>什么叫自然？自然和角色化是相反的两个词。</p><p>举个例子，3岁的小孩用iPhone就很容易上手。比如iPhone的开锁，小孩不用学就会用，因为触摸是人的天性。小孩是看不懂文字的，但是他知道触摸、滑动，通过iPhone上的箭头一滑就解锁了。再比如用手一撑图片就放大了，这个不需要教，小孩天生就会。这就叫自然。</p><p>第二个，再举一个反例。</p><p>我有一个女性朋友，她在外企工作，在职场上非常优秀，但是她在谈恋爱的时候老是有问题。我跟她沟通以后就发现，她对男友或者丈夫，有太过于刻板的角色化预期。她喜欢上班，因为上班的时候是角色化的对接，所有人该如何对接、如何预期、如何反馈，这些都很清晰。但是下了班回到生活中，该如何与生活中的人相处、有什么样预期和反馈，她就不明白了。她觉得她的男友或者丈夫，为什么老是不能够按照自己的预期去行动呢？但对方凭什么按照你的预期去行动？</p><p>这个问题和产品经理新手遇到的问题是一样的。他们已经习惯了角色化思考，放弃了对一个真实、完整、鲜活的人的观察和接纳。人其实只有在压力非常大的情况下，才会去扮演角色。除非你能给他的压力非常到位，否则就不要对他做角色化预期。</p><p>如果你是想做一个能让用户放松使用的产品，或者你想和一个人拥有轻松惬意的亲密关系，那你为什么要给对方那么大压力，让对方来扮演你所期望的角色呢？所以，基于角色化预期其实很难和人互动。不管是在生活中真实地与人互动，还是通过一个产品与人互动，你都很难基于角色化预期做到。</p><h4 id="集体人格"><a href="#集体人格" class="headerlink" title="集体人格"></a>集体人格</h4><p>再来谈集体人格问题。</p><p>有一次和钉钉App的产品经理交流，我就说钉钉反人性。他回答：“对，因为我们是给一个集体做产品，集体人格就是反人性的。”他说得好有道理，我竟无言以对。</p><p>如果你的产品的使用对象是一个“个体”，那你必须要抛开对个体角色化的刻板想象，而把对方当成一个完整的、鲜活的人，去做用户研究。但是如果你是在给一个特定的集体做产品，那么其实你应该充分研究这个集体的集体人格、共同记忆和核心观念。</p><p>举一个最简单的例子。小米拍了一个广告片叫《100个梦想赞助人》，大概就是讲前100个小米粉丝的故事。广告片播放的时候，小米的几个合伙人热泪盈眶，但我坐在旁边就很尴尬。因为我完全不知道它在说什么，我没有这个片子传递的记忆，我也不知道这个片字传递的观念是什么。这个产品其实是精准地投放给属于这个集体的人。因为我不属于这个集体，所以我是个无效用户。</p><h4 id="本讲小结-3"><a href="#本讲小结-3" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>这节课就到这里，总结一下：</p><p>人是因为训练和压力才成为角色的，而集体就是角色的聚集。</p><p>如果你想做一个好的产品经理，那么首先要学习的就是通过“去角色化”来研究真实的用户，而不是用一堆“应该”来臆测用户的行为。</p><p>如果你希望用户在很放松的情况下，毫无压力地、自然地使用你的产品，或者你想找到在生活中可以放松惬意相处的伴侣，那么你就要放弃对人的理想化、角色化预期，去认识并接纳那个在“寄居蟹的壳”下面真实的人。角色化生存就是我们真实的生存处境，但是只有去角色化地认识、沟通、交互，你才能够得到真正的感情。</p><p>课后作业</p><p>角色化生存，基本上是我们现代人生存的真实情况，既是方便，也是痛点。</p><p>1.你觉得自己是不是擅长角色化生存，或者擅长把别人训练成角色呢？</p><p>2.你能够去角色化地和别人建立真实的交流吗？</p><p>欢迎分享你的故事。</p><h3 id="07-自我与自律，哪一种更贴近产品精神"><a href="#07-自我与自律，哪一种更贴近产品精神" class="headerlink" title="07 自我与自律，哪一种更贴近产品精神"></a>07 自我与自律，哪一种更贴近产品精神</h3><p>这是第一模块的最后一讲。我们之前用了四讲来讲怎么观察别人，这一讲我们回到自己。</p><p>良好的产品思维是今天最稀缺的职业能力。那么，具有什么天赋的人，最适合做产品经理呢？</p><p>我一直在思考这个问题，但久久没有找到合适的答案。没想到，我竟然在自己学绘画的过程中得到了启发。这个发现，要归功于我学绘画用的一本书——《五天学会绘画》。这本书不仅帮我在短期内提升了绘画水平，而且让我发现了一位优秀的产品经理和其他的管理者，在思维方式方面的最大差异。</p><p>我的结论是——做产品经理的人善于感知，能在已经有结论的地方建立新观点。而做其他管理地人更善于逻辑推理和总结归纳。</p><p>有一种流行的说法，把善于观察、发散的思维叫做右脑思维，把善于逻辑归纳的思维叫做左脑思维。其实学界已经证明，人的左右脑管辖区域并没有那么明显的区分，但这两个概念已经被人熟知。《五天学会绘画》这本书里也用了这样的说法，为了便于理解，本讲下文且用“右脑”代指擅长观察发散的思维方式，“左脑”代指逻辑归纳的思维方式。从学绘画中，理解两种思维我先介绍一下这本书的核心内容。</p><p>《五天学会绘画》首先抛出了一个问题：随着年龄的增长，人的手做精细动作的能力越来越强。但是，为什么一般人的绘画能力，却停留在孩子的水平？作者的解答是：因为9岁之后，大部分孩子的时间被学校的系统训练占得满满的，而学校的教育一般只开发左脑，训练我们的判断、逻辑、效率等能力。所以9岁之后，我们的认知就被左脑主导了。左脑指导我们把握要点，快速概括。</p><p>《五天学会绘画》的解决方法是：不要去画你认为自己看到的东西，那只是你左脑的判断。具体怎么做？书中给出的训练方法就是——想办法绕开左脑。</p><h4 id="怎么绕开左脑呢？"><a href="#怎么绕开左脑呢？" class="headerlink" title="怎么绕开左脑呢？"></a>怎么绕开左脑呢？</h4><p>画画的时候，不要急着用线条概括你要画的主体，而是要描绘主体和背景之间的边线。然后，你会发现所有物体的边线都是共享的。如果你要画一个放在桌子上的杯子，那就忘掉杯子本身，去描摹杯子和桌子交界处的边线。因为杯子的边线，也是桌子的边线。看起来是你一直在画桌子的部分，但其实空出来的地方就是那个杯子。这样你能得到的画面，会比直接画一个杯子拥有更丰富的细节。</p><p>把这个方法迁移到我们的思考习惯中，当你积极用左脑思考时，学校训练的知识、效率、时间观念等，会从你的潜意识中冒出来。你按这种思路画出的东西，一定不是你能最大化观察到、感受到的，而是左脑认为效率最高的。所以用《五天学会绘画》的逻辑来推论：</p><ul><li><p>被认为算“左脑思维”的人逻辑推理能力强、时间观念强，同时感受力差；因为感受力差，所以没那么敏感和情绪化，整个人体现为情绪稳定，甚至刻板；更容易根据规则调适自己，更自律，更容易角色化。</p></li><li><p>而被认为算作“右脑思维”的人，就正好相反，感受力强；能在别人已经有结论的地方，建立自己的新观察，并且不太喜欢听已有的逻辑；难以控制自己的情绪，能激情地表达自己，具有人格魅力。</p><p>这些人还有一个特点是时间观念差，比如开会原本预计一个小时，激情上来了，可能变成4个小时，把后面的事都耽误了。这样的人非常自我，也因此会非常自私。</p></li></ul><h4 id="自我的人更适合做产品"><a href="#自我的人更适合做产品" class="headerlink" title="自我的人更适合做产品"></a>自我的人更适合做产品</h4><p>这两类人，哪类人适合做产品经理？</p><p>答案是，自我的人更适合做产品经理。因为创造力是自我的延伸，而控制力是自律的延伸。创造力要求对自我有极深的体察和释放，但控制力是自律的体现，是社会化的产物，是对别人的体谅与迁就。人长期关注什么，就会认为什么东西更重要。自我的人长期关注的就是自己，所以必然自私；自律的人，长期关注的是外部的边界和规则，所以这类人有克己奉公的精神。一种人更关注我喜欢什么，而另一种人更关注什么是对的。</p><p>比如说，联想培养的人是自律的人，腾讯更能够容纳自我的人。我曾给不同的企业推荐过几个很优秀的腾讯产品经理，对方的评价都是：这个人太自我了，对自己考虑得太多，没办法用。我心里默默想，你们为什么不深思一下，为什么你们觉得没办法用的人，腾讯可以用。</p><p>还有一个问题，为什么优秀的女性产品经理很少？其实本质原因是相同的。我们上一节讲了集体人格，女性也是一种集体人格。所有的社会观念在潜移默化地要求女性，说女性应该是隐忍的、体谅的、照顾他人感受的。在这种集体人格的塑造下，女性很难去为难别人，容易觉得过意不去。</p><p>自我并且自私的人天然没有这种障碍。我曾与一个很优秀的产品经理一起协作。他要挑一张App的开机图，图片闪现时间其实不到1秒。他挑了100多张图都不满意，最后挑到设计师无法忍受，提出了辞职。当我告诉他，和他配合的设计师要辞职时，他的第一反应是：“新的设计师什么时候到？得接着改。”一个优秀的产品经理，比如乔布斯，会把他的设计师和工程人员逼疯，会把对方骂得死去活来。这么做是因为乔布斯真的受不了，但他根本不关心与自己合作的人是死是活。</p><p>刚才我们说的产品经理的特点——感受力强、暴躁、情绪化、无时间观念、自我、自私……乔布斯每条都符合。所以，一个优秀的产品经理，有可能是一个在工作集体中或者生活中让你觉得非常讨厌的人。</p><h4 id="找到自己，接纳他人"><a href="#找到自己，接纳他人" class="headerlink" title="找到自己，接纳他人"></a>找到自己，接纳他人</h4><p>说到这里，可能会有人问：我应该自我呢？还是应该自律呢？</p><p>当你问出这个问题的时候，本质上你关注的就是规则与边界，其实你就是个挺自律的人。但是，我们可能每个人都是在这种自律的、集体主义的氛围中长大。所以即使再自我的人，可能都得有一部分学会自律。你可能还会问：未来我应该释放哪一方面的能力呢？</p><p>找到你自己的愉悦或者恐惧吧。</p><p>靠愉悦驱动的人，往往自我。</p><p>靠恐惧驱动的人，往往自律。</p><p>这两者，都会催生非常优秀、非常成功的人。</p><p>每个希望成大事的人，都需要想办法接纳与自己完全相反的那个人，让他成为你亲密的合作伙伴。</p><h4 id="模块小结"><a href="#模块小结" class="headerlink" title="模块小结"></a>模块小结</h4><p>到这里，第一模块——同理心，就讲完了。</p><p>我们内在的愉悦、恐惧、潜意识与集体人格，共同形成了我们自己。当你要认识一个人，或者要做一个产品时，你要思考自己到底要在哪个层面下功夫？你还是要回到自己的内心，看到自己的愉悦与恐惧，看到自己的天分，看到用户的愉悦与恐惧，了解他们的潜意识和集体人格，不要触发他们的防御。这就是你的起点。</p><p>从这个起点开始，我们要进入第二模块：机会判断。第二模块的第一节课，从一个点开始——点线面体的战略选择。</p><p><strong>课后作业</strong></p><p>1.你觉得你是一个更加偏自我，还是一个更加偏自律的人呢？</p><p>2.你有没有过与“和你完全相反的人”合作的经历？如果有，你们是怎么相处的？</p><p>除了回答以上的问题之外，如果你有任何关于产品的问题，欢迎你在留言区分享。</p><h3 id="模块二）-机会判断"><a href="#模块二）-机会判断" class="headerlink" title="模块二） 机会判断"></a>模块二） 机会判断</h3><h3 id="08-机会判断：点线面体的战略选择"><a href="#08-机会判断：点线面体的战略选择" class="headerlink" title="08 机会判断：点线面体的战略选择"></a>08 机会判断：点线面体的战略选择</h3><p>这一课，我们开始进入第二模块——机会判断。</p><p>本模块第一节，我讲一个非常重要的战略判断框架。这是一个非常简洁的思考结构，叫<strong>点线面体</strong>。</p><p>点线面体是曾鸣教授的理论，他在得到App的课程《智能商业20讲》中做了阐述。我也从曾鸣教授这个新型的定位方法中收益良多。我和他说要在我的产品课里，把我的理解再讲讲，获得了他的授权。</p><h4 id="富人与穷人的区别"><a href="#富人与穷人的区别" class="headerlink" title="富人与穷人的区别"></a>富人与穷人的区别</h4><p>有句老话说：男怕入错行，女怕嫁错郎。说的就是怕选错。</p><p>举个例子，有一对双胞胎，在2010年一起大学毕业，一个加入腾讯，一个进入报社。7年之后，去腾讯的那位已经是年薪百万，而且满街都是挖他的猎头。投资人也在挖他，只要出来创业就给钱。去报社的那位，因为报社沉沦了，他曾经寄托理想的整个产业都没有了，一切都需要重来。</p><p>这里不是说双胞胎的素质或者能力有多大差异，也不是说他们分别跟随的领导的能力或者个人操守有问题。核心问题是这两个单位所附着的经济体，一个在快速崛起，一个在快速崩溃。这就是我们要谈的点线面体。</p><p>其实我们都有体会，努力工作的工资收益，远远不如2013年以前买了腾讯的股票，或者2010年以前买了北上广的房子。为什么？<strong>因为你再努力工作，你还是一个点。一个月或一年的工资，只是一个点的努力成果。</strong>但是腾讯股票与北上广房子的收益，是因为这个点附着于一个快速崛起的经济体，这是一个线性周期的结果。对于做投资来说，<strong>你需要首先选择某个正在崛起的大型经济体，接着去找一个领域，投它的成长周期。</strong>所以你会发现很多投资人，会投资一个赛道上所有的产业。为什么呢？因为他不赌单点，而是整个周期的收益。比如金砖四国的概念，是高盛公司包装出来的投资概念。他们要寻觅大型经济体的崛起，再从这种大型经济体里找到自己的位置。</p><p>所以，普通人和富人的区别是什么？</p><p><strong>普通人勤恳努力、斤斤计较，他在意的是每一个当下的点，而任何一个点都不会产生过多的收益。</strong>如果要成为中产，至少要获得一次线性周期的收益。比如持有腾讯股票10年，什么都不用干，10万变1000万。<strong>那么成为富人呢？就要借助面和体的崛起。</strong>当你选择要做一个产品的时候，你不但要投入自己的时间和资源，还要“忽悠”更多人，把他们的时间和资源一起投入进来，这也是说你要为更多的人负责。你在做选择的时候，要看到你切入的点是在一条什么样的线上，这条线在一个什么样的面上，以及这个面又处于一个什么样的体上。你面对的是什么竞争，是来自对手的竞争？还是来自趋势的竞争？所以，<strong>点线面体的战略选择非常重要。你再怎么优化产品、提升效率，一旦点线面体选错了，都是白搭。</strong></p><h4 id="安全市场的两次颠覆"><a href="#安全市场的两次颠覆" class="headerlink" title="安全市场的两次颠覆"></a>安全市场的两次颠覆</h4><p>我会用两节课来谈这个概念。这一节课，时间会比较长，我要讲一个横跨大约二十年的故事。</p><p>今天我们都知道，360是互联网安全的企业。但是上世纪90年代，还没有互联网安全的概念，当然也没有360。那个时候，这个市场叫杀毒软件市场。更早的时候，还不是软件，而是硬件——防病毒卡。</p><p>1991年，瑞星公司成立，开始做防病毒卡。1993年的时候，瑞星成为这个市场的老大。1994年，江民公司成立，做出了旗帜性的KV100杀病毒软件。</p><p>1995年，瑞星创始人王莘生病了，瑞星公司群龙无首、业绩下滑，而江民杀毒软件开始在中关村崛起。</p><p>1998年，康复归来的王莘重返中关村，当时江民已经占了杀毒软件市场的80%。这时候王莘就用了一招，以超低价格，对硬件厂商捆绑销售瑞星杀毒软件。当时一套正版杀毒软件零售价格应该在100元左右，而瑞星以低于10元的超低价，向联想、方正等电脑厂商供货，让出厂的电脑自带瑞星的杀毒软件。王莘归来一年后，瑞星在媒体宣布重获计算机安全市场占有率第一，并且此后当了很多年老大。瑞星在巅峰的时候，年收入7亿，净利润3亿多。这个市场太肥了。</p><p>2001年，雷军的金山也推出了金山毒霸，进了这个市场。这三家公司的产品，瑞星、江民和金山，其实都是同维度的点，持续了好几年，用按件付费的方式打来打去。</p><p>2006年7月，周鸿祎进场了。奇虎公司推出了360安全卫士，赠送卡巴斯基杀毒软件半年使用权。同年12月，腾讯公司也推出QQ医生。至此，今天重要的网络安全主角就全部入场了。</p><p>2008年，360发起了向瑞星所代表的传统杀毒企业的进攻，可以说是以互联网思维进攻、颠覆传统产业的发端。以后，几乎所有的互联网企业打击传统企业都是这么干的。</p><p>我来说一下当时几方的实力状况。2007年，瑞星的年营业额7亿人民币，利润是3亿，公司有充足的现金面对战争。2008年，周鸿祎开始发动进攻。而2005年才成立的360公司，在那个时间刚刚完成了两轮融资，一共募到两轮合计4500万美元，约3亿人民币。所以在2008年，周鸿祎打这一仗的时候，无论是现金、技术积累，还是人才储备都不如瑞星。前面说过，1998年，瑞星通过低价OEM切入PC大厂的用户网络，快速超越当时市场覆盖率80%的江民，夺回安全软件市场占有率第一。10年之后，2008年，周鸿祎发动新一轮进攻的前两个动作，与当年王莘曾用过的招数如出一辙。王莘低价，周鸿祎免费。王莘借助PC大厂的用户，完成用户积累。周鸿祎则选择了一个更为广大的用户渠道，就是已经拥有3亿网民的互联网，背后是PC互联网崛起的这个面。</p><p>为什么这场战役里，有7亿现金的瑞星会输？其实瑞星是输在产品的战略结构上了。这就是我们今天要谈的点线面体。瑞星赢了江民，它是用一个点赢了另外一个点，但之后的十年时间，它依然只是一个点，没有发生变化。而360通过免费策略，快速获得用户，短时间内超越瑞星成为用户量第一的网络安全服务商，就好像当年瑞星超过江民一样。</p><h4 id="360如何由点到面"><a href="#360如何由点到面" class="headerlink" title="360如何由点到面"></a>360如何由点到面</h4><p>360在第一个点砸实之后，迅速扩张成了一个面。</p><p>2008年3月，360启用360.cn的域名，将360安全产品，升级为安全平台。同时，推出360安全浏览器，向使用360免费杀毒的用户推广。这时候，浏览器就可以通过工具栏广告、内置广告、搜索分成等方式获得商业收入。浏览器之后，360又展开了网站导航、软件下载、手机App分发等众多服务。360从一个免费安全的点入手，快速变成了一个安全平台，接着变成流量分发平台。这就是360的三级火箭策略。2010年1月18日，360杀毒用户规模突破1亿。其实，2010年360的收入为5379万美元，折合人民币约3.6亿。大约为瑞星巅峰时期年收入的50%。换言之，360拿下了整个杀毒市场的时候，整个市场产生的利润，不到旧市场中大户利润的一半。这就叫改朝换代。</p><p>我在回顾这段往事的时候，突然意识到，2008年，周鸿祎通过打这一仗，一举拿下了这个利润丰厚的市场里的绝对地位。这距离他1998年开始创业，已经过了11个年头了。其实所谓的创业维艰，真的是一身英雄胆，却无处安放。所以，我能理解为什么2010年，估值4亿美元的360，会挥刀冲向估值400亿美元的腾讯，打了一场互联网历史上最有名的3Q大战。因为当时腾讯是互联网的“恐怖大魔王”，几乎是腾讯之下寸草不生。你想想，老周干了11年，才拿下一块对他来讲算是真正战略根据地的江山。消停了才1年，腾讯就大兵压境，搁谁也得拼命。当然，3Q大战同时成就了360和腾讯。一仗之后，腾讯推出了开放平台，并改变了公司的生态策略。到了2010年，腾讯市值400亿美元，今天已经是3000亿美元了。360用户与收入都大增，并且第二年在美国纽交所上市。</p><h4 id="移动互联网的趋势"><a href="#移动互联网的趋势" class="headerlink" title="移动互联网的趋势"></a>移动互联网的趋势</h4><p>所有熟悉老周的人，都知道老周是有搜索情结的。所以，2011年360上市成功，有钱了，周鸿祎亲自带队憋大招——再做搜索。2010年3Q大战时，马化腾曾接受采访称：“周鸿祎要我们投资他，就像微软投资Facebook一样。周鸿祎还说要联合我们打百度，把搜索流量卖给我们。他会出一个拦截百度的东西，先攻击百度的医疗广告。”马化腾讲话的真假暂且不论，这里其实透露出的重要信息是：360一直在观察百度的弱点，以及一直在寻找向百度发起进攻的时机。要知道，老周那个时候就知道，百度的医疗广告是百度的命门。那个时间点，比魏泽西事件爆出来，至少早了6年。当面要打架的时候，点就有机会。面一定会给点让度最大的利益。老周挂帅做搜索的时候，一个百度员工告诉腾讯科技，当时为了应对360的挖角，他所在部门的几位核心员工都获得了一定程度的涨薪。更让他震惊的是，有几个特别聪明的人，在百度、搜狗和360这三家搜索公司之间来回跳槽，一年的时间，让工资收入翻了四倍以上。这也是面在竞争时，资源一定会溢出，让点有红利的一个小例子。就像淘宝早期要发展，一定要让几个商家占便宜，道理是一样的。</p><p>2012年8月16日，在360搜索正式上线的同一天，还有一个产品发布，就是小米2手机。360对百度的战争，他们遇到的真正敌人，是“趋势”。2012年，堪称中国移动互联网爆发之年。PC互联网的整体流量开始大幅下滑，用户集体向移动互联网迁移。360推搜索的同一天，雷军推小米2手机，这是一个很有象征性的场景。周鸿祎是著名的产品经理，但是他在做360搜索的产品决策时，漏掉了移动互联网这个巨大的经济体。所以，今天360公司的公司估值，不如今日头条。要知道，在360发布搜索产品的那一年，今日头条公司才刚刚注册成立。</p><h4 id="本讲小结-4"><a href="#本讲小结-4" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>我们简单回顾了360几场战役的得失。我想说的是：当你想做一个产品的时候，入手只能是一个点。但你要想清楚，它附着在哪个面上？这个面在和谁竞争，它能如何展开？这个面，是在哪个经济体上？这个经济体，是在快速崛起，还是沉沦？</p><p><strong>悲催的人生，就是在一个常态的面上，做一个勤奋的点。</strong></p><p><strong>更悲催的人生，就是在一个看上去常态的面上，做一个勤奋的点，你每天都在想着未来，但其实这个面正在下沉。</strong></p><p><strong>最悲催的人生，就是在一个看上去常态的面上，做一个勤奋的点，其实这个面附着的经济体正在下沉。</strong></p><p><strong>如果一个人一生只能收到点状努力的计时收益，从来没有享受过一次线性周期的成果回报，这就叫穷人勤奋的一生。</strong></p><p>课后作业</p><p>1.描述一下，你现在的职业是什么样的一个点？</p><p>2.你所在的公司或者业务肯定是需要串联很多点的一条线，那你的这个点是在公司这条线的什么位置上？</p><p>3.这个公司附着在什么样的一个面上，谁在给你或你的公司赋能？这个面又是附着在哪个经济体上？</p><p>就好像在地球仪上，找到自己的位置点一样，请你用点线面体的框架，尝试标一下自己的位置。</p><h3 id="09-机会判断：怎样找到有势能的趋势"><a href="#09-机会判断：怎样找到有势能的趋势" class="headerlink" title="09 机会判断：怎样找到有势能的趋势"></a>09 机会判断：怎样找到有势能的趋势</h3><p>这节课，我们继续谈“点线面体”。</p><p>女生相亲的三点建议</p><p>在课程最开始，我讲了一个结婚教练的故事。不少人感兴趣，我就再多说一点技术性细节。结婚教练给女孩第一次相亲提了三点建议：</p><ul><li><p>打扮要女性化。</p></li><li><p>不要努力表现自己，不要谈自己最擅长的东西，不要努力营造氛围，平淡如水即可。</p></li><li><p>适当的时候，主动结束约会。如果对方不再约你了，就放弃这个人。</p></li></ul><p>第一点很容易理解。如果教练要求女孩打扮得漂亮一点，其实每个女孩对打扮得漂亮的理解都不一样，要化个浓妆吗？要穿晚礼服吗？但如果要求是女性化，那么至少一些非常男性化和中性化的打扮方式就可以被过滤掉。在女性化的范畴里，你按照自己能做到的，自己舒服就行了。因为你是去相亲，就跟打开一个网页一样。你要在对方看到你的0.1秒内，让对方意识到，他是在和一个女性约会，这是第一场景。</p><p>第二点的目的是什么呢？很多女孩在希望引起一个男生注意的时候，会表现得非常用力。她会努力拿出自己最好的一面，给对方留个好印象。比如，一个女孩是个计算机高手。她可能会在和男生第一次相亲的时候，把话题引到自己最擅长的领域，然后在自己最擅长的领域里充分展示自己，希望给对方留下一个深刻的印象。这样做对吗？第一次见面，到底是应该照着平淡如水来，还是去玩命地表现自己？如果是追求短线关系和片面接触，当然应该玩命闪耀。比如表演，比如做销售。但如果是长期关系，两个人认识相处的目的是缔结婚姻，成为长期合作、伴侣关系，那么就应该平淡处理。为什么？因为每个人现在呈现的样子，其实都是自己过往所有经历的累加。有句话说：“你的样子里，有你爱过的人，走过的路，看过的风景，读过的书。”相亲时，对方看你一眼，喜欢就是喜欢，不喜欢就是不喜欢。</p><p>所以有了第三条，如果对方不再联系你，那你就放弃吧，因为对方没感觉。其实做产品也是这样的。你也许会想会不会是因为他没有看到你最闪耀的点，所以没有喜欢上你，这样是不是太亏了？如果你追求的是长期关系，就不能基于自己最闪耀的点去缔结关系。因为你所有闪耀的点，都有它没用的时候。做生意有亏钱的时候；你擅长计算机，但是技术也在不断更新迭代；你是名记者，但是媒体行业也在不断变革，也不是所有人脉永远买你的账。如果对方是因为你闪耀的这些点才喜欢你，那你是不是为了保持对方对你的兴趣，要不停地闪耀呢？长期关系里，没有人做得到。你平平常常拿出来的样子，就是你真实的样子。这才是你可以稳定提供的样子，才是可预期的样子。从这个稳定的点开始，作为一段长期关系的发端，有可能才是靠谱的。</p><h4 id="从你做得到的“点”出发"><a href="#从你做得到的“点”出发" class="headerlink" title="从你做得到的“点”出发"></a>从你做得到的“点”出发</h4><p>做产品也是如此，世上的机会千千万，应该从哪个“点”开始呢？和相亲一样，从你能做到的、能稳定提供的那个“点”开始。<strong>不要憋大招，自古长考出臭棋。</strong>如果是需要卯足了劲跳起来才能够得到的一个“点”，其实很难持久。</p><p>我见过无数创业者，真的非常痛苦。为什么？因为当下能做得到的事，他觉得不甘心，甚至自己都无法直视自己的真实能力、真实水平。他更不愿意客观面对，这就是自己实际能够达到的“点”，这就是自己当下配得上的人。而他自己想要的，够起来太费劲。这就是我要把“点线面体”再讲一课的原因。</p><p>因为不论是相亲还是其它的事，看得上我的人我看不上，我看得上的人看不上我。或者我想要的离我太远；我能做到的我看不上。这是无数人的痛苦。我认为，这是同一个问题，就是过于关注“点”。这个人只对“点”有感觉，对“线”、“面”、“体”的力量，完全无视，甚至完全没概念。任何一个点都有它的来路，都有使它成为“今天”这个点的线、面、体。如果你对线、面、体完全无感，只想拥有一个点的当下，那基本上是守株待兔。比如说你想嫁一个有房有车的人，看上去好像很难。但如果你找一个在BAT工作的码农，或者某个新兴独角兽公司的早期员工，稳定了几年之后，就会有房有车。你要看到这条“线”，而不要纠结于当下的“点”。在一个“点”上反复纠结，其实得不出本质的结论。不如花时间，从这个“点”上跳出来，研究一下这个“点”下面的大框架——“线”、“面”、“体”。</p><h4 id="易到的选择"><a href="#易到的选择" class="headerlink" title="易到的选择"></a>易到的选择</h4><p>比如，易到用车是2011年开始的，算得上是全球第一家互联网约车公司，比Uber都早。用创始人周航自己的话说：“干了一年，完全没有对手，心里都发毛了。”第二年，也就是2012年，是移动互联网的元年，一个新经济体诞生了，并且快速膨胀。一瞬间，基于这个新经济体的各种应用全都涌出来了。这一年，Uber、滴滴、快的及100多家各种各样的网约车公司同时出现。风口周边，必然VC成群，这是个铁律。所以，当时江湖上所有的投资公司，以及有投资业务的大佬，全都找过周航，包括腾讯、阿里等等。最后，周航选择了携程。为什么呢？周航觉得业务相关。</p><p>接着，就是2014年著名的打车补贴大战。为什么会补贴打车应用？其实不是滴滴和快的要打，而是腾讯和阿里在打。这两个“面”为了争夺移动支付市场，需要争夺打车软件这个移动支付场景。所以滴滴和快的的大战，背后是腾讯与阿里这两个“面”对它们的赋能。这和上节课我讲360和百度打仗时，几个“点”上的员工涨了工资一样。当“面”打仗的时候，“面”上的“点”是有红利的。2016年，易到卖给了乐视。但实际上，它的败局在2014年拿携程投资的时候，就已经注定了。</p><h4 id="求之于势，不责于人"><a href="#求之于势，不责于人" class="headerlink" title="求之于势，不责于人"></a>求之于势，不责于人</h4><p>我读《孙子兵法》，最大的收获是两句话，一句是“胜与不胜在于彼，败与不败在于己”。这句不是《孙子兵法》的原话，是我自己总结的。</p><p>《孙子兵法》的全篇核心就是这个概念，意思就是说：我能不能赢了你，其实我做不了主，这是你的问题；但是我会不会输，会不会打光所有的牌，会不会下桌走人，那是我自己的问题。</p><p>另外一句是《孙子兵法》的原话：“<strong>求之于势，不责于人。</strong>”</p><p>这句话出自《孙子兵法·势篇》，相关原文如下：“故善战者，求之于势，不责于人，故能择人而任势。任势者，其战人也，如转木石；木石之性，安则静，危则动，方则止，圆则行。故善战人之势，如转圆石于千仞之山者，势也。”</p><p>雷军曾经告诉傅盛：“一个人要做成一件事情，其实本质上不是在于你多强，而是你要顺势而为，于万仞之上推千钧之石。”基于“点”的评估，其实每块石头都是一样的。但是位置不同，势能不同。所以，当你观察一个人或产品机会时，就像你手里拿着一块石头。你是要拿着这块石头站在原地，还是爬上山顶把它推下山去成为千钧之势？</p><p>我们再来说一下后半句，“不责于人”。刚才我们说了石头都一样，人都一样。它们之间的区别取决于它们搭载在哪个“面”上，“面”在哪个“体”上。如果你和敌人，在平原地带拼刺刀，确实只能依赖一个又一个士兵的单兵战斗力。第一模块我们谈了生物性情绪，面对危险和压力，恐惧与焦虑是人类的正常反应。有经验的将军其实能够通过训练与管理，让一个集体的集体人格短时间压倒个体的脆弱。老大一声喊，大家就冲上去了，但是这是不得已才会发生的情况。“制高点”这个词，就是从战争中来的。一个将军，不能担心自己的士兵怕死。为什么？人怕死、人不够勇敢，这是人的常态，这是人性。士兵怕死和销售怕产品难卖一样，是必然的。对于必然的事情，你有什么可担心、可抱怨的呢？</p><p>如果你选择做一个将军，那你就要找到战略制高点，带大家爬上一座山，从山上推石头下来砸敌人。这时你会发现，每个士兵的勇气与战斗力都提升了3倍，因为地理优势为团队的每个人都赋了能。但是作为将军或管理者，不能抱怨士兵或员工不够勇敢，这叫“责于人”。</p><p>“求之于势，不责于人”，是要自己去找有势能的“面”，而不能寄希望于员工的“点”。如果想一切靠员工的“点”的努力来得到，所有的士兵其实都贪生怕死，所有的员工都害怕努力而没有收获。</p><p>“求之于势，不责于人”，这才是CEO该干的事。找到外部势能，为你的整个组织赋能。</p><p>比如，优酷被爱奇艺超过。优酷的对外解释是，上市到了一个周期需要给投资人回报，所以减少了版权购买的支出。结果，爱奇艺抓住机会加大版权购买，只用了一年时间就超过了优酷。其实背后还有一个逻辑是，百度对爱奇艺的赋能。因为版权购买就是花钱，谁都能做。而百度用高效流量的和机房IDC（数据托管服务）能力，极大地为爱奇艺赋能了。所以，后来优酷也抱了大腿，加入了阿里巴巴。但对于视频网站来说，阿里巴巴所擅长的能力不如百度的能力有效。纵使阿里今天的市值是百度的很多倍，就这一“点”的赋能能力，还是百度强。</p><p>“求之于势，不责于人”，这才是通往幸福的道路。</p><p>作为一个CEO，你不应该天天对自己的团队和员工不满意。你应该去找外部势能，为你的组织赋能。今天能跟着你干活的，都是你能得到的最好的员工。每一个人，就只是一个当下的“点”，资源都很有限。一个“点”，你再抱怨，再压榨，也就只是一个“点”的资源而已。反过来你要想，大家把自己最好的“点”都给了你。在一个时间周期之后，你会回报给大家什么样的线性收益呢？</p><h4 id="本讲小结-5"><a href="#本讲小结-5" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>女孩判断伴侣，产品经理判断产品机会，创业者判断创业方向，这三者的痛苦其实是一样的。我看得上的看不上我，我能做到的又觉得不够。所以，我们为什么第一模块要花整整五讲来说构成了你心智的情绪、潜意识和集体人格。因为你需要知道，这些东西其实只是情绪而已。你在做关键决策的时候，不要被这些小情绪干扰。你要强迫自己，离开牵动你情绪的“点”，去看到“线”的方向，去预测这条“线”的周期，并且明确你自己在周期的哪个位置，是哪个“面”在给你赋能。你要明白外部的势能才是重要的，不要过于苛求那个跟随你的“点”，这才是决策的关键。但这确实很难。比如巴菲特的合伙人查理·芒格，为了把自己训练得客观，用了一生的时间。</p><p><strong>人生的选择远比努力更重要。</strong></p><p>你的选择应该是一条“线”、一个“面”，甚至是一个“体”的收益。你个人的努力，只是在“点”、“线”、“面”、“体”的既定框架内，作为一个“点”的挣扎而已。</p><p>课后作业</p><p>这节课我们讲了“求之于势，不责于人”，但是如果势能发生了变化，比如说你所在行业的风突然之间停了，你觉得应该怎么做呢？</p><h3 id="10-痛点、痒点、爽点都是产品机会"><a href="#10-痛点、痒点、爽点都是产品机会" class="headerlink" title="10 痛点、痒点、爽点都是产品机会"></a>10 痛点、痒点、爽点都是产品机会</h3><p>上节课我们讲了点线面体。</p><p>不管你是做一个产品，接触一个产品，还是接触一个人，总得从一个点开始。</p><p>今天我们就来讲点。</p><h4 id="痛点是恐惧"><a href="#痛点是恐惧" class="headerlink" title="痛点是恐惧"></a>痛点是恐惧</h4><p>我们做产品不可避免地就要谈一个词叫痛点。</p><p>什么叫痛点？</p><p>我搜了一下，在“什么是痛点”的问题下，排第一的答案是：“对于产品来说，痛点多是指尚未被满足的、而又被广泛渴望的需求。”这个答案当然不对。</p><p>没有被满足用户只是难受而已，不能拿用户的难受当痛点，或者产品的切入点。为什么？我在下面会讲到。</p><p>反而一些网友讲自己的案例，非常有意思。一个叫子柳的网友说：</p><p>手机上一天到晚都会收到推销的广告电话，恨不得卸载手机的通话功能，直到我遇上某某号码通。碰到头疼脑热的小病，跑医院能把人折腾死，又不敢乱吃药，这时候有一个App就很好地解决了我的问题。</p><p>一个叫舒大畅的网友说：</p><p>当年的海飞丝广告就很打动我。我第一次拜访岳父岳母，肩上都是头皮屑，让老人一脸嫌弃；面试的时候衣服上都是白点，让面试官皱眉头……这些都是很痛的事情。</p><p>你注意一下，上述场景中用户决定要用什么产品帮助自己时，他们用的一个词是“怕”。<strong>痛点是恐惧。</strong></p><p>接下来，我要讲一篇文章叫《如何抓住用户痛点做产品》。这篇文章的说法是错的，所以我当作错误示范来讲。</p><p>张太太是个全职太太，全职在家带两个孩子。她每天早上起床后，要先给两个宝宝做早饭，老大吃完后就要去幼儿园。张太太要推着婴儿车让老二坐在里面，再牵着老大的手把孩子送到幼儿园。之后，她要赶紧回家，哄老二吃饭，并陪他玩耍。到幼儿园放学时，张太太又要带着老二去接老大。到家后先生也要下班了，她又要开始准备晚饭。张太太也有自己的兴趣爱好，有自己的想法和梦想，但实际上家务活已经占去了她所有时间。</p><p>接着这篇文章对张太太做痛点分析。张太太没有自已的时间，时间全部被孩子占据了，能不能有一款产品解决张太太的问题？这不是她一个人的痛，这是一群忙于家庭生活的、大多数女性的痛。</p><p><strong>这是痛点吗？当然不是，因为这中间没有恐惧。</strong></p><h4 id="爽点是即时满足"><a href="#爽点是即时满足" class="headerlink" title="爽点是即时满足"></a>爽点是即时满足</h4><p>痛点，是做产品的抓手。另外一个做产品的抓手，是爽点。</p><p>什么叫爽点？</p><p>人在满足时的状态叫愉悦，人不被满足就会难受，就会开始寻求。如果这个人在寻求中，能立刻得到即时满足，这种感觉就是爽。</p><p>当年俞军在百度招聘产品经理时，招聘题目是百度如果要做音乐该怎么做？很多人都写了洋洋洒洒的规划书给他，有一个人只写了六个字：“搜得到，能下载”。俞军就挑了这个人，他就是后来当上百度副总裁的李明远。当年互联网资源非常少，人们上百度找音乐找自己想听的歌，一搜就搜得到，还能下载，这就是爽。今天的外卖，你在家用手机下单，吃的就送到你家来了。你在河狸家上下单，美甲师就上门给你做美甲了。</p><p><strong>有需求，还能被即时满足，这就是爽。</strong></p><p>回到刚才的场景，我们知道张太太自我实现的想法没有被满足，这当然是不爽的状态。但是，你的服务可以让她即时满足吗？你能做个产品，能即时满足这类女性实现自我的需求吗？这是个复杂问题，是不可能做到即时满足的。这不像是在游戏里顶个蘑菇加10分那么简单。你看到了张太太不爽的状态，但是如果你没找到让她即时满足的方法，那么你依然没有找到这个产品的切入点。</p><p>为什么？因为自我实现其实是一条漫长而痛苦的路，人的本性是懒惰的。你看到一个人展现出了勤奋、规整、自律，其实这是被一系列的恐惧、集体人格、潜意识压迫，才会呈现出那个样子。所以，如果没有恐惧这条疯狗追着，没有爽点这种满足感来持续喂养，只靠一个App帮助女性实现自我，那可以不客气地说，这就是个不痛不痒的产品。</p><h4 id="痒点是满足虚拟自我"><a href="#痒点是满足虚拟自我" class="headerlink" title="痒点是满足虚拟自我"></a>痒点是满足虚拟自我</h4><p>痛点和爽点，我们说完了。刚才说到不痛不痒，我们再说说痒点。</p><p>那什么叫痒点呢？这其实是我自己挖的坑，我以前在自己的微信公众号上写过一篇文章，叫做《痛点痒点》。痛点已经成了今天互联网的万金油概念了。但今天满街都是创业者和投资人，只靠抓一个痛点做产品，其实不容易。这时咱们发现近两年有一个现象，各种网红产品层出不穷。比如网红奶茶、网红酸奶、网红曲奇、网红洗发水，它们的爆红是靠抓住痛点吗？显然不是，网红产品们靠的是痒点。什么是痒点？</p><p>咱们说一部大家都知道的韩剧《来自星星的你》。这是好几年前的剧了，我当时热追来着。我为什么会追这样一部剧？因为它的痒点非常打动我。它讲的是一个女明星和外星人的爱情故事。听上去，这个故事创意也没什么新意，为什么当时那么火呢？“痛点控”们总结说：这部戏抓住了女性对英雄和美少年合体的想象，满足了这个痛点。如果这个痛点是对的，那么单靠一个痛点，怎么可能拍出20集九百多分钟的内容呢？怎么会让我们不停地看，还愿意不停地讨论，甚至做一些周边产品呢？</p><p>你可以翻一翻百度贴吧“来自星星的你吧”，看一下大家都在聊什么。我当时去看的时候，有600多万个帖子在讨论这部剧。大家都在谈的是，教授（男主角都敏俊）的微表情、教授的眼神、论教授对二千（女主角千颂伊）态度的转变、二千的衣服、二千的妆容与唇膏、二千的配饰……这些其实都是痒点。</p><p>痒点是什么？这也是我自己定义的，<strong>痒点满足的是人的虚拟自我。</strong></p><p>什么是虚拟自我？<strong>就是想象中那个理想的自己</strong>。</p><p>比如，我们看偶像剧，追星，看网文，看英雄故事，看网上的名人八卦，看名人的创业故事、成功神话。你是在热追他们吗？不是，你情不自禁投入到关注的内容，是你的虚拟自我，是你自我想象的一个投射。</p><p>这时咱们再来说说这一波网红电商。其实<strong>网红为你营造了虚拟自我的生活，是大家理想生活的投射。</strong>我们购买网红的东西，就部分地实现了自己的虚拟自我。</p><p>比如，淘宝第一网红雪梨，在谈她的运营经验的时候说，为了营造更好的形象，每次为新款的衣服拍照，只有45公斤的雪梨要提前一周节食。你在微博上看到的那种非常“随意”的街拍照片，是她用10天时间拍摄，然后挑选和修图运营出来的产品。在微博上发照片，就是她与粉丝最重要的互动。她要用她的照片，为粉丝营造出一种生活场景，她说：“你卖的其实是一种生活方式，它要满足女孩心中美美的幻想。”雪梨的粉丝成套地买雪梨的穿搭，她们买的不是衣服，不是基于功能性的需求，不是天冷了需要一件衣服保暖。而是我要穿雪梨在巴黎穿过的那件衣服，穿上雪梨的衣服，她们就会觉得自己部分地过上了雪梨所营造的生活。这就是一种虚拟自我的实现。</p><h4 id="本讲小结-6"><a href="#本讲小结-6" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结一下，什么才是一个产品的入手点。痛点、爽点、痒点都是不错的点。这个就看产品经理自己对用户的哪个点感受最深、手感最准。比如说，饿了要吃东西。但是“吃饱了”和“吃得很满足”，这是两个概念。吃个馒头能饱，但是仅仅是满足了功能需求，不能支持好产品的概念。</p><p>酣畅淋漓地吃一顿海底捞火锅，大汗淋漓，感觉爆爽。这就抓住了爽点，这是好产品。</p><p>怕吃火锅长胖，抓住这一点的恐惧，抓住痛点，也有产品空间可以做。或者还可以做一个美美的网红餐厅，像雕爷做的薛蟠烤串。用户点一份干冰爆米花，吃一把，两个耳朵往外冒干冰的白气，人人都会拍张照然后发朋友圈，这是痒点。</p><p>吃顿饭，其实也可以有痛点、爽点、痒点这些不同的切入点来做产品的。</p><p>课后作业</p><p>你能不能介绍一下，你现在正在做的产品，核心是在打痛点，还是打痒点，还是在抓爽点，或者三不沾呢？</p><p>欢迎在留言区分享。</p><h3 id="11-两套经典的用户画像"><a href="#11-两套经典的用户画像" class="headerlink" title="11 两套经典的用户画像"></a>11 两套经典的用户画像</h3><p>这节课来讲用户画像。</p><p>有非常多的书在讲用户画像，并且有一大堆方法论。所以在这一课里，我讲讲我们在实际工作的过程中用到的用户画像，希望能够给你启发或者能够直接用得上。</p><h4 id="第一套用户画像：羊群与草地"><a href="#第一套用户画像：羊群与草地" class="headerlink" title="第一套用户画像：羊群与草地"></a>第一套用户画像：羊群与草地</h4><p>比如，YY的创始人和董事长李学凌给我讲了一组用户画像，我早期做产品就是用他的这组用户画像来做的。他教我说：如果我有一片草地，我就在我的草地上养羊，所以我先要有第一只羊。如果这一只羊能够在我的草地上活下来，玩得很好，那么我的草地就是没问题的，我就可以引入更多的羊。羊多了，你就会发现头羊才是关键的，为什么呢？因为一只头羊可以管一大堆羊，你就不用管了，那些小羊就不用管了，头羊都会管。只要有头羊，羊群就可以聚集。羊多了就会有狼，狼多了，我就把羊圈起来，然后向狼收费。</p><p>几乎所有的互联网社区，都是按照这个场景和用户描述去做的。在这里我们谈到了几个用户画像：第一只羊、头羊、狼。你的草地上来了第一只羊，接着这只羊吃了一口草，死了。第一只羊是什么？就是你迎来了第一个用户，这个用户玩了一下就走了，再也不来了，就叫“死了”。那怎么办？你再拉来第二只羊吗？有很多同学问我，为什么相亲后男生不再主动联系，你就放弃，在这里也一样，就是因为不匹配。一个人的自然状态，让另外一个人觉得不喜欢，和你准备的一个产品请一个用户来用，用户不喜欢，这两种情况其实是一样的。你可以为了留住这只羊，动用很多外部资源，比如我从外面买草买料，可以暂时把这只羊留下来。但这其实是靠额外付出，才能撑住场面。并不是说你的产品、你的草地已经具备了生生不息的自然状态。所以如果你要有羊，还是需要回来继续解决你自己的草的问题。</p><p>接着你有一片草地，迎来了第一只羊，这只羊吃了一口草没死，但是玩得不开心，这个是什么意思呢？就是你有了一个产品，来了一个用户，然后这个用户用了一下觉得也还可以，但是没那么爽。这个时候你可以引入更多的羊吗？也就是说你要开始推广你的产品了吗？当然还是不行，其实这依然是你的草的问题，你的产品的问题。日本的剑圣宫本武藏，有一本书叫<strong>《五轮书》</strong>。他说：“即使面对千军万马，你要斩杀的其实只有你对面的一人。”所以测试你的产品，其实你不需要其他的条件。首先要有第一只羊；这只羊在这里过得很好、玩得很开心，它得到了即时满足；这时可以引入更多羊，也就是产品可以推广了。</p><p>做产品需要磨炼自己的心力，让你的心非常硬，不能自欺欺人，不要骗自己感觉良好。不要觉得万一去推广时会有其他的羊喜欢。不能这样，你要从找到第一只羊开始。第一只羊是最关键的角色。你找到了这个用户，他可以在你这里得到即时满足，玩得很开心，那么针对这只羊，针对这个用户的同类用户去做推广，你的产品就可以被快速地推开。</p><h4 id="头羊与网络效应"><a href="#头羊与网络效应" class="headerlink" title="头羊与网络效应"></a>头羊与网络效应</h4><p>第二个关键角色是什么呢？是头羊。李学凌说整个生态发展到最后，最核心的就是头羊。整个企业的资源核心就是要去维护头羊，只要有头羊就会有羊群。有时候小羊叫一叫表示不满，我们根本不用管，因为企业资源有限。什么叫头羊？比如说论坛的版主、YY公会的老大、微博的大V、重度用户、淘宝的店主，这些都是头羊。当你的草地上出现了头羊，头羊开始自己管羊群的时候，这代表着什么？其实这就代表了自组织的开始，你开始拥有了网络效应。我想你可能听过曾鸣讲的《智能商业20讲》，其中说到了<strong>未来商业最核心的双螺旋：数据智能和网络效应。</strong>他还专门讲了为什么Uber没有网络效应。在这里，我再援引头羊的理论，把网络效应再解释一下。Uber有头羊吗？滴滴有头羊吗？没有。Uber、滴滴都是一家公司直接服务每一个单点司机，所以Uber、滴滴不存在自组织，也没有网络效应。</p><p>当你要评估一个产品或者一家公司的网络效应有多大时，一个非常简单的评估方式就是数一数它有多少头羊。比如说一个很火的摄影网站叫蜂鸟BBS，它大概有50个版主，所以它有50个头羊；那另外一个更火的BBS——天涯，最少有5000个版主，所以它至少有5000个头羊。这样一对比，你就大概知道，天涯的网络效应肯定是远远大于蜂鸟的。百度贴吧有多少版主，就至少有多少头羊；淘宝上有多少卖家，就有多少头羊。那按照这个标准来看，百度贴吧和淘宝，它们的网络效应其实是巨无霸级的。草地、第一只羊、头羊和狼就是一组经典的用户画像。狼是什么我们放到最后说。其实，基本上所有玩互联网网络效应的、玩社区的，都用这一组用户画像去开启他的生态体系。</p><h4 id="第二套用户画像——大明"><a href="#第二套用户画像——大明" class="headerlink" title="第二套用户画像——大明"></a>第二套用户画像——大明</h4><p>另外一套经典的用户画像是我做的，有三个核心角色，叫大明、笨笨和小闲。</p><p>在这一套用户画像里，第一个用户叫大明。大明有什么特点？大明对自己的需求非常了解、非常清晰。比如说男人买衬衫就是大明，或者男人买一个手机或3C产品，他就是大明。因为他对他要的东西是非常清晰的，所以他要寻找的核心是价格或者硬货。这个时候，网站的页面做得再漂亮、格调再高雅，如果产品价格不好，大明一样不买账。所以互联网产品中，大明最依赖的工具是搜索，因为他对自己主动要找的东西是非常清晰的。最早的互联网电商都是依靠大明用户开始的。比如成熟最早的旅游，卖机票、卖酒店，这些都是标准品。然后卖3C产品，也是标准品。比如，像去哪儿的搜索比价引擎，提供从同一班航班里找到最便宜的机票这一服务，这更是大明用户所青睐的一个经典产品。</p><p>京东其实就是定位于服务大明的，所以标准品的竞争几乎都是京东赢。为什么？因为大明用户极其简单，他要干的事情就是两件：一、搜索自己要的；二、比价格。京东的体量优势越来越大，对供应链的挤压能力越来越强，所以它服务大明用户的能力就越来越强。现在一些B2C品类暂时还有机会，其实是京东的火力还没有扩展到那里。标准品的电商，只要是京东来做，根本不需要精细化的运营就能够压倒其他的商家，为什么？因为大明用户要的就是价格和效率。</p><p>当然了，大明用户还有一个特点，他没有忠诚度。比如一个男士，他买衬衫，买了就走，不会再多看一眼其他的东西。易到用车的创始人周航有一个朋友跟他说：“我对你的忠诚度就是10块钱。用易到和用其他的打车软件，如果差价是10块以内，那我就选易到。但如果说差价超过10块，不好意思，谁便宜我选谁。”这就是大明用户。</p><h4 id="第二套用户画像——笨笨"><a href="#第二套用户画像——笨笨" class="headerlink" title="第二套用户画像——笨笨"></a>第二套用户画像——笨笨</h4><p>说完了大明，咱们说笨笨。</p><p>笨笨的特征是什么？就是我有大概的需求，但是还没有那么明确。</p><p>如果说男人买衬衫是大明，那女人买裙子就是笨笨。</p><p>你问女生她想要一条什么样的裙子，她真的不知道，我得看、挑选、比较，最后从各种信息中做一个决定。所以如果男人要出门买衬衫，基本上一定会买一件衬衫回来；但如果女人要出门买裙子，她可能会逛十家店看了200条裙子，最后买了一顶帽子。</p><p>如果京东是服务大明的，那么现在有一个给女生用的App叫小红书，它就是一个经典的服务笨笨的应用。我们来比较这两个的区别是什么。</p><p>京东有一个很强的产品目录检索，小红书没有这个功能。而且小红书搜索任何一个结果都会出一大堆产品，你想要用关键词过滤掉？做不到。为什么？故意的。因为女孩儿的目的不是要有效率地、快速地找到自己要的东西，而是想东看看、西看看，看看有什么她不知道的，有什么她没见过的，看得多了就会忍不住买一样。最后买的东西和她最初想要的东西相不相关，这不重要，这就是笨笨用户。</p><p>淘宝，尤其是智能化升级之后的淘宝，更是服务笨笨用户的。马云说淘宝是一个娱乐公司，为什么？因为每天晚上都有2000万的女生在淘宝上逛，什么也不买，就是逛。但是，如果笨笨决定了要买什么产品，那么下一秒有70%-80%的概率，笨笨就会变成大明，然后开始去追求价格。一个经典场景是我在豆瓣东西上找买东西的灵感，接着到淘宝上去找最便宜的一件购买。</p><h4 id="第二套用户画像——小闲"><a href="#第二套用户画像——小闲" class="headerlink" title="第二套用户画像——小闲"></a>第二套用户画像——小闲</h4><p>第三个用户就是小闲。小闲的特征是什么？就是我没有消费需求，我就是来打发时间的。如果说百度、京东服务大明，淘宝服务笨笨，那么腾讯其实就是服务小闲的。</p><p>QQ聊天是因为闲，微信刷朋友圈还是因为闲，你玩游戏依然是因为闲。所以你在任何一个闲的时候，打开腾讯的产品一定可以帮你杀时间。所以腾讯的用户往游戏和视频去转化，转化率就会非常高，为什么呢？因为用户玩游戏也好，看视频也罢，其实他都是因为闲，是沿着小闲既定的心理需求和行为路径发展下去，继续打发时间。但是如果你要让腾讯的小闲流量转化为购物的电商，效果就很差，为什么？因为场景不对。场景是个大词，我之后会专门讲。</p><p>总之，一个人到这来是来打发时间的，如果你突然让他买东西，他会觉得他心理建设没做好，他没有这个预期。其实不单是腾讯，其他服务小闲的社区，比如说天涯、豆瓣、蚂蜂窝，用它们的社区用户去做产品的交易导流，效果都挺一般的。</p><h4 id="本讲小结-7"><a href="#本讲小结-7" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>讲完了大明、笨笨、小闲，你就会发现，互联网的BAT就是服务这三类经典用户涨起来的。百度服务大明，你要什么说清楚，我帮你找；淘宝服务笨笨，没什么事你就上来逛吧，有层出不穷的东西给你看；腾讯服务小闲，闲着没事的时候，打开腾讯的任何一个产品打发时间。</p><p>这三个用户和上面那个草地与羊的关系是什么呢？</p><p>不管大明、笨笨和小闲其实都是羊，你想服务具体哪种羊，你就要按照大明羊、笨笨羊、小闲羊，三种不同羊的需求，来管理你的草地，制作你的产品。所以具体到痛点、痒点、爽点，你得让大明羊、笨笨羊、小闲羊按照他的心理预期，来吃一口你的草，如果吃得开心就再也离不开了。刚才说完了羊，这个角色里其实还有一个狼，那么狼是谁呢？对于B2C的企业来讲，如果你是向B端收费，那其实狼就是B端。比如说像京东、淘宝，其实它们都是向上游挣钱的，所以<strong>商家是狼</strong>。那对于腾讯呢？其实腾讯的主要收入来源不是在B端，而是在C端，所以我们可以认为腾讯也会把少量的羊卖给狼，但是它主要是靠剪羊毛成为一家巨大的公司的。</p><p>课后作业</p><p>请你选一个产品分析一下，这个产品核心是服务大明、笨笨，还是小闲呢？这个产品的竞争对手是谁？你觉得谁服务得更好一点？</p><h3 id="12-设计产品时要包括产品的场景"><a href="#12-设计产品时要包括产品的场景" class="headerlink" title="12 设计产品时要包括产品的场景"></a>12 设计产品时要包括产品的场景</h3><p>上节课提到了场景，所以这节课就把场景这件事细说一说。</p><h4 id="用好场景，让美女脱颖而出"><a href="#用好场景，让美女脱颖而出" class="headerlink" title="用好场景，让美女脱颖而出"></a>用好场景，让美女脱颖而出</h4><p>场景在几年前还是个新概念，现在满大街都能听到这个词。为什么经常提到场景呢？因为场景本来就是产品的一部分。你脱离了场景谈产品，就好比你给了一个女孩一件很漂亮的晚礼服，东西很美，女生也很喜欢，但是无处安放。那这东西有什么用呢？</p><p>什么叫场景？咱们都知道杰奎琳是美国历史上最优雅的总统夫人，她有一句名言：“我知道我不管做什么事，都不如我把衣服穿得好更重要。”杰奎琳穿衣服有多讲究呢？她陪肯尼迪出国访问的时候，她会提前要对方接机仪仗队的着装方案以及接机的场景，为的是当她走下飞机的那一刻，她的着装在整个场景中既无比和谐，又能非常好地突出自己。</p><p>有一篇文章讲到了电影《绣春刀2》里的杨幂，用了一个词，我觉得特别有趣，说杨幂在这部电影里的作用叫“女性景观”。“女性景观”这个词很有意思。如果我们按照一个女生有多美来作一个比喻，有的女生就像路边的野草，完全不会留下任何印象。也会有一些美女是家庭盆景级，挺漂亮的，会有个印象。但是有的美女，比如说像张艾嘉，茶道的张南揽，已经把自己修炼成了行走的艺术品。而杰奎琳真的是把自己做成了女性景观。</p><p>什么叫女性景观？就是你会专门花钱买一本她的画册，就好像你会专门花钱买某个著名风景的明信片那样。有人会把她的海报印出来，有人把她的头像设置成壁纸，就像对待美丽的风景那样。她的美已经是一种景观级别。那么，这种景观级别的美是天生的还是刻意为之的？就杰奎琳来讲，她是把她自己作为一个产品运营，也就是她对自己公众形象的运营。杰奎琳为什么有这么多好照片？对于普通人来讲，高兴就拍张照。但是对于杰奎琳来讲，她的照片不是个人记忆，而是公众视觉，是公众记忆的一部分，是她自己的重要产品。你看到杰奎琳那些很棒的照片，是她精细化运营的结果，而照片中的场景就是产品的一部分，甚至是非常重要的一部分。你想一想，如果脱离了出国访问的仪仗队背景，或者脱离了白宫中某一个特色角落的背景，只是一个美女，摆个姿势照个相，会有多少传播度呢？杰奎琳的做法是<strong>重视场景，有效地使用场景，然后在场景中成就自己的形象。</strong></p><h4 id="什么是场景"><a href="#什么是场景" class="headerlink" title="什么是场景"></a>什么是场景</h4><p>我们刚才一直在谈场景这个词，那场景到底是怎么定义？</p><p>要把场景拆开，场和景。<strong>“场”是时间和空间的概念，一个场就是时间加空间。</strong>用户可以在这个空间里停留和消费，如果一个人不能在某个空间去停留、消费，这个场就是不存在的。“景”是什么意思？<strong>景就是情景和互动。</strong>当用户停留在这个空间的时间里，要有情景和互动让用户的情绪触发，并且裹挟用户的意见，这就是场景。</p><p>很多时候，你以为你是在消费产品，其实你是在消费场景。举一个高发的消费行为——吃饭。吃饭有多少场景？我们简单说一下。比如说，早餐怎么吃？是自己对付一下，还是摆好盘、拍照晒朋友圈？这就是不同的场景。中午饭怎么吃？你自己带便当，一边看网剧一边吃，这是一个场景；几个同事一起叫便当，在会议室里边吃边聊，这是一个场景；几个同事一起出去吃，然后AA制结账，这是一个场景；中午请客户吃饭，这是一个场景；中午情侣约会也是一个场景。所以脑补一下，你会发现在不同的场景下，发生的消费其实是完全不一样的。</p><p>接着再说晚餐。回家吃是一个场景，在单位加班叫外卖是一个场景，朋友聚会是一个场景，恋人约会是一个场景，请客户吃饭是一个场景，求人办事要摆排场是另外一个场景。其实我刚才说的场景拆得极其粗，往细里还有无数的细分场景。所以开一家餐厅绝不是说你要输出的产品就是菜，或者加上菜的摆盘。开一家餐厅就是要运营一个场景。</p><p>一个朋友跟我说，他打算做一个便当品牌，决定打败<em>黄太吉</em>。他的方法是只做一种便当——寿司，因为寿司既健康又美味，而且时尚。我就问他，你的便当的消费场景是什么呢？它的消费场景是一个人自己吃，还是几个同事一起吃？如果你没有把它的消费场景考虑进去，这个产品就是不合格的。咱们之前讲过点线面体，新场景的出现其实也是一个“体”，比如碎片时间就是一个新场景。</p><h4 id="场景要能触发情绪"><a href="#场景要能触发情绪" class="headerlink" title="场景要能触发情绪"></a>场景要能触发情绪</h4><p>在移动互联网不成熟之前，我们要乘地铁，会堵车，也要等人。</p><p>碎片时间本来就充斥着我们的生活，但是因为移动互联网的成熟，使你有机会把这些碎片时间利用起来。比如“得到”，其实就是抓住了碎片时间和认知焦虑的两大红利，然后成长起来的一只独角兽。</p><p>其实罗辑思维有一个例子，就很好地体现了场景的力量。</p><p>不知道你是否记得2015年罗辑思维卖书的事？罗辑思维打包卖书的套装，一套六本，你不知道都会有哪些书，一共8000套。一个淘宝店店主当时就觉得这个套装肯定有价值，因为只有8000套。所以他在开卖的第一时间就抢了10套，8000套书在一个小时之内就卖光了。这个时候罗辑思维的群里还有人问，怎么没有了？到哪里买？于是这个淘宝店店主赶紧把他买到的这10套书上架销售。他想现在的状况是大家想买而买不着，那怎么也得加点价吧。所以他标价450元，结果放了两天也没人来问。然后他就降到了原价400元，还是没有人问。打折以后依然无人问津，最后这套书在淘宝是零交易。</p><p>为什么同一套书，在罗辑思维的这个场景里，8000套书在一小时之内被一抢而空？而在淘宝店店主自己的小店里，打了对折，放了10天还是卖不出去？原因就是罗辑思维搭建了“场”加“景”，在这个时间和空间里，大家一起疯抢，对彼此进行了意见挟裹和挤压。<strong>如果你架构的场景不能影响别人的情绪，不能形成对别人情绪的触发，它就不是一个场景。</strong>所以淘宝店店主把书放在货架上，冷冷清清往地一摆，这个是没有任何情绪触发的，只是一个“场”，不存在“景”，它不是一个场景。所以，场景的核心是在空间加时间的点上触发别人的情绪。</p><p>在第一模块已经说了，其实人所有的理智和意识都是把人往回拉的，而所有的情绪是在推动人的行动。所以人会去做一个动作，会往前走，是被情绪推动的。</p><p>比如电影《罗马假日》里，不知道你还记不记得一个桥段。公主和记者一起大闹派对，被警察追，然后他们跑赢了警察，气喘吁吁地并肩在一个街边坐下。当时真的是很美，岁月静好，月落无声。看这一幕的时候，我就在想，此情此景他怎能不吻她呢？果然下一个镜头派克就吻了赫本，这叫什么？这就叫场景和情绪触发。只有能触发用户情绪的场景才是真正的流量入口。互联网商业其实就是三个核心词：<strong>产品、流量、转化率</strong>，也就是产品的比拼、流量的争夺、转化率的优化，这就是互联网商业竞争的全部。</p><p>在万物互联的未来，到处都是屏幕，到处都是网络连接的入口。<strong>入口不是场景</strong>，它就像是淘宝店家有一个店面，那是一个时间加空间，但不是场景。<strong>想要成为场景，它还要能够触发情绪。</strong></p><h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>因此，我把场景作为咱们第二模块的最后一讲。你要规划一个产品，需要问自己<strong>七个问题</strong>：</p><ul><li><p>第一，我的产品解决了什么问题？是痛点、痒点，还是爽点？</p></li><li><p>第二，我在为谁解决这个问题？他得到<strong>即刻满足</strong>了吗？这是用户画像的问题。</p></li><li><p>第三，有多少人需要解决这个问题呢？这是市场规模的问题。</p></li><li><p>第四，目前人们是怎么解决这个问题的呢？这是竞争分析的问题。</p></li><li><p>第五，我的竞争方案为什么能够在市场竞争中胜出？你不要简单地看单点的竞争力，而是要看点线面体，谁给你赋能。</p></li><li><p>第六，用户会在什么样的场景触发情绪？需要马上去解决问题，这是场景问题。</p></li><li><p>第七，当用户遇到问题的时候，他会想到哪个名字呢？我在第四模块会讲。</p></li></ul><p>到此，第二模块就讲完了。</p><p>本讲作业</p><p>马上就是春节了，春节肯定是中国人的超级场景，不管是春节本身、春运还是春晚。你知道哪些把春节这个场景用得非常好的例子，或者说你基于春节这个场景，自己想做什么事情？</p><p>欢迎你留言与我分享。</p><h3 id="模块三）-系统能力"><a href="#模块三）-系统能力" class="headerlink" title="模块三） 系统能力"></a>模块三） 系统能力</h3><h3 id="13-怎样用系统能力给人提供确定性"><a href="#13-怎样用系统能力给人提供确定性" class="headerlink" title="13 怎样用系统能力给人提供确定性"></a>13 怎样用系统能力给人提供确定性</h3><p>这一课将进入到<strong>第三模块——系统能力。</strong></p><p>什么是系统能力？我以前问过这个问题，给你泥土和水，你能做出一个苹果吗？几乎每个人都会茫然，但是苹果树可以。<strong>用泥土和水做出苹果就是苹果树的系统能力</strong>。我们看到的所有结果，都是系统能力的产物。</p><p>你可以回到《机会判断：点线面体的战略选择》一课里，思考为什么一个“点”没那么重要？因为任何一个“点”都附着在一条“线”上，每一个“点”其实都是一条“线”的截面。这也是为什么结婚教练建议以结婚为目的的相亲，第一次见面正常平淡即可，没有必要专门地表现自己，因为每个人的自然呈现都是系统能力的结果。</p><p>比如一个人好的身材，其实是长期自律的结果；一个人得体而有美感的着装，其实是长期的审美陶冶的产物；一个人的神情和谈吐，其实是学识和性情的产物。所以一个人很自然地展现的一切，是层层叠加、长期积累的系统能力的产物。</p><p>当你说你要做一个产品，你需要的是建设一套系统能力。就好像你想拥有好的身材，就必须得有控制饮食和保持运动的系统能力一样。</p><h4 id="整体流程与确定性"><a href="#整体流程与确定性" class="headerlink" title="整体流程与确定性"></a>整体流程与确定性</h4><p>这一课有两个关键词：整体流程与确定性。</p><p>2011年，我加入腾讯的时候，被震惊到的地方就是，这家以产品著称的公司，在内部沟通时没有人提产品这个词，谁说产品谁外行。大家经常会用的词是什么呢？服务。</p><p>为什么？举个例子，比如说我们生产一个打孔机，用户要的是这个吗？其实用户不需要一台打孔机，用户需要的是墙上有一个洞。如果你定义自己在做的不是一个产品，而是一个服务的话，你的逻辑就会变成：我需要提供怎样一种服务让用户的墙上有一个洞？</p><p>那至少有几种方案：</p><ul><li><p>第一个就是做一个打孔机，然后卖给用户；</p></li><li><p>第二个就是做一个打孔机借给用户，或者提供一个服务，用户需要的时候，我就上门去给他打孔。</p></li></ul><p>以用户得到这个孔为目的去提供服务，而不是想着我要做一个打孔机，然后卖出去，这就是产品和服务的区别。</p><p>如果大家总是在谈产品，会很容易以产品经理为中心，就想着要做一个产品来改变世界。但是如果出发点是提供一个服务，就会以用户获得和用户满足为中心来做设计。这两种方式的目的和实现途径完全不一样。</p><p>今天我们要谈的不是一个互联网的产品，而是一个ATM机，为什么呢？因为ATM机是一个最简单的产品或者服务。ATM机提供什么服务？取现金。那ATM机提供的确定性就是在验证你的ID后，问你需要多少钱，把现金给到你。就像是罗辑思维提供的确定性，每天早晨6点多，罗胖都会给你60秒语音。60秒这个概念其实是马化腾提出来的，当时罗胖发了这条语音，他自己没有意识到，但马化腾马上就说这个60秒是个好概念。</p><p>马化腾是对确定性和压力点都极其敏感，也极其执着的人。为什么确定性这么重要？我们都是有感觉的，人生如此不确定，所以当你看到有一个东西非常确定的时候，是让人留恋的。</p><p>我们为什么会留恋自己的家？因为自己的家是一个确定性的存在。但如果两人天天吵架，动不动就会把离婚、分手挂在嘴边，这就会产生不确定感。不确定的东西是没有办法让你投入时间或者持续依赖的。所以我刚才谈了两个很重要的词，<strong>确定性</strong>和<strong>依赖</strong>。在我们整个课程的最后一课，我会再讲一遍，希望你有空也多体会这两个词。</p><h4 id="ATM机的确定性"><a href="#ATM机的确定性" class="headerlink" title="ATM机的确定性"></a>ATM机的确定性</h4><p>还是回到ATM机的例子上，ATM机提供的确定性就是验证ID之后给现金，围绕ATM机系统能力的设计和建设，所做的一切就是为了保证这个确定性。所以如果问ATM机有什么特点？怎么设计？从答案你就可以分辨出，一个产品经理是不是上道了。</p><p>如果让一个不上道的产品经理来说，他就会花过多的时间在ATM机的显性特性上。比如这个ATM机长什么样子，是长的还是宽的，界面是红的还是蓝的，是先出卡还是先出钞，等等。这个产品经理所有的观察和兴奋点，其实只是非常表面的一部分。刚才说了，ATM机的<strong>核心服务</strong>是取钱。一台ATM机里要放20万的现金，如果一个银行提供100台ATM机的话，就意味着要把2000万的现金放到外面去。就是说<strong>当你在提供核心服务的时候，也分流了企业的核心资源。</strong>ATM机是红的还是蓝的，这不是服务的本质，我们是需要回到服务本质来看的。基于这个服务本质我们需要有几个流程：</p><ul><li><p>第一步，首先需要有一个战略判断，战略部门需要做出一个决策，为什么要提供这个服务？提供这个服务对于企业，对于用户的价值是什么？</p><p>这个时候ATM机有两个价值点：</p><p>​    第一个是放在营业网点的旁边，分流取钱的压力，我们看到所有银行的营业网点旁都会有ATM机。</p><p>​    第二个价值点是放在人流密集的地方，可以服务用户，增加企业的曝光，增强用户黏性，提高好感度。</p></li><li><p>第二步，运营部门要对每一台ATM机有没有实现战略诉求来做价值评估。比如，钱放了很长时间都没有被取掉，那可能说明人流过少，这个点就应该拆撤；这个营业网点旁取现压力过大，一台ATM机不足，那就应该增加一台。</p></li></ul><ul><li><p>第三步，在运营部门对每个点的战略价值做完数据分析和价值评估之后，需要哪个点存在，我就要保证它的服务可用。为了保障服务可用，还要做哪些事呢？</p><p>最首要的肯定是现金，一台取不出钱的ATM机就是个铁盒子，是毫无意义的，就像无数个App都做得很漂亮，但用户真正需要一个漂亮的界面吗？不需要。就像我们在《痛点、痒点、爽点都是产品机会》那一课说的，用户需要的是即时满足。我要取现马上给我钱，有源源不断的钱，这个才是最重要的事情。</p></li><li><p>第四步，维护ATM机还要做很多其他事，比如说硬件管理。要保障ATM机不能间断电源，打印机要能打印凭条，还得有油墨、纸张，打印机的硬件不能坏掉。</p></li></ul><ul><li>第五步，要有客服管理。比如机器突然吞卡了，出钞有问题了，用户要投诉，这得有人处理。所以ATM机是一个最简单的产品，因为它提供的确定性就是出钞。钱是最简单的产品，为什么呢？因为它没有用户区分，不管男女老幼，只要拿到钱，他就是满意的。除了钱之外的任何一种商品，可能都是有用户区隔的。男性需求、女性需求、老人需求、孩子需求可能都不太一样。所以ATM机是不需要有用户区隔的，只需要能够保证确定性的供给，用户就会满意。但即使是这样一个最简单的产品，你要能够保证服务，提供完整的系统能力需要七个岗位：<strong>战略、运营、现金、密码、硬件、客服、技术。</strong></li></ul><p>如果说每次取钱ATM机可以收两块钱，一台ATM机总体回收成本大概是10年，这就是整体的服务成本。这也是为什么很多公司死了，而一些看上去页面很粗糙，做得不怎么好看的网站和App依然有旺盛的生命力。因为稳定出钞，这个是最关键的。<strong>持续地提供用户可以依赖的确定性，这个是关键。</strong>如果你把过多的热情花在了诸如ATM机应该是什么形状的，是红的还是蓝的，可不可以再精美一点，这些显性特性的东西上，对于整体的业务效率和业务结果没什么影响。</p><h4 id="本讲小结-8"><a href="#本讲小结-8" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>如果回到第二模块讲的点线面体，你从“面”看回“点”的价值，这时候你就会发现，今天的手机支付越来越普及，我们对现金已经没什么需求了。所以对于ATM机这个“点”，我们基于上述的考虑，ATM机已经走向没落了，所以基于它的技术开发和优化，可以整体降低投入了。所以当你准备做一个产品的时候，你可以把ATM机这个最简单的产品拿出来对照一下：</p><ul><li><p>第一，你的产品在“点线面体”的什么位置？</p></li><li><p>第二，你提供的是一个什么样的确定性？</p></li><li><p>第三，为了保证确定性的稳定提供，你需要的系统能力都要包括哪些环节？你有足够的资本和能力来支撑所有的环节吗？</p></li></ul><p>很多创业企业其实死在这里，你想提供取现服务，知道一台ATM机价格是20万，但是没有把它要用到的资金成本，以及它的七个岗位的运营成本和能力充分地计算在内。用我们的话来讲叫“老鼠尾巴”，就是你抓了一个很小的东西，你以为这就是全貌，但往前走一走，你才发现好大的一块还在后面，这是你完全不能够覆盖的，这样去做产品其实是很危险的。</p><p>课后作业</p><p>1.挑选一个你最熟悉的产品，说说它应该给用户提供怎样的确定性满足？这个产品做到了吗？如果没有，你觉得问题在哪？</p><p>2.持续的满足就会依赖，不确定的感觉就是伤害。你可以说说，你有没有确定性被伤害的时候？</p><p>欢迎你留言与我分享。</p><h3 id="14-系统效率：小米的效率革命"><a href="#14-系统效率：小米的效率革命" class="headerlink" title="14 系统效率：小米的效率革命"></a>14 系统效率：小米的效率革命</h3><p>这个模块是讲系统能力，产品是一个系统能力的产物。</p><p>本模块的第一课讲的是确定性，如果不能保证确定性，用户是没有办法依赖你的，这就不可能有忠诚用户，所有的铁粉是对确定性有依赖。</p><p>这一课讲效率。为什么讲效率？因为企业是效率分工的产物。</p><p>中国古代是自然经济，男耕女织，一个家庭解决所有的问题，但是现在已经再也不会回到那样的社会了。为什么？太没效率。这个环节应该交给谁做，谁的效率高就分工给谁。所以做产品是建设一套系统能力，提供并保障确定性，而效率则是这个系统能力的一个核心指标。</p><h4 id="小米的护城河是效率"><a href="#小米的护城河是效率" class="headerlink" title="小米的护城河是效率"></a>小米的护城河是效率</h4><p>这堂课的案例，我想讲讲小米，为什么？因为手机的竞争是现在产品竞争最激烈的板块。</p><p>当我们在谈产品竞争的时候，我们拼的是什么？是前端的产品吗？一台ATM机，你表面看到的是ATM机，但实际上让它有用的，是它背后银行的系统能力。那么我们看手机市场竞争的时候，它背后是什么系统能力？</p><p>2011年，小米手机一代发布，三年时间就做到了中国第一、世界前三，在全球的硬件企业中，这基本上是绝无仅有的成长速度。2015年和2016年，这两年小米挺困难的，但是在2017年奇迹般地逆转了。这么大体量的硬件企业在大幅下滑之后还能够快速逆转，甚至再次大幅增长，这在全球的商业领域也是绝无仅有的。</p><p>关于小米之前的快速增长和这一年奇迹般的逆转，流传着很多解读版本。我也有一个解读，而我的关键词就是：“效率”。雷军说过：“互联网思维里最关键的是两个点：第一是用户体验，第二是效率。”他还说过：“小米真正的护城河就是效率，而小米真正要做的就是效率革命。”</p><p>与小米竞争的其他手机厂商，认为小米是在比拼产品，其实小米在比拼效率。2010年，雷军带着十几个人，拿着3000万人民币开始创业。3000万是什么概念？就是500万美元，比今天的绝大多数创业者拿到的钱都要少很多。</p><h4 id="三浪并发，推动小米崛起"><a href="#三浪并发，推动小米崛起" class="headerlink" title="三浪并发，推动小米崛起"></a>三浪并发，推动小米崛起</h4><p>他们最先搭起的是小米社区，聚集了一批手机的发烧友，然后在社区以互动的方式做出了MIUI操作系统。这个过程的主导者是黎万强，他出过一本现象级的书叫<strong>《参与感：小米口碑营销内部手册》</strong>。在这本书里，他很详细地介绍了他们怎么每个星期都迭代一版系统，强制性地每周发新版。每个版本如果采纳了哪个网友的意见，就会专门跟这个网友讲：“你上次提的意见，我们新版已经改掉了”。这个网友就超有参与感，于是就有了第一批铁粉。</p><p>对于这批人来讲，MIUI是他们一起做的，小米是他们一起做的，因此是神圣不可侵犯的。在MIUI发布之后，小米继续采用它的参与感大法，推出了小米手机、小米网电商。我的解读是“个人效率”，小米对“个人效率”做了哪些事情呢？用雷军自己的话来讲：</p><p>一方面，互联网把人数字化了，把每个人的工作成果全都数字化了。所以每个人每天都可以看到自己的数字，数字自然会对人产生压力。员工每天一看自己的数字，就得给自己一个判断。</p><p>另一方面，小米打造了一个全员面对用户的组织结构，接受来自用户的压力。</p><p>这个里面的差别在于，你让员工修改一个东西，两个人是要相互说服的。如果你要拿领导的权威去压他，他可能就会说那我改吧，但心里不服气。如果这个建议是来自用户，用户说不舒服，这个员工自己就默默改了，他加班也得改，而且心服口服。</p><p>2011年，小米推出第一款手机。当时市场上有300多个手机品牌，每个品牌都有几十款手机。那个时候我写过一篇文章《Allin——雷军的极致》，为什么雷军会有这么大的勇气，赌上他所有的一切？一次只推一款主力机型，而不是多做几款手机，降低他的失败概率？这和他以效率为核心的价值观是一脉相承的。</p><p>雷军的评估是，很多公司的研发成本高，是因为要开发将近100个型号的产品。小米是把几乎所有的资源砸在一两个型号上，用这一两个型号卖到一个很大的规模。比如，其他品牌做一款手机的研发经费是1000万，我一年投10个亿，做100款手机的研发，这样就分担了企业的风险。小米是用1亿人民币来研发一款手机，单款小米手机的研发投入可能是同行业的10倍，但是总研发成本，小米却是其他品牌的1/10。所以在这个点上，小米也提升了效率。用这种方法，小米把自己的一个单点做到很强。</p><p>我们再回到2011年、2012年，用“点线面体”的战略结构来看这件事情。</p><p>2011年到2012年这个时间节点，是一个三浪并发的时刻，智能手机大换代、消费升级、网红电商的流量红利。</p><p>产品的新需求、用户的变化、流量的变化，这三个时代级的红利一起撑起了小米手机。我们盘点一下，除了小米之外其他手机品牌，这三大红利，它们吃到了几个？你会发现其他品牌最多吃了其一、其二，而只有小米这个“点”有三个快速张开的“面”共同给它赋能。所以小米只用了三年时间，在三大红利的共同推动下，做到了中国第一、全球前三。这个也很好地阐释了，“点线面体”的战略选择有多重要。</p><h4 id="小米快速逆转的法门，还是效率"><a href="#小米快速逆转的法门，还是效率" class="headerlink" title="小米快速逆转的法门，还是效率"></a>小米快速逆转的法门，还是效率</h4><p>刚才说的是小米的老故事，我更想谈的是小米2017年的新故事——小米是怎么逆转的。</p><p>2017年，小米的逆转靠的依然是效率。2015年和2016年两年是小米的负向周期。2017年初，甚至还有一个评论说：“世界上没有任何一家手机公司在销量下滑后还能够成功逆转，小米前途堪忧。”</p><p>为什么这么说呢？因为手机行业的供应链是全球高度整合的，上游高度垄断，技术迭代很快。所以一个手机的成功，需要一个价值网上的很多合作伙伴共同努力才能实现。但是当一个手机品牌进入下滑周期时，容易导致整个价值网都不看好你，也就意味着来自价值网的支持会减少，这势必会加剧这家公司一步一步滑向深渊。</p><p>先不谈小米怎么逆转，先来谈谈为什么vivo和OPPO这两年胜出了，明面的原因至少包括两条：</p><p>第一，vivo和OPPO的用户体验很好，它们的OS做得非常好。</p><p>第二，它们用的是明星代言的流量模式，从电视上拿到了新流量。</p><p>我写过一篇文章叫《创京东》，做市场的同学应该看看，这个套路在那篇文章中讨论过。小米遇到的问题，首先就是流量不够了，在这之前小米销售纯粹依靠互联网流量、靠雷军代言的单一模式，但后期乏力。互联网的战争就是产品和流量。你的产品够不够硬？你从哪里拿流量？OPPO和vivo显然没什么互联网思维的包袱，就是遵从生意的本质，哪有流量就去哪堵用户。所以OPPO、vivo快速做了渠道下沉，沉到了中国六七级市场——县和镇的级别，在全国开了超过60万家专卖店。这个时间窗口，小米一心一意专注在线上，错过了县、乡市场的线下换机潮。这是两家销量拉开差距的一个本质原因。</p><p>从整个中国的商业格局来看，电商其实只占商品零售总额的10%。到今天，其实90%的人还是在线下买东西，即使你拿到了线上100%的市场，但是在整个大市场里，你也只有10%。联想的杨元庆、360的周鸿祎、小米的雷军，都是中关村孕育的豪杰，怎么可能认输呢？为了和OPPO、vivo对决，小米用了不到一年的时间，就把自己的渠道迅速扩张成了一张立体的网。在这之前小米打的是互联网思维，主要依靠小米官网，同时向京东、天猫这一类的主流电商供货。在这之后，它开始启动了小米之家线下店，然后通过电商磨炼出来的大数据，支持线下零售做高效率的决策。目前，小米的线下零售做到了27万的坪效（零售卖场每坪面积所产生的营业额），排在全球第二，并且小米还打算开1000个小米之家。</p><h4 id="利用个人流量，快速拓展小米小店"><a href="#利用个人流量，快速拓展小米小店" class="headerlink" title="利用个人流量，快速拓展小米小店"></a>利用个人流量，快速拓展小米小店</h4><p>我想再说一个小米零售的创新——小米小店。</p><p>阿里也在做一个天猫小店，但是小米小店的特性是它有小米的供应链优势。</p><p>小米之家是开在一、二、三级城市，而小米小店是只开在县和镇这两级，任何个人都可以申请做小米小店的店主。</p><p>小米利用它的大数据来做审核，比如这个人必须得这个县和镇的地理位置上生活，根据手机定位的活动区域可以做判断。便捷的审核后，小米小店就能快速集聚大量的店主，他们很容易就可以把店开起来。接着这些小米小店的店主，就用自己的模式来拓展流量。产品的竞争其实就是产品加流量的竞争，小米利用了大量的个人流量，把它们变成小米小店来拓展流量。你可以去赶集，可以有个自己的店，也可以摆个摊位支易拉宝。所有的货都是小米统一邮寄给用户。但是客服工作还是这个小米小店的店主来承担，为什么？乡里乡亲比较熟悉，解释起来方便。2017年8月，小米小店全国销售量最高的人是一位镇上的警察，他认识全镇的人，所以大家找他很方便。小米小店是在几乎没有人知道的情况下，用不到一年的时间开了20万家。小米的计划是开到100万家。</p><p>这就是小米的策略，用非常快的速度开100万个小米小店，以此来对垒OPPO、vivo的60万家实体店。为什么在我们都不知道的情况下，小米只用了几个月的时间就可以开20万家小米小店？这靠的是小米长期积累的数据智能，也是小米长期运营的智能效率系统。你会发现，雷军打OPPO、vivo这仗和周鸿祎打瑞星方法有点像，都是在用整个“面”来打一个“点”。现在小米和当年的360有点像，都成为了搭建一个三级火箭的模式。</p><p>小米的三级火箭模式是：</p><ul><li><p>一级火箭：小米手机，也是头部流量。我们都知道一级火箭是不挣钱的，所以小米手机的利润极其低。</p></li><li><p>二级火箭：小米手机拉动的立体化零售渠道。</p></li><li><p>三级火箭：未来MIUI、小米云等互联网业务，才真正支撑起小米的利润以及它的智能化未来。</p></li></ul><p>当vivo、OPPO在跟小米拼手机的时候，小米却在拼效率。手机对于小米来讲只是一级火箭，它的智能化未来，才是真正的核心。此外，雷军还很擅于借势，会持续引入其他的外部势能来为组织赋能。我们在讲“点线面体”的时候说过，CEO最重要的事情就是不断地寻求外部势能为你的组织赋能。比如，小米和武汉成立200亿的长江基金，这意味着什么？意味着雷军有200亿来夯实小米业务，但却没有稀释小米的股份，这是一个很高明的做法。所以小米打OPPO和vivo的这一仗，我会赌小米赢。OPPO和vivo当然是非常强悍的“点”，但是小米是用了几个“面”，建立起了一个复杂的“体”来打这个“点”，并且几个“面”彼此借力。这个战术有非常强的周转空间。</p><h4 id="本讲小结-9"><a href="#本讲小结-9" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>第一，小米打OPPO和vivo，看上去是手机的产品战争，但实际上背后是它们的效率之争。小米展现的至少是两方面的效率：一个是小米组织里个人的特殊效率；另外一个是小米系统性地搭建了智能效率。</p><p>第二，当你决定要做一个产品，准备搭建自己的系统能力时，你先问自己一句“我应该从哪个点来建立我系统性的效率优势？”因为没有效率优势，这个系统是一个没有竞争力的系统。</p><p>关于效率，我推荐一个卫哲的演讲，你可以在得到搜索“卫哲”，查看李翔知识内参转述的《卫哲：五个方面提高效率》来了解。</p><p>再次强调，<strong>企业的存在就是社会效率分工的产物，天下武功唯快不破。</strong></p><p>课后作业</p><p>企业是效率分工的产物，那么你所在的企业的护城河在哪？你觉得它在哪个方面的效率比别人做得更好？</p><h3 id="15-系统世界观：微信、米聊、陌陌"><a href="#15-系统世界观：微信、米聊、陌陌" class="headerlink" title="15 系统世界观：微信、米聊、陌陌"></a>15 系统世界观：微信、米聊、陌陌</h3><p>第三个模块的第三节课，我们来谈迭代。</p><p>迭代是什么意思？<strong>迭代就是小步快跑，把最内核的部分先放出来，不断优化、小范围试错。</strong></p><p>我有个说法：让互联网产品在互联网上生长。</p><h4 id="产品设计要直指人心"><a href="#产品设计要直指人心" class="headerlink" title="产品设计要直指人心"></a>产品设计要直指人心</h4><p>为什么要把迭代作为专门的一节课来讲？</p><p>简单粗暴的回答就是：<strong>版本规划能力是产品经理的重要能力。</strong>当然这是一个角色化的要求，但是为什么要这样做角色要求呢？因为我经常看到有的产品经理出产品规划，第一版产品就无比复杂。我常常听某个产品经理，非常有激情地介绍自己规划的产品，无比复杂。这是一开始就要做整个互联网吗？<strong>判断一个产品经理是否厉害，很重要的一条就是判断他设计的产品第一个版本有多简单、直接、切中要点，能不能直指人心。</strong></p><p>为什么很多产品经理要把产品的第一个版本设计得那么复杂？因为他们不自信。他们对“我只要做强哪个点，用户就必然买账”没把握，而希望在一些附加的功能点上，寻找心理依靠。这种产品天生没劲，怎么可能意外爆发。</p><h4 id="系统能力让微信赢了米聊"><a href="#系统能力让微信赢了米聊" class="headerlink" title="系统能力让微信赢了米聊"></a>系统能力让微信赢了米聊</h4><p>在这节课，我讲一个案例——微信的迭代过程。</p><p>今天，咱们都已经非常依赖微信了，使用微信聊天、支付、玩游戏、订电影票，觉得一切都是如此天经地义。但实际上，它也是从非常简陋的版本，一个非常小的内核开始，一点一点迭代，成为了今天的样子。</p><p>微信是腾讯在2011年1月发布的一款产品，比小米公司的米聊晚两个月。微信的1.0版本基本和米聊一样，应用场景定义为熟人间的通讯工具。简单说，就是可以免费发短信和照片，代替收费短信和彩信。</p><p>为什么说它的定义是熟人间的通讯工具呢？因为微信刚上线时只有四个主要功能：</p><ul><li><p>导入通讯录；</p></li><li><p>发送信息；</p></li><li><p>发送图片；</p></li><li><p>设置头像和微信名。</p></li></ul><p>备注和黑名单功能是在微信的1.2版本才加入的。微信的1.0和1.1版本时，加好友是不需要备注的，因为我不会加陌生人，这里只有我特别熟的朋友。微信2.0版本时，微信用户有400万，而米聊有1000万。所以在微信1.0的时代，不管是功能上还是用户数量上，微信一直在追赶米聊。米聊有开发人员在论坛上说：这是我们米聊新上的功能，截个图，放在论坛立帖为证，微信几天之后就会抄我们。果然，一周之后，微信就抄了这个新功能——语音通讯功能。但是，微信2.0的时候很快就追上了米聊，并从此将米聊远远甩在后面。为什么？抛开前端体验，就系统能力而言，微信的运维能力比米聊强太多。张小龙在做微信之前，做了十年的腾讯邮箱，那是全国最大的邮箱服务平台。它有一个很强的功能是超大附件，要有强大的服务器功能保证，超大数据定点传输中负载均衡，系统不崩溃。微信的背后有数十万台服务器支撑微信的数据流量。这样的系统能力建设，对于腾讯这样的公司是天然的。而创业初期的小米，根本不可能囤积那么多的设备去提升米聊的性能。所以两个前端体验基本一致的产品，你用微信，永远都会觉得很快，而米聊有时会慢、会卡，偶尔会系统崩溃。两个产品的区别在这里就开始拉开了。回到ATM机的例子，比起系统能力，前端那个铁盒子没那么重要。</p><h4 id="微信、陌陌、米聊的不同路径"><a href="#微信、陌陌、米聊的不同路径" class="headerlink" title="微信、陌陌、米聊的不同路径"></a>微信、陌陌、米聊的不同路径</h4><p>微信赢米聊，仅仅是靠系统能力吗？绝不仅如此。迭代中，重要的是次序，前一个动作是后一个动作的预动作。微信2.1版本里添加了一个新的功能，叫做“好友验证”。2.1版本之前，都没有好友验证。随后2.2版本推出一个核心功能，叫做“查看附近的人”。戏剧化的是，微信发布“查看附近的人”功能的同一天，另外一款和它一模一样的产品在苹果的AppStore上线了，这款产品叫陌陌。陌陌和微信在同一天开始，基于位置的陌生人语音社交。米聊就此止步于熟人社交，直到很长时间之后才打破这点，但那时大势已去。微信和米聊刚开始的产品中观设计是一样的，为什么几次迭代之后，走上了不同的道路？</p><p>我个人揣测，因为张小龙、唐岩是湖南人，雷军是湖北人，三个人非常不同。雷军少年得志，非常年轻就成为了中关村的大佬。他的世界一直非常拥挤，他的时间极端宝贵。他个人的需求就是提升与熟人间的沟通效率，没有需求认识一个陌生人。张小龙和唐岩是曾体验过孤独与弱势的人，所以他们有与陌生人建立连接的需求，并且对和陌生人交往过程中，压力点的体验非常清楚。区别是什么，注意一些细小的点，比如“表情包”。人为什么要在交流的时候使用表情？其实是因为用户很多时候找不到合适的词汇。QQ最早就在表情包上下功夫，帮助想表达却老是觉得词不达意的宅男宅女，用一种更轻的思考方式传递自己的想法、感觉、情感。长于沟通、长于说服的雷军、马云，出品的通讯工具，从来不在表情包上下功夫，因为老板没有被辞不达意困扰过。这是什么？这叫<strong>微观体感</strong>不同。在米聊上，你发了一个信息会有信息状态，如果对方读了就会从“已发送”改为“已读”。而微信没有这个设置，为什么？腾讯的高层为了这个点，讨论了好几天，最后还是觉得，这一点点功能会给对方心理压力太大，还是决定不放。我之前说过，马化腾对压力和确定性的体会极深。但雷军一直是大佬，对给人压力这件事，没有那么在意。增加了“查看附近的人”功能以后，微信的用户从400万达到了2000万，与仍然专注熟人社交的米聊拉开了差距。随后的迭代里，微信3.0推出“摇一摇”功能。3.0之后，微信用户上亿，米聊的峰值永远停留在了3000万。</p><p>在这里，我再补一句场景概念。我在《设计产品时要包括产品的场景》那节课说：</p><p><strong>“在万物互联的未来，到处都是屏幕，到处都是网络连接的入口。入口不是场景，能触发情绪才是。”</strong></p><p>米聊的例子，就印证了入口不是场景，不一定产生流量。小米手机年销售几千万台，几年下来应该累计了几亿小米手机的用户吧，而每一台手机上都内置了米聊，但米聊用户非常少。这就叫“有入口，没场景”。</p><p>米聊就说到这里，我们接着说和微信的“查看附近的人”同一天上线的陌陌。米聊的系统能力弱于微信，陌陌难道好吗？当然不。运维能力不足、代码效率差的问题，陌陌在初期其实也遇到了。唐岩告诉我，曾经陌陌流量过大，导致宕机3天，服务器瘫痪。但是3天之后，服务器一旦再次运转，那些饥渴的用户瞬间回到这里，并没有流失。为什么？对于寻求某种满足的人，陌陌能提供确定性满足。</p><h4 id="本讲小结-10"><a href="#本讲小结-10" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>是去连接广阔的陌生人，还是提升与熟人沟通的效率，这是微信与米聊的区别。微信的3.5版本，与陌陌也拉开了差距。3.5版本的微信先做了功能前置，加了“扫描二维码”；3.6版本的微信加了“微信公众号”。从3.6版本开始，微信与陌陌开始走向不同的道路。陌陌继续连接陌生人，而微信选择去连接线下更多的内容与商业，去连接广阔的物理世界。3.6版本的微信，赢了米聊与陌陌，但依然是一个通讯工具。但微信没有止步于此，它继续迭代和蜕变。这节课就到这里，下节课我们继续讲微信的迭代。</p><p>课后作业</p><p>微信的迭代其实有两个价值：</p><p>对外部，可以快速得到用户的反馈，让用户反馈去驱动产品；</p><p>对内部，建立了开发团队的节奏感和确定性，每周都有新版本。</p><p>请分享一下：</p><p>1.你的公司或产品对于新版本的节奏或者感受。</p><p>2.欢迎你谈谈对微信故事的感受。</p><h3 id="16-系统迭代：微信红包的意外与刻意"><a href="#16-系统迭代：微信红包的意外与刻意" class="headerlink" title="16 系统迭代：微信红包的意外与刻意"></a>16 系统迭代：微信红包的意外与刻意</h3><p>微信确实是这个时代最伟大的产品之一，所以咱们用两讲的时间来说一说微信是怎么迭代过来的。即使是用两课的时间来讲，也只能讲一些非常皮毛的东西。</p><p>上一讲，我们说到微信在2.2版本之后就甩开了米聊，从3.6版本之后和陌陌走上了不同的道路。这一讲我们从微信的4.0版本说起。</p><h4 id="迭代中，核心功能最重要"><a href="#迭代中，核心功能最重要" class="headerlink" title="迭代中，核心功能最重要"></a>迭代中，核心功能最重要</h4><p>微信1.0版本，就是一个在熟人之间可以免费发文本信息和图片的工具。</p><p>微信2.0版本，增加了微信的语音功能和“查找附近陌生人”的功能。到这里，微信成为了陌生人语音社交的工具，但还是个工具。</p><p>微信3.0版本的时候推出了“扫一扫”、“服务号”，从这个点开始，微信开始连接世界。</p><p>微信4.0版本的时候，微信推出了“朋友圈”，也就是说微信从通讯工具开始进化，变成了社交平台。</p><p>微信在推出“朋友圈”功能之前，做了两个前置工作：3.5版本加了扫描二维码；3.6版本加入了微信的公众号。这两个动作的价值在于，一个普通人的生活没有那么多可供朋友消费的内容，如果没有这两个前置功能，我们就直接打开朋友圈，会非常难看。</p><p>4.0版本时，你在朋友圈发照片，如果朋友评论，你是没有办法回复评论的。回复评论的功能，直到4.2版本才做出来。这说明什么呢？没有必要憋大招，没有必要把所有功能全都做好再放出来。不能回复朋友在朋友圈下的评论又怎么样呢？如果我非常想回复他，大可以点对点跟他说。所以产品的核心功能点有效比什么都重要，基于核心功能附加的其他功能点没有那么重要，可以一步步来。接着就是微信的4.5版本，推出的就是今天的内容公众号，推动了一批媒体人创业，孕育了一大波网红。</p><h4 id="微信红包的发布"><a href="#微信红包的发布" class="headerlink" title="微信红包的发布"></a>微信红包的发布</h4><p>微信的5.0版本，对微信来说有一个巨大跃升，就是加上了“绑定银行卡”。要知道在5.0版本之前，微信是不沾钱的。如果微信不加“绑定银行卡”的这个动作，没有把微信和钱连在一起，微信就是一个移动版的QQ空间，大家可以在这里晒照片、聊天、彼此点赞。但是微信绝不会成为今天的移动生活场景，甚至是移动商业帝国。5.0版本的第一个挑战是什么呢？那时微信已经有了4.7亿用户了，大家平时用微信的社交功能已经够用了，为什么要升级到5.0版本，又为什么要把我的银行卡绑在微信上？</p><p>关于这一点，我会在微信的6.0的版本里谈。但是微信得先拥有绑银行卡的能力，这个能力点是5.0版本提升的。怎么让大家升级成5.0版本？这个时候微信做了一个非常漂亮的运营，而这个运营是通过产品来完成的。它推出了一个小产品，我想你还有印象，就是“打飞机”。那个时候如果你刚升级了5.0的版本，一打开微信就直接出现一个“打飞机”游戏的界面，然后大家就都开始玩。身边的人听说了也会去升级版本，加入打飞机大战的战团，彼此PK。微信就在不知不觉间，完成了5亿用户的升级。直到今天，我们经常看到一些App拉用户升级，还是会非常傻大黑粗地吆喝一下：“你的版本过低，建议升级”。甚至更讨厌的就是直接闪退，不升级不让用。这就是产品的高低段位的差别，哪怕在你让用户选择版本这一个动作上，怎么能让用户舒舒服服地去更新，差别都是很大的。接着就是刚才已经预告过的微信6.0版本。这个时候，微信面对的难题是：用户为什么要把自己的银行卡绑定在微信上？而且还要在微信上发生钱的流通？这时候有一个重要事件就是微信红包。微信的支付团队是从财付通团队脱胎而来的。互联网圈都知道，大概有十年的时间，支付宝一直都是财付通头顶的一座大山。2013年的第三方统计，移动支付市场，支付宝的市场占有率是76%，财付通只有3.3%，20多倍的差距，这是三层楼和76层楼的体量差别。就是在2013年这一年，诞生了微信红包，改变了支付战局。微信红包是财付通下面的微信支付团队里一个小团队内部做的一个小项目，一群小孩利用自己的业余时间没有做任何的申报，用公司资源就做了。当时微信支付的总经理吴毅在回忆微信红包发布的场景时说，他当时在自己的办公室里坐着，觉得外面的办公区特别吵，一帮人在那儿又喊又叫地折腾。他就推门出去说：“你们在干什么？怎么这么吵啊？上班呢！”这些小孩就说，“我们以前说要做一个发红包的小应用，现在做出来了，特别好玩，要不你试一试？”一个是点对点红包，一个是拼手气红包，当时还是作为一个插件安装在微信里的，大家开始测试，这时候就有人顺手把一个红包丢到了腾讯的一个大群里。于是从根本上改变了支付宝和财付通战局的产品就这样发布了。在此之前，其实腾讯内部都不知道有这样一个产品。接着，我们就看到微信红包从一个小插件，换到了输入框下面的重要位置。现在红包已经成为了微信使用率最高的功能，远远大于“查找附近的陌生人”、“摇一摇”，这些微信的早期里程碑产品。</p><h4 id="圈层与圈层壁"><a href="#圈层与圈层壁" class="headerlink" title="圈层与圈层壁"></a>圈层与圈层壁</h4><p>有两个故事，我想把它拆出来，再讲一下。</p><p>第一个故事，我想通过这个故事讲一个概念词——<strong>圈层</strong>。我们都生活在某个圈层里，而且<strong>圈层之间是彼此不了解</strong>，<strong>也很难破壁的</strong>。比如，我原来腾讯的同事，一个1985年的男生，他做了一个短期小额贷款产品，大概每天有300多万人向他贷款。他基本上是通过大数据的方式去审核筛查，给100万多人放钱。这些人要贷多少钱呢？基本上是贷200块到1000块钱之间，贷款的时间大概是两个星期到两个月。场景就是很多人离发工资还差两个星期，但是实在没有钱撑不下去了，需要借200块钱撑两个星期。所以我当时的第一反应就是，我不能理解为什么200块钱还要贷款？他说：“这就是圈层，是有这样的圈层存在的。你去关注一下这群找我贷款的人的关系链，你会发现，几乎是同一时间，这个人的整条关系链都在借钱。”就是说这个人要借200块，而他身边几乎是人人都在借钱，没有人可以借200块钱给他。这件事情我当时听到是很震撼的。</p><p>回到微信红包，也有一个故事，我非常震撼。刚才说微信红包是在2013年的某一天偶然间发布的，然后就很自然、很流畅地被大家发来发去，进入了各个互联网公司，大家都开始使用。2014年春节，微信红包就达到了它的第一个用户峰值，多少人呢？458万人。这之后的几个月时间里，微信红包的用户数就再也没有突破过这个数字。除夕肯定是红包的高发期，那一天使用微信红包的达到了458万人，之后的几个月，又从这个高峰值上掉下来了，而且再也没有达到过这个数字。这叫什么？这就叫遇到了<strong>圈层壁垒</strong>。所以每次有人问我说互联网圈的核心活跃人数有多少？我就跟他说，有458万。因为这是微信红包按照它的自然能量达到的极限值。像红包这么天然的东西，微信红包操作又是这么简单，但是在没有借助任何外部势能的情况下，将近7个月的时间，它就困在400万用户里无法突破。实际上，互联网的尝鲜爱好者就这么多，它的自然传播极限大概也就是这样了。这个圈层壁是怎么被打破的呢？春晚。我想很多人还记得，2015年微信和春晚合作。我们不得不承认，春节就是我们中国最高的文化势能之一。微信是怎么做的呢？就是摇一摇抢红包，操作足够简单，当天微信红包新增一亿用户。从400万用户到一亿用户，靠春节这样一个核心场景的触发完成。支付宝积累一亿用户用了多久呢？大概是8年，而微信支付是一天。当然，能够一天从400万用户平滑升级到一亿用户，这也是依靠腾讯强大的系统能力。不是随便一个小公司，给你一亿用户你就能接得住。</p><p><strong>支付宝红包有什么不同</strong></p><p>刚才我们说的是微信红包，虽然支付宝红包前面讲过，但这里作为对照你再看看支付宝红包有什么不一样。关于2015年的支付宝红包为什么失败有很多总结，比如社交场景不同。但我们从用户体验来讲：</p><p>微信红包简简单单，发的就是红包，点开就是钱，再没有其他的东西了，拿到就很爽。</p><p>支付宝红包上面则是放了一堆广告。我收发一个红包，还得给淘宝打广告，点红包没有瞄准，可能还点到广告上。这是什么呢？就是不爽。</p><p>关键问题是什么？是支付宝没有认真去总结问题，同样的错误，它在2016年又犯了一次。2015年微信红包通过和春晚合作，用户一举破了亿。2016年，阿里砸了2.69亿元拿下了猴年春晚的合作资格，干什么？就是推支付宝红包。它是怎么做的呢？它当时还提了一个概念叫“集齐五福，分两亿现金”。你肯定也有印象，一堆人都集齐了四福，就差最后一张敬业福。我们来盘点数字，支付宝一共发出了82万张敬业福。而所有的用户里，集齐五福的有多少呢？79万。这样一听没什么概念。我们再扔两个数据出来，参加这个活动的用户有多少呢？最少不可能少于2000万，而支付宝的总用户是多少呢？四亿用户。我们在第一课就讲了，什么叫爽，就是被满足。被满足的感觉就是爽，不被满足就是不爽。我满怀期待，努力了半天去集福，集齐了四个，最后一个没集着，肯定不爽。2016年支付宝红包的不爽率有多高？支付宝花了2.69亿去打广告，如果有2000万用户参与支付宝抢红包的话，不爽的人大于96%。如果说是它的四亿用户都去参与了抢红包，不爽率是99.8%。总之，从此微信支付就一举改变了这种战局。</p><p>现在有不同的统计数据，但总体来讲都说微信支付和支付宝两家的体量是相接近的。从我来讲当然是希望它们继续打，因为商家竞争，我们用户的体验才能变好。</p><h4 id="本讲小结-11"><a href="#本讲小结-11" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>到这里，6.0版本之后的微信就是咱们今天熟悉的样子，它就成了我们今天移动生活的场景。</p><p>我们简单地讲了微信的六次大版本的迭代，它过去一共迭代了几百次。从最早是一个通讯工具，到社交平台，到现在的移动生活场景，甚至是移动商业帝国。它自己从一个“点”变成了一个“面”，最后形成了一个巨大的经济体，无数企业和个人，从生活到财富，光荣与梦想，都能够在微信里得到支撑，甚至在微信上完成闭环。腾讯的强大是这家公司的系统能力，它能够孕育出一批小马化腾，不断在腾讯的土壤中产生像QQ、QQ空间、微信、王者荣耀这一类奇迹级的产品。微信肯定已经成为了一个经济体，但它也只是腾讯公司的一个产品。</p><p>腾讯当然是这个数字时代的一个巨大经济体，腾讯同时也是深圳市的一个企业，只是深圳的350个上市公司之一。</p><p>深圳有350个上市公司，这个城市不过只有37岁，比我们今天很多得到App的用户还要年轻。罗马不是一天建成的。不管我们今天看到的是微信这个我们每天都要依赖的产品，还是腾讯这家公司，抑或是深圳这座城市，都是迭代的产物。我们自己的人生也是迭代的产物。</p><p>从一个最好的内核开始，一个一个动作地持续迭代和一次一次微小的选择，就会成就你的产品以及你的人生。微信不过就是7年，深圳市也不过就是37年。今天你在一个什么样的点位上没有那么重要，重要的是在未来的几年里，你会用什么样的方式持续迭代。</p><p>课后作业</p><p>1.微信红包这样的产品都有好几个月的时间无法突破圈层壁垒，你的产品有没有遇到过这样的情况？你是怎么做的呢？</p><p>2.你的人生产品，你准备怎么迭代呢？</p><p>欢迎你与我分享。</p><h3 id="17-系统生死线：猎豹和它的关键任务"><a href="#17-系统生死线：猎豹和它的关键任务" class="headerlink" title="17 系统生死线：猎豹和它的关键任务"></a>17 系统生死线：猎豹和它的关键任务</h3><p>第三模块的最后一节课，我来讲关键任务——穿越生死线。</p><p>这个话题是我和阿里巴巴管HR的副总裁王民明聊领导力的时候谈到的。我问王民明：“阿里巴巴怎么定义领导力？”他说：“把握客观元素，把事情做成的能力。”接着他又说了一个很有趣的话题，阿里巴巴对领导力的定义就是带领大家穿越生死的能力。</p><p>在日常状态下，大家做流程、分工、项目进度、质量评估，这个叫<strong>项目管理</strong>。但是，在面对巨大压力，甚至是生死存亡的时间点时，在一大堆事情里找到关键任务，带领所有人穿越生死，这个是<strong>领导力</strong>。</p><h4 id="朝鲜商人的生死线"><a href="#朝鲜商人的生死线" class="headerlink" title="朝鲜商人的生死线"></a>朝鲜商人的生死线</h4><p>韩国作家崔仁浩写过一本小说叫《商道》，讲的是19世纪朝鲜时期商人林尚沃，从一无所有变成了富甲朝鲜九道的朝鲜首富的故事。</p><p>这本小说讲了林尚沃的三个节点，分别是：“死”、“鼎”、“戒盈”。</p><p>我们就讲他的第一个节点：“死”，林尚沃遇到的第一个生死线就是一场商战。</p><p>当时朝鲜最有价值的商品是红参。林尚沃带商团到北京和大清商人在做交易时，遭遇到了清商的联合压价。清商希望成交价是70两白银。林尚沃为了扛住价格，借款收购了朝鲜商团所有的人参，形成了垄断。清朝商人就联合抵制，不降价他们就不买。这时，林尚沃面对巨大的压力，他是借的钱，所有的人参在他手上，如果人参卖不掉，贷款的利息他都还不起。这时他做了一个选择：烧人参。反正每天烧一点，如果没有人来买，我就把今年朝鲜的人参烧光，今年中国市场上就没有朝鲜人参了。于是，清商的联盟就崩溃了，按照林尚沃的价格160两白银成交。</p><p>当时有人问林尚沃，你烧人参的时候，有没有想过人参都烧完了，还没有人找你买怎么办？林尚沃说，“在我刚开始动手烧人参的时候，我就已经想好了，如果所有的人参都烧完了，我就跳进火里自焚，和人参一起消失。”这就是生死线，这就是别人不敢玩、不敢拼的风险，就是壁垒。在生死线之外是安全区，安全区是没有壁垒的。</p><h4 id="腾讯用风控能力区分职级"><a href="#腾讯用风控能力区分职级" class="headerlink" title="腾讯用风控能力区分职级"></a>腾讯用风控能力区分职级</h4><p>腾讯的职级系统中，对不同级别员工的风控能力的描述很智慧。</p><p>普通员工，明确知晓常见风险。比如，别靠近水，游泳有风险。</p><p>项目经理，具备风险规避意识。比如，安排活动路线的时候，有危险的地方就放弃、绕过。</p><p>小蓝车估值十亿，一瞬间消失了，这叫不具备风险规避意识。</p><p>总监，有风控能力。我有风险规避意识，明确知道长线风险。避不过的时候，我知道应该怎么组织大家，以及做好突发事件的预案。</p><p>总经理，能操作有风险的执行。常规水域安全但竞争激烈，僧多粥少。有个地方鱼很多，但是要穿过一片风高浪大的地方，我有本事跨越大海，带你们去资源丰盛的地方打大鱼。</p><p>常言道：富贵险中求。</p><p>平平安安，顺顺当当的地方，一定早有人来到这里，趟平所有的坑，控制了核心资源，并定下了有利于他自己的规则。平原地带的竞争，一定是体量大的赢，先到的赢，不要命的赢。所以，如果你来得晚、体量小、还怕死，就踏踏实实地按照项目管理的方法做项目。知足常乐、自求多福，也是一种人生的选择。但是如果你有强悍的愿景，你不甘心，还有另外的道路。</p><h4 id="傅盛带领金山，跨越生死线"><a href="#傅盛带领金山，跨越生死线" class="headerlink" title="傅盛带领金山，跨越生死线"></a>傅盛带领金山，跨越生死线</h4><p>刚才讲了一个小说里朝鲜商人的故事，我再分享一个我身边朋友的故事。傅盛和他的猎豹的故事。</p><p>在第二个模块讲“点线面体”的时候，我讲了周鸿祎如何利用互联网思维杀入了杀毒市场，并且一举占据了杀毒市场大概90%的市场份额。当时杀毒市场里都有谁？老大是瑞星，还有江民、金山。瑞星、金山、江民这三家都是在杀毒这种点状市场里竞争，大家都是一条连贯的曲线，线性发展了很多年。突然冒出来360的降维打击，它们就像遇到了非连续，原来的线性发展无法持续。瑞星、江民持续了十年的线性发展到此戛然而止，而金山跨越了非连续，也就是说它穿过了生死线。有一个很有名的记者——程苓峰，写过一篇很棒的关于这个故事的报道，你可以搜一下看看。360其实是傅盛做的，后来傅盛从360辞职。更加戏剧性的是，2010年他带着自己创业的可牛公司几十个兄弟加入了360的对手金山，合并以后公司就改名叫金山网络，后来又改名叫猎豹。所以他到金山网络的时候，应该算是危机四伏，生死一线，列出来的死法至少有三种：</p><ul><li><p>第一种死法就是可牛和金山合并不顺利，团队崩盘，公司死了。</p></li><li><p>第二种死法就是被360灭掉。2010年，周鸿祎就放话说，当年有一家安全厂商会死，一夜之间卸载了金山网盾的8000万用户。当时网盾的负责人陈勇，一个汉子放声痛哭，基本上大家就知道周鸿祎放言要灭掉的是谁了。</p></li><li><p>第三种死法，他们团队没有崩盘，也没有被360灭掉，但是因为产品没有办法超越360，只能是在股东的保护伞下苟延残喘，赖着过日子，先被嫌弃，再被抛弃，慢慢死去。</p></li></ul><p>死法有三种，而活路只有一条，就是跨越非连续。</p><p>从一家已经有23年历史的软件公司变成一家互联网公司。他们面临的风险是同一个，不改革是等死，改革是找死，甚至有可能死得更快。那个时候傅盛只有33岁，当时他面对的局面还包括傅盛和金山合并的时候，傅盛有40人，金山400人。金山23年了，很多人都在这里干了十多年，所以老金山人是不信任这个年轻人的，并且同时怀疑他的能力。金山的工程师水平不错，所有的企业都跑过来高薪挖人，很可能只要有一个骨干走了，所有人一瞬间就走光了。所以，傅盛在决定接手金山的48小时之内就做了几个决定。</p><p>第一，   我们不能够做一个全新的创业公司，我们需要先守住根基——安全。</p><p>当时金山毒霸的日活跃用户只有700万，而且还在跌，360当时有一亿用户。当时乔布斯回到苹果也是先守根基，第一件事是先重新把Mac做好，推出了iMac之后才推出了iPod，重新奠定江湖地位。</p><p>第二件事就是砍产品，Allin。</p><p>我们在之前讲过，如果你对自己不够自信，才会分散精力，但是如果你内心可以放下恐惧，在最重要的点上全力以赴，才真的有可能把这个点做强。傅盛把金山原有的七八条老产品线砍到只剩下了两个——毒霸、卫士。因为如果你不集中力量肯定是死。所有人员都被抽调去做毒霸肯定不痛快，但是理解得砍，不理解也得砍。</p><p>第三件是就是砍组织结构。</p><p>一个23年的公司，副总裁、高级总监、总监、高级经理一概取消，把整个公司从十来个层级砍到只剩三层：管理层、骨干层、执行层。管理层一竿子扎到底，就像指挥打仗一样，直接过问产品细节，直接跟一线员工和用户沟通。然后把技术、产品、运营、市场、销售、售后这些部门全部打通，所有的职能围绕产品线重新组织。整个公司只剩下两个部门，就是毒霸和卫士，所有的人都为产品服务。产品与研发、市场就不再是平级的了，我是你的领导。</p><p>第四件事，做个野蛮人。</p><p>几刀砍下来，金山的老人们看傅盛的眼光不再是怀疑，而是“你伤害了我们的感情”、“你打破了内部和谐”。傅盛索性就做个彻底的野蛮人，实话都抖出来。金山是一家成立了23年的老牌软件公司，为什么被刚成立几年的360打成这样？就是因为因循守旧、表面和气。我今天是伤害了你的面子、你的尊严、你的友好气氛。但是在生存面前，你能不能放下面子，放下尊严，放下友好气氛，生还是死，我们搏一次。你可以说傅盛运气好，他干完这些事四个月后，就赶上了3Q大战爆发。那个时候腾讯干了“二选一”，要求所有的用户卸载360。腾讯要求用户卸360就必须给出非腾讯的第三方替代方案，当时只有金山一家同时有杀毒和安全的全套产品并且性能完善。这也归功于几个月前傅盛叫停其它业务，全力打造这两款核心产品，并且在3Q大战前一个月推出。腾讯“二选一”三天后，金山毒霸日活跃从700万涨到1200万，卫士从200万涨到1000万。3Q大战打完，360上市了，腾讯开放了。金山这家老牌软件公司完成了向互联网公司的蜕变，跨越了非连续，活下来了。瑞星和江民，今天已经边缘化了。</p><h4 id="领导力的核心，是甄别关键任务"><a href="#领导力的核心，是甄别关键任务" class="headerlink" title="领导力的核心，是甄别关键任务"></a>领导力的核心，是甄别关键任务</h4><p>这个故事核心表达的是什么呢？</p><p>面对生死考验的时候，你能依靠的不是管理能力，而是领导力。</p><p>领导力的核心，是甄别“关键任务”，然后动员大家穿越生死。</p><p>一个人如果曾经有一次穿越生死，他做事的态度，他的笃定和胆魄，一定不同于常人。每天都为一些员工的小情绪纠结掂量的管理者，一定是没经历过生死的。</p><p>傅盛和他的猎豹的故事，我个人非常喜欢。因为他在强敌压境的情况下，完成了一个软件公司向互联网企业的转型，穿越了生死线。并且在这之后，傅盛带着他的猎豹第二次跨越了非连续，完成了向移动互联网，向海外能力扩展的企业能力突破。这个故事我会在第五模块再讲。</p><h4 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h4><p>第三模块系统能力就大致介绍完毕了，我在这里把第三模块简单总结一下。</p><p><strong>所有的产品都是某个系统能力的结果，你要的不是做一个产品，而是建设一套系统能力，然后为你的用户提供确定性。系统能力的效率优势、系统的迭代能力，都不是最后你呈现的产品表面能看得出来的，但是你的系统能力是你的产品能否存在的本质。如果生于和平年代，也许按照项目管理，把项目做好上线运营就好了。但机会、资本、野心、人才云集的今天，几乎每一块蓝海，都会转瞬变为红海。你需要的是像摩西一样的领导力，甄别关键任务，动员众人，劈开红海，带领大家穿越生死。只要你在创业，终有一天会面临跨越生死。那个时候，副总裁、总监通通都帮不了你。这时能够支撑你的，是你对关键任务的甄别，你内心的确认感和你真正的兄弟。</strong></p><p>课后作业</p><p>在跨越生死的关键任务场景下，股东、竞争对手、核心团队、公司中层、公司员工、用户，这六类人你最在意谁？你会把精力放在谁的身上？欢迎你跟我讨论一下。</p><h3 id="模块四）-用户体验"><a href="#模块四）-用户体验" class="headerlink" title="模块四） 用户体验"></a>模块四） 用户体验</h3><h3 id="18-用户体验的五个层次"><a href="#18-用户体验的五个层次" class="headerlink" title="18 用户体验的五个层次"></a>18 用户体验的五个层次</h3><p>我们进入第四个模块——用户体验。</p><p>之前三个模块，我们希望解决的问题是<strong>你能够情绪纠偏、认知纠偏，不再只从原生感受上来看问题</strong>。接着我们讲的是建设系统的能力。厚积薄发，“厚积”是系统能力，“薄发”是表面的呈现，就是用户体验。我们看到很多新的互联网公司、淘品牌，系统能力不如传统企业，但是可以从传统企业那里抢夺大量用户，靠的就是用户体验。在体量差异这么大的情况下，用户体验能成为核心竞争力；同维度竞争的时候，用户体验更是最核心的竞争力。</p><p>从这节课开始，我们要连续用5节的课程讲用户体验。</p><p>我给腾讯起的外号是“拜用户体验神教”，每个人都像念咒一样每天念用户体验。你在腾讯每次想推动事情前进，想拒绝需求，都得提用户体验。用户体验到底是什么？不是一句“好用”或“不好用”能说得清的，我们要拆得很细。</p><h4 id="用户体验的五层要素"><a href="#用户体验的五层要素" class="headerlink" title="用户体验的五层要素"></a>用户体验的五层要素</h4><p>我推荐一本书叫《用户体验要素》，一本讲网站设计的书。我把它的框架，加了一点自己的理解。《用户体验要素》这本书里提到：“用户体验的要素，来自5个层次的层层选择与叠加建设。”这五层分别是：</p><ul><li><p><em>感知层</em></p></li><li><p><em>角色框架层</em></p></li><li><p><em>资源结构层</em></p></li><li><p><em>能力圈范围层</em></p></li><li><p><em>战略存在层</em></p></li></ul><p><strong>最核心的战略存在层</strong></p><p>就是着手做任何一个产品前，必须明确地定义这两个问题，你需要把它们贴在墙上，保证项目组的每个人都清楚，都认同：</p><ol><li><p>我们要通过这个产品得到什么？</p></li><li><p>我们的用户要通过这个产品得到什么，他们为什么会依赖我们？得到我们各自需要的东西，我们才能继续做下去。</p></li><li>你对自己的存在战略设计是什么？你能存在，不是因为你厉害，而是别人需要你，别人能持续依赖你。真正厉害的人，能清醒地认识到这一点。</li></ol><p>我前两天又把毛泽东的<strong>《中国的红色政权为什么能够存在？》</strong>读了一遍，从这篇文章中，你可以看到什么是战略能力。战略能力，讲未来，更讲现在；讲长远的愿景，更讲谁需要红色政权，谁需要持续依赖红色政权。有人需要才是红色政权的存在条件，也是它的发展基础和战略。</p><p><strong>战略层的外延是第二层——能力圈层</strong></p><p>能力圈要确定：</p><ol><li><p>我们要做到哪些事，具体要提供什么样的确定性。</p></li><li><p>我们不做哪些事，对这些事坚决不碰。</p></li></ol><p>35岁的毛泽东对范围层的定义是：农村包围城市。能力圈的建设是：要在三不管地带建立根据地，要建立自己的武装军队。能力圈是变化的。如果有清晰的战略，能力圈就会朝着战略的方向变化、拓展；如果没有清晰的战略，能力圈的变化就是偶发和随机的。</p><p><strong>能力圈的外是第三层——资源结构层</strong></p><p>毛泽东一句话定义了“资源”，就是“谁是我们的敌人，谁是我们的朋友”。建设资源固然和能力有关，但更与战略相关。就好像《西游记》里唐僧取经一路过关，靠孙悟空上天入地搬神仙帮忙。孙悟空能上九重天，敲神仙的门，固然是孙悟空的能力；但所有的神仙肯出手相助，是为了西游的战略——唐僧取经。并且，孙悟空的加入，本身也是唐僧为了实现取经战略必须扩充的能力圈。</p><p><strong>资源结构层外是第四层——角色框架层</strong></p><p>用于网站是框架，用于人世间是角色。框架就是框定每个页面需要有多少元素，它们的链接关系、调用规则分别是什么。你打开任何一个网页，你在感知层感知到的一切内容、功能，都是在这个框架内被框定的。你和一个空姐在飞机上说话，或者和一个银行职员在银行里说话，她的反馈方式很大程度是她的角色框定的。</p><p><strong>角色框架层外就是第五层，也就是最表层的感知层</strong></p><p>我们都很明白感知层，颜色、声音、嗅觉……感知层当然很重要，就好像俊男美女，修饰得体的人永远容易赢得第一好感一样。但是，如果一个设计得非常精美的网站上，找不到你要的内容，无法实现你的目标。你要解决的问题，反而在页面设计非常简陋，而且打开速度很慢的网站上搞定了。你会觉得哪个网站的用户体验更好一些呢？</p><h4 id="百度和Google之争"><a href="#百度和Google之争" class="headerlink" title="百度和Google之争"></a>百度和Google之争</h4><p>五层要素讲了一遍，我举一个咱们经常使用的产品当案例——搜索，把这五层要素再讲一次。</p><p>说到搜索，你一定非常了解百度，也有的人用Google，还有的用户用过一个古老的霸主——Yahoo。IT一般都用蓝色调，Yahoo的主色调是紫色。</p><p>如果有一个场景，用户指着Yahoo搜索的紫色按钮，说：“不好用”。他到底在说什么？“不好用”的体验到底是什么意思？他是说感知层的问题吗？是他不喜欢紫色？还是他觉得按钮的形状不好看，或者尺寸太大了，还是按钮位置不合适？还是框架层的问题，他要的搜索结果没有按照他希望的方式陈列？</p><p>你在百度上搜“顺丰快递”，搜索结果页的第一条就是顺丰单号查询框，之下依次是顺丰官网、百度贴吧的信息等。百度框架的意义就是能让用户在第二个动作得到他要的信息，绝不让用户多点一层。百度能出这样的搜索结果，是因为它的爬虫以毫秒为单位，在抓取各个网站的动态信息。它不但持续积累资源，而且还不断优化自己的资源处理能力。</p><p>Google还在中国开展业务的时候，百度做了Google没有做的动作，自己着手建设内容资源，做了百度贴吧和百度知道。百度贴吧上线的时间是2003年，那时整个中国互联网上的内容都不多。Google的算法当然比百度好，但即使Google抓遍了所有中国网站，也没有足够的内容资源。所以，当时的中国互联网搜索引擎的竞争还是资源量的竞争。百度从2003年开始做百度贴吧，2005年做百度知道，做了大量资源建设的工作。而以Google的清高和耿直，不会做这样的事。当有用户有需求的时候，Google还会为百度导流量，给对手送弹药。</p><p><strong>为什么移动场景的搜索竞争百度会输呢？</strong></p><p>因为在移动场景下，微信干了当年和百度一样的事。微信用公众号的方式，自己培育内容资源。现在你在百度上搜微信公众号的内容，几乎是搜不到的。最新的内容都在微信里了，百度进入移动场景，却没有新内容可供搜索，这是在资源层出了问题。这也是今日头条为什么必须花大力气建设内容的原因，这是资源层的比拼。</p><p><strong>资源层再往下是能力圈。</strong>百度当然建设了符合中国市场特色的能力圈，而Google没有。就中国市场而言，论能力圈，百度赢；论资源层，百度赢。所以，你不能说Google退出了中国之后，才给了百度发展的机会。当然如果Google没有退出，两家竞争，那么百度肯定会比今天更健康。</p><p><strong>Yahoo为什么输给Google</strong></p><p>为什么前面提了一下Yahoo呢？百度贴吧之父俞军给我讲了个故事。</p><p>2004年，一批华尔街精英做了搜索引擎的对比评测，评测结果是Yahoo最好。但奇怪的是，评测完之后，大家平时还是都用Google。为什么大家心口不一？俞军发现，这批华尔街精英的测试方法是选了十几个关键词，在Google、Yahoo等六七个搜索引擎中搜索，打印出所有搜索结果页放在一起对比。每人拿一把硬币，认为哪个搜索结果页更好就投一个硬币，最后Yahoo获胜。为什么Yahoo会胜出？因为当时Yahoo使用的后台搜索引擎也是Google的，但Yahoo对一些热门关键词做了人工优化，它的搜索结果不是跟Google一样，就是优于Google。但是在界面呈现上，Yahoo显示的分辨率很大，banner广告很大，设计很宽松，只看到一两条结果。而浏览Google的搜索结果页，第一屏能多看几十条结果。那些金融精英在工作中还是希望能看到更多内容，虽然Yahoo的内容更好，但宁可一下子多看三四十条。在资源一致的情况下，Yahoo在表层的框架层就输了。三个搜索引擎，感知层差别不大，用户体验的差别其实是分别在框架层、资源层和能力圈层。所以，当一个用户向你抱怨，用户体验不够好，他到底指向的是哪个层的问题？比如一个电商的App，用户说不好用，是前端交互流程的问题，还是供应链的问题，还是他根本就不是你定位的用户？</p><h4 id="看人的五层要素"><a href="#看人的五层要素" class="headerlink" title="看人的五层要素"></a>看人的五层要素</h4><p>做产品如此，看人也是一样。</p><p>开篇结婚教练的案例里讲到：最表层，你接触的都是一个人的仪表谈吐。接着你会发现，一个人的仪表、谈吐、交互方式与他的角色非常相关。如果是浅层关系，了解一个人的角色就够了。但如果你希望与一个人建立的是深度关系、长期关系、战略关系，那么你需要更深地了解一个人角色之内的另外三层：</p><ul><li><p>他的内心是什么？什么是他想要的存在感？</p></li><li><p>他为了自己的存在感，一直在怎样积蓄、打造他的能力圈？</p></li><li><p>他在怎样积累和建设自己的资源，才会拥有今天的角色？</p></li></ul><p>谈恋爱、看人和买产品是一样的，关注的是最表层的用户体验。结婚和股权投资类似，最内的三层更为关键：<strong>一个人对自己存在的自我设定、能力圈建设、资源建设</strong>。所以，我们历数伟人，孙中山、乔布斯等等，你真实地跟他打交道，会发现他们问题太大了。但是他们自我的存在战略，是绝对的、伟大的、独一无二的。当你被一个人感知层的瑕疵折磨，为此怀疑、痛苦的时候，你有没有认真去评估，他天赐一般无可替代的战略存在价值呢？以及你爱不爱他这一点？这就是对一个人做判断时的芝麻与西瓜。</p><p>当然，我有一个完全相反的例子。著名女作家三毛的丈夫荷西对三毛说自己的存在战略：“我没什么追求，不可能有个大房子，我就想有个小公寓，有个你这样的太太，下班给我煮饭。”很多女人一听这个男人这么没追求，可能瞬间就放弃了，再帅也不嫁。但是三毛在这句话中，听到了荷西的未来规划，听到了自己在这段关系中的存在感，听到了荷西对她的接纳与依赖，这就是他们婚姻或者关系的基础。你说他们在之后相处中，感知层、框架层、资源层有没有冲突？当然有，他们来自不同国家，会有沟通、文化的隔阂，生活资源的不满足。但是他们这段关系里的基础始终存在，就是<strong>彼此的存在感，互相认定与依赖。</strong></p><h4 id="本讲小结-12"><a href="#本讲小结-12" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>没有完美的产品，也没有完美的关系。</p><p>做一个产品，就是我要做一个东西，让它成为某些人生活中、工作中可以确定性依赖的存在。</p><p>看一个人，则是我知道对方想成为一个什么样的存在，我是不是认同他想要的存在感。并且站在这个人的立场，接纳这个人的瑕疵，帮助他，成就他。</p><p>乔布斯说自己要成为伟人，荷西说他没什么追求，你是不是认同他要的存在感？</p><p>回顾一下，本节课，密度有点大，概念词有五个：</p><p><strong>战略存在、能力圈、资源结构、角色框架</strong>和<strong>感知层。</strong></p><p>课后作业</p><p>1.一个产品的体验有五层，你能不能说一下，你现在正在做的产品，最核心建设的，或者你觉得做得最优秀的是哪一层？</p><p>2.你有没有处在一段深度关系中，你知道对方自我存在的设定是什么吗？你们这段关系的基础是什么？</p><p>你可以在留言区分享一下。</p><h3 id="19-怎样绘制用户体验的地图"><a href="#19-怎样绘制用户体验的地图" class="headerlink" title="19 怎样绘制用户体验的地图"></a>19 怎样绘制用户体验的地图</h3><p>这一节讲用户体验地图和用户故事。</p><p>用户体验地图就是通过画一张图，用一种讲故事的方式，从一个特定用户的角度出发，记录下他与产品或者服务进行接触、进入、互动的完整过程。</p><p>开始做产品经理的人容易犯的错误，就是用管理员的视角来规划产品。我经常看到这种全局型的产品设计图，复杂、全面、没重点，这肯定是错的。我一般会告诉这种产品经理，请按照一个用户使用的路径，把这个产品设计图再画一遍。从一开始用户怎么进入，到每一步怎么体验，最后怎么离开。这就是我们在《两套经典的用户画像》那节课里讲的，“第一只羊”怎么能够在你的“草地”上活下来，而且玩得很开心的过程。画出“第一只羊”从开始到结束的完整体验，这就是用户体验地图。</p><h4 id="怎么画用户体验地图"><a href="#怎么画用户体验地图" class="headerlink" title="怎么画用户体验地图"></a>怎么画用户体验地图</h4><ol><li><p>一个画像完整的人物角色：需要对“第一只羊”有完整地了解。</p></li><li><p>清晰描述用户的目标和预期：他为什么来到你的草地上？他要什么？比如，用户买钻孔机，但是他的目标不是拥有钻孔机，而是需要在墙上打个洞。比如吃饭，用户目标是吃饱？还是想要营造气氛？还是想获得一次交流机会？搞清楚用户的目标和预期到底是什么。</p></li><li><p>服务触点：用户从接触你的服务，到实现他的目标之间，会跟你在产品上有哪些接触，你需要在这些地方服务用户。</p></li><li><p>用户使用路径：使用路径与服务触点的关系是什么？用户在宜家逛的过程是使用路径；在宜家里向工作人员咨询，到盒子前拿免费的资料是服务触点。</p></li><li><p>用户情绪曲线：场景是要触发情绪的。在整个过程中，用户的情绪是如何变化的？把这个用户从接触你的服务开始，到达成自己的目标为止（或者放弃为止），整个流程画一个坐标图，横轴是用户的使用路径与触点；纵轴是用户情绪。这样你就可以得到一条用户在与你的服务互动过程中的情绪波动曲线了。</p></li></ol><h4 id="为什么要画用户体验地图"><a href="#为什么要画用户体验地图" class="headerlink" title="为什么要画用户体验地图"></a>为什么要画用户体验地图</h4><p>为了避免管理员视角，很多初级产品经理都是用管理员视角在设计产品，有什么产品罗列什么，而不是考虑用户要什么。你要通过用户体验地图，让自己<strong>以用户视角来思考</strong>，用户能不能一步一步实现目标，这个过程是困难还是容易？</p><p>比如，我的一个朋友闫辉做了一个中医养生类的Keep，叫一体。用视频教用户怎么做八段锦、拉筋等等。我感觉产品方向不错，但下载后却发现是产品只有一堆教学视频的罗列，有易筋经、八段锦、五禽戏等等，但我作为用户不知道应该看什么。我问闫辉说，为什么我是你的目标用户，但我没办法坚持用你的产品呢？</p><p>其实可以通过用户体验地图来分析一下：</p><ol><li><p>用户画像：</p><p>亚健康、需要自我调理的人，智能手机用户。</p></li><li><p>我的目标是什么？</p><p>我的目标是调整我的亚健康状态，我的问题是脖子疼、肩膀疼、后背疼。看着视频做动作，不是我的目标。比如，Keep会对新进入的用户提问：你的目标是减肥、塑形，还是练出马甲线？</p></li><li><p>我的触点是什么？</p><p>只有一个，看教学视频。</p></li><li><p>我的使用路径是什么？</p><p>因为我看不到自己的目标，除了自己搜索看视频，没有其他路径。</p><p>以Keep为例，有以下路径：选择减肥；选择能承受哪个负荷的运动；女生最热门的运动；1个月打造马甲线的专项等。多路径的设计，让用户更容易找到合适练习的方式。</p></li><li><p>用户情绪曲线：</p><p>在我需要的前提下打开它，首先没有看到我的目标和这些视频之间的关系。其次没有用户使用路径设计，导致我不知所措。虽然目前内容资源都有，但用户要知道该如何使用你的内容，达到自己的目标。</p></li></ol><p>刚刚讲了很多概念词，所以当产品经理进行沟通的时候，应该如何描述目标、触点和情绪曲线呢？应该用用户故事的方法。</p><h4 id="什么是用户故事"><a href="#什么是用户故事" class="headerlink" title="什么是用户故事"></a>什么是用户故事</h4><p>开放大学是英国最大的大学，它提供的是远程教育，它的网站起着两个关键作用：连接学生与大学；帮助潜在生源找到学校。</p><p>我们来看一下开放大学网站交互设计的变化。一开始，开放大学提供的课程目录是典型的数据库和目录。从学院列表开始，再进入到具体的课程介绍。这种设计的前提是，网站假设用户最想知道的内容是每个课程的详细信息介绍。这种设计其实是给大明用户用的，比如京东就是给大明用户用的，所以它的检索、产品目录很强。这种设计可以让需求明确的用户，沿着搜索、目录，找到自己要的东西。</p><p>选课的交互设计上线之后，设计人员很快发现这种方式不是最佳的。为什么？因为开放大学网站的设计人员认为他的用户是大明用户，但其实他的用户是笨笨用户。他们其实不知道自己要学什么课，更不了解详细的课程信息，他们更关注自己的梦想如何能实现。</p><p>我们来分析下，开放大学可能有以下几种用户：</p><p>一位同学烦透了他的工作，他想寻找更具挑战性的转变；</p><p>一位做会务策划工作的同学，想将这份兼职工作转化为全职，但并不知道这种转化如何实现。</p><p>有少数用户是大明，他有简单直接的目标，学习、考试、拿下一个学位或者证书。但是绝大部分人其实不太了解自己到底要学什么专业，具体要学的是什么课程，以及他们所学的知识能把他们带往何方。</p><p>有一个用户的故事是：一个叫Pritti的年长的巴基斯坦女士，曾经为了家庭而放弃了她的学业。现在，她想拿到她在年轻时错过的大学学位，所以她来开放大学选课。她刚开始的想法是，第一门课要选一门可以帮助她提高英语阅读能力的课，并能帮她恢复良好的学习习惯。于是她和她的朋友努力地查，最后选择了显然不适合她的高级语言学。</p><p>事后她跟产品经理讲她的选课思路，产品经理发现她点击每一个链接都有充分的理由，但是为什么选了不适合她的课呢？因为这个网站没有用Pritti女士能理解的语言表达，网站没有告诉他们应该如何选择。这个网站是给大明用户设计的，产品设计默认用户知道如何根据课程介绍选课，但其实大量来选课的人是笨笨用户，他们不知道自己要什么。</p><p>从这个故事开始，开放大学决定在学生选课之前，先向他们展示其他人上这门课的目的，把一系列用户故事放在网站的课程介绍上。比如茫然的年轻人，通过学习成功转行的故事；Pritti这种年纪比较大的人，重拾学业的故事。其中有一个人通过学习取得了法学硕士学位的故事，开放大学网站是这样描述的：“我花了整整六年的努力学习，每周超过16小时的学习时间，牺牲看电视的美好时光，然而这一切的付出绝对是值得的。我空出星期天的时间来放松，与家人相处，但是我每天晚上和周六都预留出来用于学习，以保证学习进度。这意味着为了保证学习进度我必须要工作到凌晨一点，不过这6年我坚持做到了。”下面页面上展示的，就是他的课程安排。</p><p>对于笨笨这类用户，他们先看了与自己相似的人生故事，知道了对方的困惑和付出，再看这些人选了什么课，花了多长时间完成这些课程，是不是更有感觉？</p><p>开放大学做了什么改变？从一开始，假定用户为大明用户，他们知道所有学院、课程的意义，提供干巴巴的课程信息；转化为了提供给笨笨用户可以理解的场景故事。在此之后，开放大学的宣传从“我们有什么老师和课程”，变成了“我们有什么用户”、“用户故事是什么”。这就像淘宝早期传播淘宝卖家的传奇故事一样，故事更容易在淘宝的卖家中传播。</p><p>回到我们说的用户画像中的“第一只羊”，我们刚才举例的那个大妈，Pritti，就是开放大学新版的“第一只羊”，一只笨笨羊。她自己选课的结果是选了最不合适的课程，如果真的开始学，她一定坚持不下来，这就是羊不适应，死掉了。如果我们只关注数据，而不关注用户故事，那么我们很容易做出的决策是导更多的羊进来。这批被导进来的用户肯定会有问题。如果压力过大，有人就会诡辩数字形成的原因，甚至还会对数据作弊。这就是不关心用户故事，只关心数据转化率的结果。</p><h4 id="腾讯讲用户故事的原因"><a href="#腾讯讲用户故事的原因" class="headerlink" title="腾讯讲用户故事的原因"></a>腾讯讲用户故事的原因</h4><p>我在腾讯工作的几年，每次在做工作汇报的时候，大家很少谈论数据。</p><p>我们有时间坐到一起的时候，反而会花大量时间谈感觉，谈细节体验，谈不同场景的可能性，谈不同人群模式的不同体验。这也是我在第一个模块谈的内容。几年之后，我发现故事比数据重要。因为数据是水管里流的水，是一个常态，是一个结果。用户研究，重要的不是零散地收集数据，拿数据证明自己的对错，而是建立一个有代表性的故事。</p><p>再举个简单的例子，一个女孩与一个男孩相亲，简单地收集数据的做法是问“你有多少存款啊？你有房吗？有车吗？月薪多少啊？“但这些数据只能代表这个人，作为当下这个“点”的截面特性，你能根据这些数据做决策吗？你知道这个人经历了什么，才成为今天的样子吗？每个人对这些数据的解读，肯定是不一样的，而且各有各的道理，各有各的逻辑。大家拿着数据和逻辑PK，其实很难有说服力。</p><p>为什么腾讯内部不讲数据而要讲用户故事？因为老板要观察是<strong>你对用户的感觉有多强，你跟用户的关系有多好。</strong></p><p>说到关系，量子物理中有个定义很有趣，<strong>关系＝信息</strong>。如何判断你跟一个人关系好不好，无非就是你知道多少他的信息，以及他的最新动态信息会有多少跟你同步。你掌握的信息越多，说明你们的关系越好。你对你的经典用户故事是否足够了解，足够深入，足够完整，足够洞察，是判断你跟你的用户关系的标准。开放大学的产品经理，没有把Pritti大妈当做一个选课失败的数据，而是真正了解了她的完整故事。所以一个好产品是从“第一只羊”被真正被满足开始的。我们充分认识这“第一只羊”，能够完全用他的语言说话，你需要了解他的故事。</p><p>一个好产品，是从一个好故事开始的。</p><h4 id="本讲小结-13"><a href="#本讲小结-13" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结一下，我们谈了一个概念叫<strong>用户体验地图</strong>和两个核心观点。</p><p>第一个观点：<strong>故事比数据更重要。</strong></p><p>第二个观点：<strong>一个好产品，从一个好故事开始。</strong></p><p>课后作业</p><p>这堂课最后，再留一个作业：</p><p>说一说你最近的一次产品体验，有没有哪个产品的用户体验地图做得特别好，让你的情绪在每个环节都得到了呼应？</p><h3 id="20-服务蓝图的要素终值，峰值"><a href="#20-服务蓝图的要素终值，峰值" class="headerlink" title="20 服务蓝图的要素终值，峰值"></a>20 服务蓝图的要素终值，峰值</h3><p>上一节课我们讲了用户体验地图。这节课我们讲和用户体验地图对应的另外一张图——<strong>服务设计蓝图</strong>，以及服务设计蓝图的两个核心概念——<strong>峰值</strong>和<strong>终值</strong>。</p><p>第四模块的第一节课，我们谈了用户对产品的体验，其实是从五个层次来谈的，存在战略、能力圈、资源结构、角色框架和感知层。CEO最核心的工作就是定义战略和建设能力圈。用户体验地图的价值让你真切地站在用户视角，来看自己的产品是不是满足了用户的目标。服务设计蓝图是为了解决资源结构和角色框架的问题。</p><h4 id="如何配置资源结构和角色框架"><a href="#如何配置资源结构和角色框架" class="headerlink" title="如何配置资源结构和角色框架"></a>如何配置资源结构和角色框架</h4><p>在上一课，我们说过健身应用里Keep的产品做得很好。健身这件事，用Keep和请私教都可以帮助用户达到目标，但是这两种方式的用户体验是不同的，成本当然也不一样。我很多朋友请私教的是因为人性的懒惰。私教可以通过打电话、发短信等方式，把他拉回健身房。很多动作的训练，如果不是教练监督，自己真的很难完成。教练的介入，对于控制情绪曲线，完成训练任务，有非常大的作用。你作为商家，选择提供Keep这类服务还是私教这类服务，所对应要求你拥有的系统能力、需要设置的资源结构和角色框架都是千差万别的。</p><p>这节课我们要谈的服务设计蓝图，就是介绍如何配置资源结构，以及如何在每个用户触达点上来设置角色框架。用户体验地图是讲“第一只羊”怎么在咱们设计的“草地”上玩得开心，具体在哪个点爽，哪个点不爽；服务蓝图则是站在服务提供者的立场，怎么在总体成本控制的范畴内，给这只羊核心体验，并且保证服务不崩溃。简单说，<strong>用户体验地图是以用户情绪为中心的，而服务蓝图则是以服务流程为中心的。</strong></p><p>没有任何一家公司的服务，能够完成用户所有的期待。如果每一个点都达到甚至超过用户期待，甚至超过了你的资源配置，那你的资源配置一定是超级冗余，相应的成本一定会过高。</p><p><strong>服务蓝图到底要干什么</strong></p><p>服务蓝图要做<strong>一眼、一条路、三个点</strong>。</p><p>一眼是什么？就是产品要第一时间<strong>让用户“一眼”看到自己的目标</strong>。比如，Keep会问用户，你的目标是什么？减脂、增肌还是塑形？健身本身不是目标。</p><p>一条路是什么？就是<strong>产品要有一个清晰的路径</strong>，让用户能够知道如何使用你的服务，用来达到或者接近自己的目标。用户无法走下去，就是服务流程的崩溃点。比如，我打开我朋友设计的一体App，看了一堆视频，却不知道该跟着哪个视频做多长时间可以缓解我的后背疼痛，最后我什么都没选，关掉了App，这就是一个服务崩溃点。</p><p>三个点是什么？<strong>峰值，终值和忍耐底线</strong>。</p><p>先说忍耐底线。比如，吃饭时每个桌子配一个服务员，用户体验当然非常棒，然而对于餐馆来说代价是成本过高。那么多少张桌子配一个服务员合适呢？这就需要找到用户的忍耐底线在哪里。PC时代用户等待一个页面打开的忍耐底线平均数是7秒，等了7秒还没打开，基本上99%的用户就会离开。所以，对成本的控制是本分，但是不能挑战用户的忍耐底线。</p><p>峰值和终值，是由2002诺贝尔奖得主、心理学家丹尼尔·卡尼曼提出的。他发现大家对体验的记忆由两个核心因素决定：</p><p>第一个是体验最高峰的时候，无论是正向的最高峰还是负向的最高峰，一定是能记得住的。</p><p>第二个是结束时的感觉。</p><p>这就是<strong>峰终定律</strong>（<strong>Peak-EndRule</strong>）。体验一个事物或产品之后，所能记住的就只有在峰值与终值时的体验，而整个过程中每个点好与不好，时间长短，对记忆或者感受都没那么大影响。</p><p>比如，大家都喜欢宜家，但宜家也有很多用户体验不好的地方。比如只买一件家具也需要按照路线图走完整个商场；比如宜家店员很少，因此要自己在货架上找货物并且搬下来等等。但是，宜家对顾客的“峰终值”的设置非常好。</p><p><strong>宜家的服务设计蓝图</strong></p><p>峰值是产品试用，如果拆得再详细点，就是坐在宜家样板间的沙发上，或者躺在样板间的床上，体验宜家所营造的小空间。<strong>样板间体验就是宜家服务蓝图的峰值设计。终值就是出口处**</strong>1<strong>**块钱的冰淇淋。</strong>所以我们可以发现身边有不少朋友开心地逛了一天宜家，最后什么也没有买，仅仅在3层喝了一杯会员免费的咖啡就回来了。大多数人的</p><p>心情或者对宜家评价都是不错的，因为他体验了宜家的峰值。</p><p>在迪士尼，峰值一定是某个刺激游戏。终值是累了一天，晚上坐在地上看花车游行和园区上空的烟火秀，大家一边休息，一边仰着头说：“好美啊”。所有的体验过程，肯定都会有各种小bug，但是峰值和终值好，你的回忆便是好的。</p><h4 id="为什么要讲体验的峰值和终值？"><a href="#为什么要讲体验的峰值和终值？" class="headerlink" title="为什么要讲体验的峰值和终值？"></a>为什么要讲体验的峰值和终值？</h4><p>因为<strong>平庸的用户体验无法成就你</strong>。设计服务蓝图核心就是让你在资源有限的情况下，配置你的资源，在关节点上安排角色，保证整体服务路径不崩溃，尽量不压到用户的忍耐底线。然后尽量集中资源，打造体验的峰值，最后再做一个体验终值的美好小尾巴。</p><p><strong>亚朵酒店的服务节点</strong></p><p>再讲一个例子，最近几年比较新锐的亚朵酒店。亚朵的定位是一个中高端的品牌。之前中国酒店都集中在经济连锁品牌或者五星酒店品牌的范畴，中端市场会有空白就是因为有难度。亚朵做了什么事情能在令人觉得有难度的中高端市场建立自己的品牌？</p><p>这里，我先讲亚朵如何设计服务蓝图和峰终体验的，在第五模块，我会再讲它的创新模式。亚朵酒店在设计服务蓝图的时候，是从客人第一次入住亚朵，到他再次入住亚朵的整个过程，中间有十二次端口，也就是亚朵服务的<strong>十二个节点</strong>：</p><p>​    第一个节点，预定；</p><p>​    第二个节点，走进大堂的第一面；</p><p>​    第三个节点，到房间的第一眼；</p><p>​    第四个节点，跟你联系，向酒店提供服务咨询的第一刻；</p><p>​    第五个节点，吃早餐的那一刻；</p><p>​    第六个节点，你在酒店等人或者等车，需要有个地方呆一下的那一刻；</p><p>​    第七个节点，你中午或者晚上想吃夜宵的那一刻；</p><p>​    第八个节点，你离店的那一刻；</p><p>​    第九个节点，离店之后，你点评的那一刻；</p><p>​    第十个节点，第二次想起亚朵的那一刻；</p><p>​    第十一个节点，你要跟朋友推广和介绍那一刻；</p><p>​    第十二个节点，还有你第二次再预订的那一刻。</p><p>亚朵的这十二个节点都不一样，资源配置与角色工作，都是基于这十二个节点。在亚朵入住的时候，有三项服务是为了加强第二个节点的体验强度。比如百分百奉茶，到了亚朵，先给你一杯茶；三分钟办理入住；有时候再做一个“免费升舱”，给用户惊喜。你在亚朵的终值体验是退房的时候，这时服务人员会给你一瓶矿泉水，如果是冬天就会给一瓶温热的矿泉水。亚朵给每个服务都起了个文绉绉的名字，比如临走时给你的这瓶水叫“别友甘泉”之类的。这会给当时用户有概念体验和印象留存，对用户来讲，这就够了。刚才说了亚朵服务蓝图的十二个节点，在这十二个节点配置资源的时候，亚朵采取了“与其更好，不如不同”的策略。你入住酒店时，一推门第一眼看到的是大堂。一般四星酒店装修大堂会花非常多的钱，而亚朵并没有在大堂大理石等地方上多花钱，因为花再多钱也不如五星级酒店。亚朵更愿意做一个有温度可体验的小空间，它会在大堂设一个图书馆，可以在那里看书、喝咖啡，也可以把书拿回房间看。这就是“与其更好，不如不同”。出差的人核心需求就是睡个好觉，床的体验好，对出差的人很关键。亚朵宁愿在床、床垫、枕头上花更多的钱，选更好的品质，降低地毯这类开支成本。这就是一个用户体验地图和服务蓝图的对接过程。<strong>在用户有预设的地方，不要太让用户失望。在用户没有预设的地方，给他惊喜，制造峰值。</strong>所以，亚朵每个房间的平均成本控制得很好，而且做到口碑不错。</p><h4 id="本讲小结-14"><a href="#本讲小结-14" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>我们有了用户视角的用户体验地图概念之后，需要对应做服务蓝图，来安排我们的资源，以及配置每个接触点的角色，用来完成服务。但是企业的资源是有限的，你不可能在所有点都达到用户预期。所以，你需要做的是，在服务蓝图上配置你的资源来制造用户体验，使用户拥有一个美好的峰值和令人回味的终值，并且全程不突破用户的底线。</p><p>课后作业</p><p>这堂课留一个有趣的作业：</p><p>请你按照峰终理论，设计一次约会的峰值和终值。</p><p>如果设计一场你和男朋友／女朋友的约会，你会设计一个什么样的环节，让你对方惊喜万分或者感动？约会结束时，你会设计一个什么结尾，让对方印象深刻？把自己当成导演和恋爱达人，开始设计吧。</p><p>我会挑出在体验设计上最特别的五位，送一份小礼物。</p><h3 id="21-上瘾机制：用户激励系统"><a href="#21-上瘾机制：用户激励系统" class="headerlink" title="21 上瘾机制：用户激励系统"></a>21 上瘾机制：用户激励系统</h3><p>在《来自星星的你》中，全智贤饰演的女主角千颂伊，回答记者为什么会有人喜欢自己，她说：“漂亮就行。”一时被奉为金句，成为所有卖口红、卖面膜的微商的重要依据。</p><p>产品的用户体验，视觉当然是感知层里非常重要的部分。我发现我在“黑”感知层，其实不是的，而是说除了感知层之外，其他许多工作也非常重要。比如，中国有4000个手机游戏团队，一年出1万款游戏，但是能挣钱的只有几十个而已。最后赢的并不一定是美术水平最高的那个，就好像我们最念念不忘的人，不一定是容颜最美的那个。以我的观察，我发现最火的游戏是最懂得激励用户的游戏。你内心难以忘记的人，是那个最长时间激励过你，改变你人生轨迹的人。进入本次课程的重点概念——用户激励。</p><h4 id="什么是激励"><a href="#什么是激励" class="headerlink" title="什么是激励"></a>什么是激励</h4><p>回到我们第一模块谈的生物性情绪，满足了就会感到愉悦。如果满足被阻隔，得不到满足就会难受、不爽、痛苦、不安。所以怎么激励？很简单，就是完成预定动作，给他满足。并且让他清楚，完成预定动作，就能得到满足。这就是激励。海豚顶一下球，给一条鱼吃，就是激励。</p><p>首先，在游戏的体系内，它会拉动你的需求，进而给你满足，让你爽。比如，你玩俄罗斯方块，垒了好高，一直缺一个长条的，可以用来一下子消除四排。你内心的压力就会越来越强，会在内心一直喊：“来个长条、来个长条”。这时突然间，长条来了，一下消了四排，当即画面空旷，一串加分数字。内心觉得很满足、很爽。你知道会有这种爽点，但是不确定出现在哪里。但是游戏也会给你确定性的激励。比如打超级玛丽，吃到一个蘑菇加一条命，伴随着熟悉的“叮”的一声，一个“+1”的符号飘起来，内心当即就很满足，这就是激励。</p><p>不确定的爽点与确定的爽点合在一起，就是用户的体验地图情绪曲线。制作游戏能力的高低，其实就是对用户情绪曲线把握的能力。而游戏的设计，一个非常重要的部分，就是用户的激励机制。游戏是最顶级的社区，游戏之外的所有社区类产品，或需要用户活跃度的产品，都需要把用户激励机制作为非常重要的产品机制。如果你设计一个产品，而没有激励机制，那么产品是不完整的。</p><h4 id="怎么激励用户"><a href="#怎么激励用户" class="headerlink" title="怎么激励用户"></a>怎么激励用户</h4><p>怎么激励用户，怎么激励一个人，其实是一件需要花细腻心思的事。</p><p>李学凌说，游戏中打中一架飞机，视觉做得好的游戏，会给你个很炫的效果，例如击中的声音、火花效果、爆炸的声音、视觉、加分的声音等，所有的细节都让人爽。但如果资源不够，或许做不了那么多的效果，但打中一架飞机，会看到飞机消失了，并且有一个回馈的声音，接着分被加上了。这样一来，如果你的整体游戏激励机制够好，用户依然会喜欢玩。游戏的动力，就是压力感突然被满足，压力释放的爽感、确定性的获得、激励的满足感合在一起，让一个人成瘾，停不下来。不过在游戏中，所有的资源都是虚拟的。只要系统平衡性做好，玩家只要完成动作，就会被激励，这是极其确定的事情。</p><p>现实生活，每完成一个动作，就要给他激励吗？举个例子，员工一项工作完成得很好，老板很高兴，特别做了激励，发100元红包。那么下次，这个员工又完成得不错，还特别给激励吗？那是不是如果一直做特别激励，突然不激励了，员工会不会非常失落？会的。</p><p>举个运营的例子，一个健身App，一直为完成计划并上传的达人发一分到一块钱的小红包做激励。人们健身不断感觉到自己体能和身材在改善，本身是有快感的。大家是为了这种内在激励而坚持健身，App发红包是激励的迭加。但是App自停止发红包开始，用户数据当即大幅下滑，用户研究表明，用户感觉被伤害了。</p><p>其实，停止发红包，对健身本身的快感是没有影响的。发红包明明是做加法，为什么用户却觉得自己被伤害了呢？</p><p>因为这伤害了用户预期，损害了他对确定性的感受。要知道人是非常依赖确定性的动物。确定，就是依赖；不确定，就是伤害。一个确定性的丧失，不论大小，都是非常难受的。所以，所有的改版、新包装、重新装修，都是需要非常慎重的。</p><h4 id="内在激励与外在激励"><a href="#内在激励与外在激励" class="headerlink" title="内在激励与外在激励"></a>内在激励与外在激励</h4><p>刚才我们谈了一个词——内在激励。外在激励和内在激励，是两个心理学的名词。驱使人的行为发生改变的外部因素，比如获得类似奖金、名誉等奖励，这是外在激励。而驱使一个人内心获得饥渴感、满足感、愉悦感的内部因素，就是内在激励。所以，当你要激励一个人的时候，要想想，对这件事真正起作用的是内在激励，还是外在激励。你应该重点依靠哪条线？重点设计哪条线？外在激励还是内在激励？内在激励，是让人能够找到感觉，持续深入，把事情做到位的方式。</p><p>腾讯的联合创始人张志东就专门讲过，腾讯一直非常小心地保持着让员工出于自我满足的愉悦感来做事情。为此腾讯做了大量的组织设置，来保障员工的自我感受。外在激励，则是非常强有力的短期改变用户行为的工具。打车软件的补贴大战，最好地说明了这一点。所以你想清楚，你是要用外部激励，还是要内部激励来做你的激励体系。这个时候你就可以开始设计它，并且不断优化了。</p><p>接着就是设计并不断优化你的激励系统了，激励系统的两个要素是“受激励点”和“被激励能力”。如果你要为一个人或一群人完成某个动作，或者强化某个动作，设计激励系统。那么，首先要做的是测绘用户的受激励点，就是用户会在多少个点上被激励。比如游戏，用户激励的点位，就是用户的成就体系。《王者荣耀》每次越塔强杀的感觉，每次拿到MVP的感觉，每次拿到超神的感觉，好不容易拿到个五杀什么感觉？那就是满满的成就感。勋章、小红花、奖状、奖杯、腰带，这些玩意实际上是成就象征，它们本身是虚拟物品，没有意义，但是它们代表的是人们历经千辛万苦，突破重重挑战后的成就感！</p><p>比如，我觉得Keep的成就体系还可以做得再好一点。因为练出马甲线，还是少数人可以实现的成就，而大量的人是没有成就的。这个过程中，人们如何在Keep里找到成就感，而不是中途崩溃，这是可以优化的。</p><p>公司奖励员工也是如此，不能憋大招到年底再给某个员工发个大奖。受激励点少，最后一招再大，也很难发挥作用。</p><p>刚才说的都是外在激励。我想说说内在激励，谈一谈腾讯管理的内在激励方式。</p><p>腾讯发奖金还是很大方的，这是外在激励。在腾讯公司，公司的日常氛围中，运营出的产品至上、用户体验至上的企业文化，腾讯上至高管下至员工的QQ空间、朋友圈，大家在分享的内容都是各种产品的优化细节。例如，这个按钮从闪一闪改成摇一摇，再变成摇摆15度，这样看起来会比较Q。通过一点点的优化细节，所有人都在讨论，这就是企业文化，可以影响一个人的内在激励。</p><p>你发表了一个你优化产品的小细节，一堆朋友、领导都来给你点赞。虽然这个时候没有奖金，但会形成你内心的满足感。只要你发产品优化的信息，就会有人给你大规模点赞，这也是一种确定性的满足，会让你把这个动作强化。</p><p>你想在腾讯内部刷存在感，你就得在QQ空间、朋友圈里发产品如何优化的，进而就会让一个在腾讯工作的产品经理，天天琢磨怎么优化。一个人的内在激励，不单是自己原生，还来自外部环境的激发、挤压和认同。</p><p>激励系统的第二个设计——定义获得能力并努力降低门槛。</p><p>比如，你要激励你家小孩去骑自行车，但是如果他不会骑自行车，或者他没有自行车的话，再多的激励也无法被转化为行动。激励与对方的能力不匹配的事情，就是无效激励。这种事还是很多的。新创业公司总是发展很快，需要不断有人去做新的事情。这时要非常小心，如果员工能力不匹配，而自己的意愿也不强，老板却一厢情愿地觉得给了老员工一个机会，要让他突破自己，让他试试，这其实是给自己挖坑。因为赶鸭子上架这件事，做不得。</p><h4 id="《王者荣耀》如何降低激励门槛"><a href="#《王者荣耀》如何降低激励门槛" class="headerlink" title="《王者荣耀》如何降低激励门槛"></a>《王者荣耀》如何降低激励门槛</h4><p>关于降低激励门槛，《王者荣耀》依然是个好例子。</p><p>1.两根手指就可以玩，一共就三个技能键。操作简单易上手，基本上是《王者荣耀》获得最多的评论了。对于玩过DOTA、LOL等塔防类游戏的玩家，玩《王者荣耀》会很轻松。</p><p>2.此外，《王者荣耀》对时间的要求低，6分钟就可以打一局。坐地铁、上下班路上、午休吃饭、上卫生间等，随时随地开黑。</p><p>3.同时对设备的要求不高，不管你是iPhone还是安卓，都可以在同一个大区一起玩。</p><p>4.每日任务。你不知道该怎么玩？没关系，每天上来做任务就行了，小到“每日登录”，大到“击败对方10个英雄并取得胜利”，不要让用户思考，用户不需要想他需要干什么，只需要每天打开把任务发给他。只要完成任务就送经验、活跃度、送某英雄的体验等一堆东西。</p><p>这一系列动作是什么呢？就是降低门槛，降低门槛，再降低门槛。降低动作门槛，设备门槛，思考门槛，降低时间门槛。这意味着什么呢？首先，大量的女孩开始玩了。《王者荣耀》女性玩家占比是多少？第三方的统计数据——54%。《王者荣耀》有两亿用户，超过一亿是妹子。有一亿妹子在围观，对男性玩家就是激励。</p><p>我们刚才讲了，用户内在激励，除了自己内心原生的，更多来自于外部环境的挤压、激发和认同。《王者荣耀》因为大量女用户进入、围观、激发，让男用户之间的挤压更强烈，用户的内在激励变得更强。所以如果你设计的激励系统就靠你自己发奖金，这种单点、单向的激励能力是极其有限的。比如腾讯这家公司，比如《王者荣耀》这个游戏，更强的激励是营造了一个场，让用户彼此挤压，彼此激励。</p><h4 id="本讲小结-15"><a href="#本讲小结-15" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>首先，人会上瘾，是对确定性满足感的依赖。</p><p>其实，上瘾机制的设计，就是对用户激励机制的设计。</p><p>激励用户，你需要考虑如何用外在激励和内在激励来交替地持续激励他。设计你的激励系统，设置一系列用户的受激励点给用户成就感，定义他的获得能力，并降低门槛。</p><p>课后作业</p><p>这节课的最后，我们还是通过作业互动一下。</p><p>1.我们讲了成瘾的这个机制，你自己有没有上瘾的东西？</p><p>2.游戏是怎么回事，我们都了解。除了游戏，比如说有人吸猫、吸狗成瘾，举个例子来分析一下这是为什么？</p><h3 id="22-名字是你的文化资产"><a href="#22-名字是你的文化资产" class="headerlink" title="22 名字是你的文化资产"></a>22 名字是你的文化资产</h3><p>这是用户体验模块的最后一课——名字与口碑。</p><p>为产品设计名字、口碑与社交货币，应该算是产品、营销，还是运营的工作呢？不同公司也许有不同分工。</p><p>但是从我自己的角度来讲，为产品起名字，绝对是做产品最重要也是最快乐的事情之一。</p><h4 id="名字是召唤"><a href="#名字是召唤" class="headerlink" title="名字是召唤"></a>名字是召唤</h4><p>名字是什么？名字是召唤。</p><p>《说文解字》中，对名的解释是：“名，自命也。从口夕，夕者，冥也，冥不相见，故以口自名。”意思是说，在早期的社会交往中，原始社会一个部落人不多，人人都互相认识，白天可以通过形体、面貌相互识别，而到了晚上相互看不见，就只能通过呼唤名字才能召唤一个人了。所以名字是用来叫的，不是用来看的。很多演员的名字，别人一看不会念，这人就红不了。你希望成为一个被人口口相传的人，就别起这种大家不会念的名字。所以当大家还没有接触你或者你的产品之前，他已经接触了你的名字，你的名字是先于你给到用户的体验。</p><p>名字是什么？</p><p>阴阳师安倍晴明说：“名字是最短的咒。”咒就是束缚。</p><p>《道德经》说：“无名万物之始，有名万物之母。”</p><p>像我这种对神秘事物怀有强烈好奇心和探究欲的人，对这两句话的理解是：名字是连接人和世界的渠道。我们的祖先发明语言文字的过程，就是一个给万事万物命名的过程。这个命名的过程，也是我们的祖先认知这个世界的过程。罗胖第一次跨年演讲谈新物种的时候说，“新事物出现，人们对它指指点点”。为什么只能指指点点？因为没有名字。有一种推论是，我们的祖先每认识一样新事物，就会依据它外部形态、用途来做出判断，并且固化一个符号代表它，这就是早期的象形文字，这是个很伟大的过程。</p><p>《淮南子》里说：“昔，仓颉作书，天雨粟，夜鬼哭。”天雨粟，有了名字，自然开始为我所用，从此我们可以利用自然。鬼是什么？鬼是未知，你无法描述它，只有混沌的无边想象，所以可怕。一旦你命名了它，抓住它的特征，描述了它，那你就掌握了与它连接的方式。人不怕鬼了，鬼就哭了。如果简单理解，这就是为什么名是最短的咒。你抓住它的特征，就可以与它发生连接。</p><p><strong>名字是召唤世界的咒语</strong></p><p>我曾经写过一篇文章《主观世界的破碎和重建》，讲过一些主观世界和客观世界的分别。天地万物当然属于客观世界，名字属于主观世界还是客观世界呢？当然是主观世界。名字是主观的，因此它有情感温度，有文化偏见，有文化资产。一个强大的名字是带有强烈情感的，对我们有咒语般的作用。比如，你听到一个你喜欢的人的名字，就好像中了一个微笑咒。听到一个你非常讨厌的人的名字，就好像中了一个白眼咒。所以，<strong>当你要起一个名字的时候，你要知道你是在寻找一句咒语。通过这个咒语，你和你的同伴一起召唤你的产品，把它从无到有召唤到这个世界上。</strong>就好像古人在黑茫茫的一片中，喊一个名字，就有人回应。你的所有用户都是因为这个名字，这句咒语，定义你们所有的工作，与你们发生连接。</p><p>我在给一个初中生讲物理、化学，他很不喜欢，觉得枯燥。我说主要是名字不好，如果物理改叫“大自然的秘密”，化学改叫“炼金术”，你是不是就很有兴趣了？小朋友说是啊，那为什么要叫物理、化学这么让人亲近不起来的名字呢？我说大概就是为了隔绝吧，让圈外一看就觉得难，就放弃了，这也是一种命名的意图。比如中国古代算命的书里术语很多，就是为了让你看不懂。他又问我，那语文可以叫什么？我说语文厉害啦，语文可以叫“咒语书”。我只要改改名字，就顿时让孩子对一门课的兴趣和愿望产生了变化，这就是语文的力量。</p><p>人为什么要说话？<strong>说话就是咒语</strong>。舒舒服服的，干嘛要说话？说话是为了驱动别人，驱动世界。比如，我对你说，“给我倒杯水”，你就站起来给我倒了杯水。这不和神话中驱动一块石头去做事是一样的吗？如果你不给我倒，我可以换一句咒语，比如“求求你了，我太渴了，给我倒杯水吧”，我又驱动了你。或者“给你十块钱，给我倒杯水”。用钱或者权力来做杠杆，咒语的力量就增强了。</p><h4 id="名字里的文化势能"><a href="#名字里的文化势能" class="headerlink" title="名字里的文化势能"></a>名字里的文化势能</h4><p>判断一个名字是不是有力，在于能在对方心中召唤出一种什么样的情感。</p><p>举个负面例子，丰田汽车几年前对其在中国的品牌和产品进行了全线更名：凌志改为雷克萨斯，陆地巡洋舰改为兰德酷路泽，霸道改为普拉多。我本来说“我买了个陆地巡洋舰”、“我开霸道”，是不是很有感觉？如果说“我开兰德酷路泽”，是不是完全没概念？不知道品牌公司怎么想的。</p><p>同理，麦当劳通过在中国30多年的运营，麦当劳三个汉字，已经能够在我们心中召唤出非常美好的情感了。突然改叫金拱门，丢掉了过去30多年的情感文化资产，甚至还是负分的。</p><p>阿里巴巴就是一个有文化资产的名字。念这个名字，就会想到天方夜谭的故事，一个快乐的青年，打开了宝库，成为了富翁。</p><p>百度也是一个有文化资产的名字。它们都从长久的文化情感中借了势。</p><h4 id="什么是口碑"><a href="#什么是口碑" class="headerlink" title="什么是口碑"></a>什么是口碑</h4><p>简单说了名字，我们再花一点时间谈口碑，因为它们都是你需要研究的咒语。</p><p>口碑是用户自发产生的，还是我们在做产品的时候就已经设置的呢？关于口碑，雷军和华与华创始人华杉各有一句话，都挺有意思的。雷军说：“什么是口碑？口碑就是把事情做过头。”我和一个朋友说到雷军这句话时，朋友想起了买一瓶阿芙精油的体验。买了一瓶100块钱的精油，结果收到了7件赠品。他收到包裹第一感受是一小瓶精油还寄这么大一个盒子？拆了包裹，他一件一件往外拿赠品，拿到第三件赠品的时候，他已经忍不住说：“还有？”朋友说，在淘宝买个东西有赠品，这事挺正常，买1件赠7件，这真是过头了。但<strong>真的是让人印象深刻，有一种忍不住要和人说说的感觉。</strong>这就是口碑，这里有一个<strong>净推荐值</strong>的概念。</p><p>满意与推荐是两个不同的概念。你做到100分，提供了与产品描述一致的体验，能够及时响应用户遇到的困难，完全符合用户预期。用户满意了，但是他会觉得这都是应该的、分内的、没什么可说的。用雷军的话，<strong>只有超预期把事做过头，用户才会有深刻印象，才会有口碑转化的动力，也就是要从满意变成推荐。</strong></p><p>那口碑是什么呢？</p><p>华与华创始人华杉说：“<strong>口碑叫口碑，不叫眼碑。</strong>”因为人们听说的东西，会远远大于见过的东西。所以，口号、口碑、听觉，成为了传达率的关键。你的口碑的碑文是什么，就是大家提起你的时候，那句像刻在石头上一样的话，每个人说的都是同一句，比如“怕上火就喝王老吉”。同仁堂100年重复的同一句：“<strong>炮制虽繁必不敢省人工，品味虽贵必不敢减物力。</strong>”这才叫口碑。</p><p>华杉认为“碑”本来是视觉的，口碑却成为一个符号，活在口耳之间。所以口碑一定是听觉文案，一定是一句口语，直截了当，脱口而出，不绕弯子。所以，很多产品为自己设计的slogan都是视觉文案，别人就无法口口相传。就像名字是给别人使用的一样，口碑也是替消费者设计一句他要说的话。口碑就是你把那些事情做过头，然后别人要口口相传的时候会说的话。口碑是你要替消费者说一句他要说的话，然后让他说出来。</p><h4 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h4><p>第四模块用户体验告一段落，下面总结一下：</p><p><strong>1.从甄别自己的感觉，理解他人感受开始。</strong></p><p><strong>2.我们学习价值判断，用户研究，建设系统能力。一个产品是一个系统能力的输出结果。</strong></p><p><strong>3.用户体验的要素有五个层次，就你的存在战略来规划积累自己的能力圈、资源，通过角色框架完成用户能够感知的服务。</strong></p><p><strong>4.设计用户体验的峰值和终值，不断倾听，不断优化，设置用户激励系统。</strong></p><p><strong>5.最后，给它一个名字，把它召唤出来，成为这个世界的一部分，与这个世界建立连接。</strong></p><p>到这里，怎么从无到有定义并做出一个产品就讲完了。</p><p>下节课开始，我们讲<strong>第五个模块</strong>，<strong>创新模式</strong>。</p><p>课后作业</p><p>这节课的最后，留一个作业：</p><p>1.说一个你特别喜欢的名字，你为什么喜欢？</p><p>2.这个名字会带给你一种什么样的感觉？尝试着分析一下，你为什么会有这样的感觉？</p><h3 id="模块五）-创新模式"><a href="#模块五）-创新模式" class="headerlink" title="模块五） 创新模式"></a>模块五） 创新模式</h3><h3 id="23-用“用户价值公式”衡量创新"><a href="#23-用“用户价值公式”衡量创新" class="headerlink" title="23 用“用户价值公式”衡量创新"></a>23 用“用户价值公式”衡量创新</h3><p>从这一讲开始，我们进入最后一个模块，第五模块——创新模式。</p><p>为什么要将创新模式单做一个模块？因为没有创新的产品，根本不应该去做。</p><p>我们为什么要做产品？为了帮别人、帮自己。</p><p>如果市场上已经有了同类产品，用户已经用得很好，如果你还做一样的产品，这不是为了用户，只是因为你不服或者心存侥幸。用户为什么还需要你？这个产品真的能帮助你实现自己的人生目标吗？很难。</p><p>我很佩服的产品大神俞军有个用户价值的公式，我觉得这可以很好地回答这个问题。这节课就谈谈俞军的用户价值理论，回答这个问题：为什么唯有创新一条路？</p><h4 id="在增量市场里找机会"><a href="#在增量市场里找机会" class="headerlink" title="在增量市场里找机会"></a>在增量市场里找机会</h4><p>俞军是中国的顶级产品经理之一，做了百度贴吧、百度知道等几个中国用户量最大的产品。</p><p>他对产品经理的定义是这样的：产品经理是以创造用户价值为工具，打破旧的利益平衡，建立对己方有利的新利益链，建立新平衡的过程。</p><p>他没有说做产品，而说的是创造用户价值。用户价值是一个工具，产品经理用这个工具打破旧的利益平衡，建立对己方有利的新利益链、新平衡。</p><p>所有的产品开发与使用都是一个利益链和利益平衡，就好像一条河的流动，是水追求平衡的结果。你要开一条新河，把这条河的水引到自己的河里去，就需要打破这条河旧有的水位系统。</p><p>我曾写过一篇介绍腾讯怎么运营流量的文章，叫《改变大河的流向》。<strong>互联网创业就是挖条自己的沟，抢夺别人江河里的流量，形成自己的河流与生态。</strong>QQ是一条大河，微信是一条大河，百度是一条大河，百度贴吧也是一条大河……大河所过，形成自己的生态，巩固自己的水土。大河之间，小河水也欢快地流淌。看新闻、看菜谱、做运动、听音乐、看视频、订机票、买螃蟹、聊八卦……互联网上江河纵横，8亿网民各得其所，形成了互联网的滚滚流量。</p><p><strong>如何拥有自己的河流与生态？你的水源从哪里来？</strong></p><p>地球上的水的总量是13亿8600万立方千米。这是一个固定的存量，如果你要开一条新的江河，唯有打破平衡把固定循环在某个体系中的水，引流到自己的系统中。这就是基于固定存量市场的运营争夺。</p><p>按照<strong>存量竞争</strong>的逻辑，强者为王、厚黑学、找靠山、向权力寻租、崇拜资源，这些成为了我们的成功学。</p><p>家里没什么背景，人不够狠，心也不黑，不懂办公室政治，不会抱大腿的人，在旧有的竞争模型里是没有成功的机会的。还好我们赶上了互联网代表的新经济。我有个朋友刘韧曾经说过一句话：“我们信仰互联网。”</p><h4 id="互联网不是存量竞争，而是增量竞争。"><a href="#互联网不是存量竞争，而是增量竞争。" class="headerlink" title="互联网不是存量竞争，而是增量竞争。"></a>互联网不是存量竞争，而是增量竞争。</h4><p>曾经存量里的超级大佬，在新的增量市场里可能毫无威胁。比如联想曾经风光无两，直到今天在PC制造业的存量体系里依然非常优秀，但在网络经济里完全没有竞争力，甚至不能威胁一个小创业者。</p><p>服务好你的用户，不用怕那些大佬。这就是我热爱互联网的原因。</p><p>从WPS的挑战，理解用户价值公式</p><p>俞军的用户价值公式：用户价值=(新体验-旧体验)-替换成本。</p><p>我觉得这个公式很好地解释了两个问题：</p><p>为什么在存量市场中竞争先发优势那么重要？</p><p>为什么BAT打创业者非常容易？</p><p>按照俞军的用户价值公式，你要撬动一个用户，依靠的工具是用户价值。那用户能得到的用户价值是什么呢？用户价值=(新体验-旧体验)-替换成本。用这个公式可以解释一下为什么雷军英雄盖世，但当年他带领金山的WPS打微软那么艰难。如果微软Office软件用户使用体验是90分，价格体验50分，两项相乘，微软Office软件带给用户的旧体验算45分。金山WPS软件用户使用体验70分，价格体验90分，两项相乘，金山WPS软件带给用户的新体验算63分。</p><p>用户的替换成本包括什么？品牌认知、获取成本、学习成本、使用成本，包括使用过程中遇到问题得到及时帮助的便利程度等。比尔·盖茨曾经是世界首富，微软公司的品牌、渠道、产品成熟度、客服服务系统都很成熟。网上还有随处可见的用户分享、使用小技巧。所以用户体验非常成熟，用户替换成本很高，我们算用户的替换成本是20分。用户价值＝WPS新体验63分-Office旧体验45分-用户替换成本20分＝-2分。雷军带领他的英雄团队做了一个综合体验很好的产品，但是用户几乎没有得到价值。你认为别人为用户提供了45分的东西，而你为用户提供了63分的东西，你比对手提升了40%的用户价值。可是，你别忘了用户替换是有成本的。真实情况是你付出63分，而用户得到的是-2分。你认为你做得更好，但用户视你为鸡肋。</p><h4 id="创新是小企业唯一的活路"><a href="#创新是小企业唯一的活路" class="headerlink" title="创新是小企业唯一的活路"></a>创新是小企业唯一的活路</h4><p>这是我们的血泪教训，同维度竞争，先发优势是很高的门槛。</p><p>很多朋友，包括雷军和我自己都曾经非常自负，觉得某个产品做得一般，自己可以做得比对方好，于是就杀进去。</p><p>小企业对大企业就得仰攻，那么用户替换成本极高。小企业提供的局部优化，加上用户替换成本可以忽略不计。<strong>如果没有奇招，用同样的产品，小企业仰攻大企业基本上没有赢的机会。</strong></p><p>那为什么BAT打创业企业极其容易呢？同维度竞争，体量大占优，即使它后发。从替换成本开始说，用户替换为BAT的成本几乎为零。替换成本包括哪些？用户体验、品牌认知、渠道方便、学习成本。</p><p>BAT的产品用户体验都不错；</p><p>品牌认知成本为零；</p><p>渠道畅通，用户获得成本几乎为零；</p><p>你已经把用户教育好了，用户切换成BAT产品的学习成本为零。</p><p>市面上有很多音乐软件都做得不错，腾讯出个QQ音乐，功能的使用体验完全一样。腾讯渠道强大，大家很容易知道和安装QQ音乐。腾讯使用资金资源能力，垄断版权，热门音乐“搜得到，能下载”就是核心体验。于是，音乐App就QQ音乐一家独大了。</p><p>这就是BAT的典型打法，因为用户迁移成本极低，用大公司的体量优势，一点一点地优化用户体验，一点一点地挤压你、蚕食你。一个产品，你明明可以做得更好，别人先做了，你可以比原来的产品优化20%～40％的体验，怎么办？看体量，如果对方体量远大于你，就放弃。我们得出的血泪教训——<strong>同维度竞争，体量第一</strong>。就像是两个人拼拳脚，大个子打小个子。</p><p>如果几个竞争者体量差不多呢？那就是红海战争，会有一场漫长的拉锯战。只有两种方式能终结这种同维度乱战：要么有能降维攻击的企业出现，要么是资本意志强行合并。曾经的杀毒市场，千团大战、打车大战、外卖大战，莫不如此。小企业、创业者还有什么机会呢？<strong>小企业唯一的活路就是创新</strong>。小企业想改变宿命，飞跃龙门，唯一的路就是离开存量市场，寻找增量市场。</p><h4 id="傅盛找到新机会"><a href="#傅盛找到新机会" class="headerlink" title="傅盛找到新机会"></a>傅盛找到新机会</h4><p>我再讲一个，创业公司离开存量市场，在增量市场找机会的故事——猎豹CEO傅盛的故事。我为什么喜欢傅盛的故事？因为他本来有机会在存量市场抱大腿，走上一条传统的成功之路。但是他铤而走险，放弃已知而且确认的存量市场，去完全陌生的增量市场摸索，并找到了自己的空间。</p><p>我在第三模块《系统生死线：猎豹和它的关键任务》那节中讲过，傅盛用野蛮人的姿态，甄别关键任务，在强敌大兵压境的压力下，完成了公司从软件公司向互联网公司的转型，暂时活了下来。</p><p>2012年，有人问我能不能投资傅盛，我说当然可以。原因很简单，互联网战争就是流量战争，流量资源最丰富的腾讯、百度以及新崛起的小米，三家一起扶植一个小兄弟傅盛，给的单一任务是让他替大家挡住周鸿祎。我说：“三个最牛的大哥挺一个小弟，而且傅盛本人也很厉害，当然可以投。”那个时候大家都是这么看的，他们和当时的我一样，小看了傅盛。确实，如果傅盛善于抱大腿，当年他就不会离开360。江湖上手握流量最多的三个大哥，为这个小弟安排的路，傅盛还是不会走。傅盛的动作是派了一个团队到美国，干什么？不知道。这个团队就是为了摆脱已知，把自己丢进未知里，在完全的陌生感里找方向、找空间。后来他们找到了猎豹清理大师（CleanMaster）这个项目，然后猎豹公司在美国上市了。</p><p>傅盛为什么要这么做，又为什么成功了？</p><p>傅盛自己都说和360打得非常痛苦，虽然360软件最初是他自己从零做起来的，但即便是他自己，要按照自己曾经成功的路再成功一次，已经是不可能了。360打了3Q大战，把用户数扩展到了3亿，体量已经比猎豹大太多。傅盛说：“对比360，我体量太小，正面仰攻真是不好打。”他拼命做了一堆微创新，比360提前1到2周上线。一两周之后，同样的功能360就会跟上，而用户反而会觉得是猎豹在抄360。这就是用户价值公式说的，当你正面仰攻时，微小的产品优化完全没有价值。傅盛的一个小团队，到美国做了一个之前从没有人认真做过的清理大师，并借助Google应用商店快速多语种全球化。这就是在以前没有人踏足的地方，踏上自己的足迹。在以前用户体验为零的地方，你的60分就是干干净净的60分，对于用户就是及格的。</p><h4 id="本讲小结-16"><a href="#本讲小结-16" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>存量市场，小企业正面仰攻，新体验做到80分，用户体验为零分。增量市场，在用户体验为零的地方，你只要做60分，用户就结结实实地觉得可以用了。俞军说：“当你找到蓝海，找到一块用户体验为零的领域，你需要做的是什么？你需要把用户体验做到100分再发布，还是做到60分就快速铺开市场？当然是产品做到60分就赶紧上。”<strong>速度第一，快速感染用户铺开市场，让最多的用户体验到你</strong>。这就是给后来者的壁垒，这就是蓝海的意义。就好像当年在欧洲大陆混不下去的西班牙人，到了南美所向无敌一样。那些在欧洲的宫廷里混得很好的人，当然不会冒着风险穿越大海。现有存量市场的既得利益者，也犯不着考虑创新。<strong>创新，找蓝海，找到没有大佬、用户体验为零的增量市场，是新公司唯一的改变命运的机会。</strong>这是我在最后一个模块，用一个模块讲创新的原因。</p><p><strong>你问我去向何方，我指着大海的方向。</strong></p><p>课后作业</p><p>你觉得你用过的什么产品用户迁移成本特别高？什么产品用户迁移成本很低？</p><p>说说你的体验，咱们在讨论区讨论一下。</p><h3 id="24-用“交叉视角”跨界创新"><a href="#24-用“交叉视角”跨界创新" class="headerlink" title="24 用“交叉视角”跨界创新"></a>24 用“交叉视角”跨界创新</h3><p>这是我们创新模块的第二讲，这堂课只有一句话：“未来已来，只是分布得不均匀。”这句话是什么意思？我先给大家讲个故事。这是婴儿恒温箱是怎么被发明出来，又是怎么迭代产品的故事。</p><h4 id="婴儿恒温箱的发明"><a href="#婴儿恒温箱的发明" class="headerlink" title="婴儿恒温箱的发明"></a>婴儿恒温箱的发明</h4><p>19世纪70年代后期，妇产科医生斯蒂芬·塔尼在繁忙工作之后，给自己放了个假，去巴黎动物园散步。那时候相当于中国的清朝，鸡鸭等都是动物园里的观赏动物。动物园他看到了小鸡的孵化器。斯蒂芬看到了从小鸡孵化器中刚孵出的小鸡，在温暖适宜的环境中蹦蹦跳跳，他有了一个想法。他聘用了动物园的家禽饲养员奥迪尔·马丁，两个人合作用小鸡孵化器的模式，制作出了给人类的婴儿恒温箱。19世纪末期新生婴儿的死亡率高得惊人。斯蒂芬做了统计，使用了他做的婴儿恒温箱之后，体重过轻的新生儿死亡率从66%降低为38%。每一个数字，都是一个人的生命。第二次世界大战之后，婴儿恒温箱已经成为美国的每家医院的标配，让1950年到1998年，近50年间新生儿死亡率降低了75%。研究认为，婴儿恒温箱的发明对公共健康有巨大的保护作用，超过20世纪其他任何一项发明。因为它是在生命之初提供帮助，让一个新生儿拥有了人生。这么伟大的发明，来自于一个医生去逛动物园，看到的小鸡孵化器。</p><h4 id="未来已来，只是分布不均"><a href="#未来已来，只是分布不均" class="headerlink" title="未来已来，只是分布不均"></a>未来已来，只是分布不均</h4><p>这节课的核心概念就是：“未来已来，只是分布得不均匀。”</p><p>跟这个观点意思一样，还有一本专门介绍创新的书《伟大创意的诞生》中，介绍了一个概念叫“相邻可能”。我们需要的某种能力要素，它可能已经产生并成熟了，只是它正在另外的某个领域被使用着。就看这个已经存在的未来，它会不会撞到你眼睛里，让你<strong>起心动念</strong>。这就是灵感的瞬间。所以，婴儿保温箱的发明者到底是谁？是斯蒂芬，还是动手做出了小鸡孵化器，又用同样的技术辅助斯蒂芬做了婴儿恒温箱的动物园家禽饲养员奥迪尔呢？当然是斯蒂芬，因为起心动念的人是他，定义产品的人是他，完成产品化关键环节推动的人还是他。此外，斯蒂芬还做了一个非常重要的工作。他知道法国的医疗机构对于统计数字的依赖，因此他在将婴儿恒温箱投入使用后，马上跟进数</p><p>据调查。“使用恒温箱后新生儿死亡率从66%降低为38%”，这个关键数据就是斯蒂芬给出的调研结果。这个统计结果，迅速撬动了所有的关键资源，从医疗机构、媒体，到投资大佬、慈善人士全面关注，推动了这一设备的普及。</p><p>斯蒂芬不仅完成了产品的定义，产品的实现，并且提供了产品市场化的关键动力。所以，虽然动手实现婴儿恒温箱的人是家禽饲养员奥迪尔，但是我们仍然认为这个伟大产品的发明人是斯蒂芬。</p><p>就好像第一代QQ的每一行代码，都是吴宵光写的，但是QQ之父是马化腾。因为是马化腾起心动念做了QQ的产品定义。</p><h4 id="婴儿恒温箱的迭代"><a href="#婴儿恒温箱的迭代" class="headerlink" title="婴儿恒温箱的迭代"></a>婴儿恒温箱的迭代</h4><p>婴儿恒温箱还有一个迭代的故事，也非常动人。二战后，婴儿恒温箱等技术的广泛使用，已经提高了欧美国家的初生儿的存活率。但是在很多条件不好的发展中国家，比如利比亚和埃塞俄比亚，初生儿死亡率依然很高。其实，这些婴儿中大多数都是可以存活下来的。</p><p>给这样的地方提供婴儿恒温箱的关键难点在哪里？</p><p>首先，当时的婴儿恒温箱非常复杂，而且很贵。美国医院使用的一台标准化婴儿恒温箱，售价大约是4万美金。从根本上说，贵并非是一个不能攻克的难题，总有类似比尔·盖茨的人愿意捐赠。</p><p>真正的难点在于，复杂的设备容易出现故障，而维修依赖专业的技术人员和维修备件。</p><p>2005年，就是印尼海啸发生后的第二年，一些国际救助组织捐给印尼一个城市八台婴儿恒温箱。2008年年末，也就是三年后，麻省理工学院的教授普赖斯蒂洛去访问这个城市时，发现这八台恒温箱全部出了故障，停止使用了。原因当然是各种各样的，比如当地的供电功率常常波动，电压不稳，湿度高等等。关键问题是什么呢？坏了不会修。当地的工作人员看不懂恒温箱上的英文维修手册，只能任由婴儿死去。</p><p>这八台恒温箱的故事，是一个典型的例子。很多案例表明，捐赠给不发达的发展中国家的各项技术设备中，大约有95%的设备会在前五年就因为故障而无法再投入使用。</p><p>普赖斯蒂洛就起心动念，为发展中国家研发一种新的婴儿恒温箱。他出了迭代的产品，产品需求是这样的：</p><p>这个新设备不仅应该更加可靠；</p><p>而且还要造价便宜；</p><p>最重要的事情是，一旦出现故障，这个设备不会完全瘫痪，稍加修理就可以再次投入使用。</p><p>这就是新婴儿恒温箱的产品定义。</p><p>这个产品的基础功能依然没有变：为初生婴儿提供恒温、透气的保障性空间。而这次产品迭代的核心变化，是对<strong>外协资源</strong>做了完全不同的定义：在当地的社会条件下，一定可以修。</p><p>可以修要保障两点：可以找到维修人员；找到维修备件。</p><p>普赖斯蒂洛做了这个产品定义之后，接着就发动团队开始找实现方法。找到方法的并不是普赖斯蒂洛本人，而是另外一个医生罗森。罗森是波士顿的医生，他通过观察发现，任何一个发展中国家的小城、小镇，都有汽车的维修和保养能力。这些城镇里就算缺少空调、笔记本电脑或者有线电视，也都能够确保让汽车在公路上跑。于是，罗森就向普赖斯蒂洛提议：可不可以用汽车的零部件，来改良出一种简易的婴儿恒温箱呢？</p><p>在罗森提出他的创意的三年后，普赖斯蒂洛团队，做出了新的婴儿恒温箱原型，他们给它定的名字叫育婴器。设备流线型的外观和现代的婴儿恒温箱一样，但是它的内部则是用汽车的部件来拼接完成的：</p><p>育婴器由旧车的头灯的前聚光灯提供主要的供暖；</p><p>用汽车仪表盘的风扇，用来保持空气流通，循环空气；</p><p>用车门的蜂鸣器做报警系统，在供暖设备出现问题的时候，蜂鸣器会叫，用来提醒护理人员；</p><p>它的动力主要是来自于标准的摩托车电瓶，或者一个改良的雪茄打火机。</p><p>这个利用汽车零部件做成的育婴器有双重的好处：不仅可以直接利用当地供货充足的汽车零件；同时只要是汽车维修人员，就可以来修理这个育婴器。</p><p>这就是普赖斯蒂洛和罗森的设想，如果要让发展中国家的婴儿真正被育婴器保护起来，育婴器的配件必须能够轻易在本地获得。并且维修这种育婴器的人，不用是那种所谓的高高在上的技术专家，甚至根本就不需要去阅读维修手册，他只要有能力换一个出故障的车头聚光灯，就能够轻松地胜任育婴器的维修和护理工作。</p><p>普赖斯蒂洛教授的汽车配件育婴器，造福了无数的孩子与家庭。</p><p>这是慈悲之心。这是超级伟大的产品人。</p><h4 id="本讲小结-17"><a href="#本讲小结-17" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>我觉得婴儿恒温箱的发明与迭代的故事，非常动人。</p><p>用于培育小鸡的器皿，用于汽车、摩托车的零件，用另外一个视角和用途需求去看，它们就有了新的可能，给予了数以亿计的人生命。有时候，大家想到创新会觉得高不可攀或者神秘浪漫，似乎创新就必须超越环境，横空出世。其实不是的。</p><p><strong>创新重要的是面对痛苦，起心动念。</strong></p><p>如果斯蒂芬医生，不曾为了新生儿的死亡而痛苦，他看到小鸡在孵化器中蹦蹦跳跳就不会怦然心动。如果普赖斯蒂洛教授不是痛苦于，一边婴儿死亡率高居不下，一边八台婴儿恒温箱无法运作，就不会起心动念，用发展中国家随处可得的材料重构婴儿恒温箱，就不会有之后的这一成果。所以，为某件事感到痛苦，也许就是你心念已动的时候。而要寻找解决它的创新之处，不妨到其他领域转转。也许它们就正在某个动物园，或者某个车库里，等着你的眼睛看到它们。</p><p>还是那句话：“未来已来，只是分布得不均匀。”</p><p>课后作业</p><p>你知道还有哪些这种嫁接创新的例子，欢迎跟我在留言区分享。</p><p>这节课就上到这里。</p><p>你想实现的，也许答案就在你隔壁的某个行业。</p><h3 id="25-怎样从新要素到新物种"><a href="#25-怎样从新要素到新物种" class="headerlink" title="25 怎样从新要素到新物种"></a>25 怎样从新要素到新物种</h3><p>这是创新模块的第三节课，这一课，我们谈新要素。</p><p>新要素这个概念，字面意思很普通。每个人都有这个意识，任何一个新产品，总得有新要素在里面。比如服装采用最新的面料，食物采用最新的食材配方，手机采用了最新的屏幕，这些都是新要素。</p><p>我今天想谈的是新要素与新物种的概念。</p><p>如何利用不是本行业体验迭代产生的新要素，而是引用跨行业的新要素，让你的产品看起来依然是原来的产品，但是它已经成为了一个新物种。</p><h4 id="新要素一：找到实体空间的好位置"><a href="#新要素一：找到实体空间的好位置" class="headerlink" title="新要素一：找到实体空间的好位置"></a>新要素一：找到实体空间的好位置</h4><p>我主要讲一个案例，就是“服务蓝图的核心要素：峰值、终值”那节课讲到过的亚朵酒店。</p><p>曾经大家认为，酒店行业最难做的是中档酒店。但是亚朵酒店用了不到5年时间，在全国110个城市开了150家酒店。而且，在2017年的《中国中端酒店投资报告》中，亚朵在用户满意度、投资回报率、投资人满意度三个维度上，同时位居第一。</p><p>它做了哪些不一样的事情？</p><p>我们在“服务蓝图的核心要素：峰值、终值”那节课讲了它有哪些细节做得不一样，但这些是优化前端体验的东西，而这一课我们来说它的商业模式的变化。我们把互联网商业简单地抽象为三个要素，产品、流量和转化率。那么，实体商业可以简单地抽象成四个要素：产品、空间、流量和转化率。我在准备产品课案例的时候，在空间上创新的产品，我想到过好几个，比如：亚朵、漫咖啡。在对亚朵的具体访谈过程中，我发现亚朵不仅仅在空间的定义和运营上做了创新，而且在流量和转化率方面，也有不一样的尝试。今天我谈一下，它在流量和转化率方面的一些新要素尝试。</p><p>实体经济要拼位置，为什么？因为位置即流量。所以，亚朵需要和能取得好位置商业地产的人合作。在好的地段，开一家前端服务体验不错，成本能控制的酒店，赚钱是大概率事件。在亚朵的商业体系中，有两个核心角色系统，一个是亚朵酒店管理公司，一个是房东。</p><p>在这个角色系统里，亚朵的核心工作有六项：</p><p>定义亚朵的服务品质，包括但不限于软硬件要求（空调、暖气等等）；</p><p>提供亚朵视觉系统的装修方案；</p><p>为每个酒店输出总经理和人力资源经理；</p><p>为所有员工提供培训和考核；</p><p>全网打通亚朵网络预订通道，将酒店收入项及时向房东结算；</p><p>对亚朵品牌及各店进行形象推广和公关宣传。</p><p>房东做什么呢？房东有四个核心工作：</p><p>找到当地适合开店的房子，适合开店有很多要求，地段、位置、房租价格等，这个由房东搞定；</p><p>按照亚朵提供的装修方案进行装修；</p><p>招聘该酒店除了总经理和人力资源经理外的所有员工，并按照亚朵给予的考核标准及时结算工资；</p><p>先行支付前期所有因租房、装修、雇佣人员等发生的款项。</p><p>亚朵之所以能开得这么快，是亚朵酒店管理公司与当地一个个房东一起合能的结果。合能就是把能力合起来，彼此赋能。酒店该开成什么样？人该怎么管？如何利用互联网炒作知名度？优化转化率达到用户？这些事情都是亚朵的专业。</p><p>房东的核心能力就是落地的能力，找到地段好、租金合适的房子，而且能够处理所有属于当地的消防、招聘员工等问题。当然，还有一个很重要的能力，就是房东得前期投资。大概要投多少钱？平均一个亚朵酒店前期需要投2000万。</p><h4 id="要素二：把“消费者”变成“投消者”"><a href="#要素二：把“消费者”变成“投消者”" class="headerlink" title="要素二：把“消费者”变成“投消者”"></a>要素二：把“消费者”变成“投消者”</h4><p>这时我们就要谈亚朵定位之外，第二个新要素——亚朵众筹酒店。如果我有能力搞定一个不错的房子，但是我没有2000万怎么办？亚朵推出了众筹酒店的模式，把筹备中的酒店项目作为一个项目融资，在众筹平台上发起众筹。投资人可以出资1万元到10万元不等，参与新亚朵酒店的股权融资，并获得经营分红。比如，天津小白楼亚朵发起众筹，只用了2个小时预约金额就已经达到了募资需求，5小时预约总金额超过5000万。</p><p>为什么会这么火？</p><p>第一，一个人的参与款是10万元，参与人数会更广泛。绝大多数家庭都有10万元的投资能力，但是如今10万元很难参与像样的项目。天津小白楼亚朵酒店算是个地段好的品牌项目，并且给出了较高的年回报预期，大股东还承诺分红达不到承诺值时，由特许业主补足，当然大家热情就很高。</p><p>第二，除了投资收益外，参与众筹的投资人，还可以获得对应等级的酒店消费权益。这时就可以对朋友吹牛，“我是这个酒店的股东，报我名字能打折”，这个对于中国人来说很重要。</p><p>第三，我最想强调的一个，历次亚朵酒店发起众筹时，最热烈的支持者首先是亚朵酒店的用户和忠诚会员。以小白楼项目为例，两个小时就达到了预约的募资需求。其预约的投资人65%以上都是亚朵消费者或会员。他们是亚朵产品的体验者、消费者，现在经由众筹升格为投资者。所以，亚朵的投资者也都成为了高忠诚、高黏性的消费者，最早参与亚朵众筹的7500位会员，每人每年平均在亚朵住宿15间夜（酒店行业统计所有房间出租天数的单位）以上，这些人累计贡献间夜量达15万。他们不仅仅是消费者，更是“投消者”。一方面，亚朵在授权一些特许业主投资的时候，这些人就会积极响应众筹，同时他们是亚朵最忠诚的消费者。这种“投消者”模式成了亚朵品牌扩张中最重要的盟友。</p><p>亚朵在流量方面的创新有：</p><p>第一，亚朵使用了众筹这个新要素，不但让一批有能力搞定房子和关系的房东，不会因为没有2000万启动资金而被阻止开酒店。</p><p>第二，通过众筹让上万人成为投资参与亚朵建设的小股东，这群人是亚朵真实的铁粉、死忠粉、带路粉。</p><h4 id="要素三：IP酒店亚朵在流量方面的另外一个创新就是IP酒店。"><a href="#要素三：IP酒店亚朵在流量方面的另外一个创新就是IP酒店。" class="headerlink" title="要素三：IP酒店亚朵在流量方面的另外一个创新就是IP酒店。"></a>要素三：IP酒店亚朵在流量方面的另外一个创新就是IP酒店。</h4><p>在影视行业，这两年IP特别热，为什么热？<strong>IP就是情感触发，就是场景，就是流量。</strong></p><p>什么叫情感触发，场景流量，请回头去看《设计产品时要包括产品的场景》那一讲。既然我们已经说了，实体生意就是产品、空间、流量和转化率。IP即是新流量，为什么不用呢？何况还有众筹酒店这个杠杆。他们把亚朵和吴晓波合作的亚朵·吴酒店定义为“社群酒店”。《吴晓波频道》自己介绍亚朵·吴酒店的时候说：</p><p>第一，社群活动。未来每一座城市的亚朵·吴酒店，都会成为《吴晓波频道》的线下社群场景。这里是《吴晓波频道》社群线下活动的场所，全国书友会的小伙伴都可以到亚朵酒店申请场地举办“每月同读一本书”等活动。</p><p>第二，阅读空间。在“《吴晓波频道》&amp;亚朵24小时阅读空间”活动中，你可以读到我们精心挑选的图书。旅行和读书这种场景概念便可以结合起来。</p><p>第三，场景电商。这里是场景电商的试验田，我们可以在这里看到《吴晓波频道》精选的“美好的店”产品陈列，在实际使用场景中体验到这些产品。例如，在睡前抿一口安枕的吴酒，喝一盏巴九灵茶田的茶，在猫王收音机里，听一集《每天听见吴晓波》。</p><p>利用吴晓波的品牌场景和《吴晓波频道》已经建设的社群流量，优化入住转化率。现在亚朵·吴酒店已经开了两家，北京、杭州各一家，前一段热炒的杭州网易严选酒店也是亚朵做的。亚朵的计划是未来10%的酒店是IP酒店，因为地段自带流量，IP也自带流量。</p><h4 id="要素四：场景电商"><a href="#要素四：场景电商" class="headerlink" title="要素四：场景电商"></a>要素四：场景电商</h4><p>第四个新要素，刚才介绍亚朵·吴酒店的时候带了一句，就是场景电商。你在亚朵酒店体验到的东西，例如枕头、床垫、洗发水都是可以买的。在讲服务蓝图的时候，我说过亚朵在它的床垫上比较下功夫。2016年，亚朵床垫卖了3万张，即使对于一个天猫店来说，这都是一个不小的量。亚朵创始人说到将来亚朵开到1000家店的时候，一年会有至少600万独立用户，真实体验亚朵空间的各个产品，因此亚朵有机会成为一家巨大的电商公司。</p><p>再说，亚朵创始人对亚朵空间定义的第一条，之前提到实体经济的四个重点：产品、流量、空间、转化率。亚朵的空间定义不仅是休息空间，也不仅是基于用户体验地图优化的峰终体验，而且还是用户在不同的地方体验各种生活新产品、所见即所得的电商空间。</p><p>你住亚朵酒店，不管它在用户体验地图，在你体验的峰值、终值上如何设计，从用户体验上它依然是个酒店。不像上一节课讲的小鸡孵化器变成婴儿恒温箱一样，成为了不同的东西。但是，用户体验没有很大变化的亚朵酒店从经营角度来讲，其实已经成为了一个新物种。因为它的流量模式、融资渠道、收入来源都发生了变化，使它与传统酒店业有了完全不同的腾挪空间和借力点。别人只能收房费，但它至少有三种利润来源：房费、商品的展示费、电商的利润。所以亚朵才会在过去几年，呈现出如此强大的生命力和扩张态势。</p><h4 id="本讲小结-18"><a href="#本讲小结-18" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>总结一下，<strong>新产品一定要有新要素，否则没有竞争力。</strong></p><p>新要素有两种：</p><p>第一种，在现有体验的基础上，运用最新科技等新要素，提升用户体验，或者改变成本结构。</p><p>第二种，用整个社会经济升级、产业升级所产生的其他领域新要素，变革内在的商业逻辑。也许用户的前端体验，依然是那个产品、那个服务，但公司背后的商业运作，已经成为了完全不同的新物种。</p><p>课后作业</p><p>在这节课的结尾，给你留一个作业：</p><p>1.你现在做的产品使用了什么样的新要素呢？</p><p>2.或许你自己的公司，就是一个传说中的新物种，不妨在留言区给大家介绍一下。</p><h3 id="26-三级火箭：深度讲解互联网降维打击"><a href="#26-三级火箭：深度讲解互联网降维打击" class="headerlink" title="26 三级火箭：深度讲解互联网降维打击"></a>26 三级火箭：深度讲解互联网降维打击</h3><p>这是第五模块的第四节课，这节课咱们谈三级火箭。三级火箭是互联网圈一个特别容易被提起的概念词。我们在《机会判断：点线面体的战略选择》那节课讲了360的三级火箭。</p><p>360的第一级火箭是免费杀毒工具，利用这级火箭打破了持续10年的杀毒软件市场三国鼎立的局面，成为用户量最大的安全工具。</p><p>360的第二级火箭是从免费杀毒工具变为安全网络平台，进而推出360安全浏览器和360安全网址导航。</p><p>360的第三级火箭就是它最终承载的商业闭环，从安全浏览器和网址导航的广告收入，获得企业的经营利润。</p><h4 id="搜狗的三级火箭"><a href="#搜狗的三级火箭" class="headerlink" title="搜狗的三级火箭"></a>搜狗的三级火箭</h4><p>2017年上市的搜狗，也是三级火箭模式的受益者。</p><p>2003年，张朝阳委任王小川开发搜狗搜索引擎，制衡百度，现在来看搜狗的起步相比较而言是较早的。搜狗开始的时候，Google、百度都还没有上市，Google是2004年上市的，百度是2005年上市的。</p><p>百度在做自有品牌的搜索之前，一直运营着两大业务。第一是为门户网站做搜索服务提供商。2000年，新浪就是中国的互联网，新浪的搜索是百度在背后提供服务。百度的第二个业务是做机房，也就是服务器托管服务。百度的强，不仅强在搜索技术优于当时的对手，它对流量的理解也远远优于其他对手，包括在中国开展业务的Google。百度有机房在手，哪台服务器上流量高，这个服务器上跑什么业务，百度再清楚不过了。蔡文胜说过，百度早期最重要的一笔交易就是收购了hao123网址大全，这笔交易为百度奠定了核心流量和利润。</p><p><strong>互联网商业就是产品、流量、转化率三个词。</strong></p><p>2003年，搜狗的产品技术不如百度，对流量的理解更不如百度，做不起来是必然的事。但王小川是天才少年，并且韧劲儿十足，居然没有放弃。</p><p>2005年，他做了搜狗输入法。我们说一个搜狗的秘史——搜狗输入法是如何快速达到市场占有率70%以上的份额的。</p><p>360免费杀毒的动力是来自于传统杀毒软件都是收费的，而且价格不菲。输入法一直都是免费的，那么搜狗应该怎么做？</p><p>搜狗输入法的流量获取依然很有中国的风格。当时“番茄花园”、“雨林木风”这类盗版系统非常受欢迎，搜狗就请他们帮助做了内置。就是这样一个简单的渠道，一年的时间搜狗输入法达到了70%的市场占有率。十几年后，搜狗上市了，曾经做盗版系统的天才少年都陨落了。如果搜狗输入法是搜狗的第一节火箭，那么这些产品就是它的燃料。搜狗的二级、三级火箭和360是一样的，利用一个大流量工具，推浏览器和搜索，再用这两个模式的商业变现。今天搜狗的模式又有了变化，为什么？大家的网络场景已经变成了手机。iPhone有内置输入法，安卓也有输入法。如果这时依旧用输入法再做头部流量，显然不够健壮。这时我们发现，王小川在股东选择上的智慧。回到“点线面体”的第二讲，谁是最有能力给你赋能的那个“面”。搜狗是互联网的万人迷，一堆老大都想做搜狗的股东。王小川做了什么？王小川拒绝了周鸿祎，清退了阿里，这并不是容易做到的事。拥抱了腾讯作为股东，并且两次让腾讯增加对搜狗的持股。这就形成了今天搜狗搜索的新三级火箭。</p><p>第一级火箭：头部流量。今天搜狗在移动搜索方面80%～90%的流量来自腾讯，其中从QQ浏览器导入的流量占到70%。</p><p>第二级火箭，内置搜索。用户在微信内、QQ内等不同的场景里的诉求，在浏览器之外通过庞大的使用场景去释放更多搜索的需求。搜狗内部称之为智慧战略。</p><p>第三级火箭，商业变现。</p><p>理解互联网公司的三级火箭</p><p>总结一下，三级火箭是什么意思？</p><ul><li><p><strong>第一级，头部流量。</strong></p></li><li><p><strong>第二级，沉淀某类用户的商业场景。</strong></p></li><li><p><strong>第三级，完成商业闭环。</strong></p></li></ul><p>举两个例子，第一个先讲一下罗辑思维。</p><ul><li><p><strong>第一级火箭是罗振宇坚持了多年的免费脱口秀。现在做知识付费的平台很多，只有得到App是有头部流量的。</strong></p></li><li><p><strong>第二级火箭，就是沉淀用户的商业场景，得到App。</strong></p></li><li><p><strong>第三级火箭，你今天付费听我讲课，这就是第三级火箭。</strong></p></li></ul><p>小米公司也是如此。</p><ul><li><p><strong>一级火箭是手机。</strong>手机对于vivo、OPPO是利润中心，对于小米是头部流量。所以为什么业界很多人批评小米价格低、利润薄，搞得行业都不好做，其实是因为对产品的战略定位不一样。</p></li><li><p><strong>二级火箭是它的一系列零售场景</strong>，小米商城、米家、小米之家、小米小店。我和雷军说，等你开了1000家小米之家，100万个小米小店，那真是插根扁担都能开花。</p></li><li><p><strong>三级火箭是一个高利润的产品</strong>。现在雷总还是不愿意说出来，但最后一定是一个利润非常高的项目，能扛住整个小米的财报。</p></li></ul><p>为什么要把三级火箭当一节课来讲？</p><p>我们上节课讲了新要素、新物种。你以为亚朵在做酒店，其实亚朵在做社群共创的实景电商。你以为你在和雷军比手机，其实他只是拿手机做头部流量。你要赚利润的东西，并非是他人要赚钱的地方。面对这样的竞争者，传统的生意套路会失效。</p><p>什么人能玩三级火箭？</p><p>玩三级火箭，如果去掉三个字，就是玩火。</p><p>要玩三级火箭，有几个必要条件。</p><p><strong>第一，第一级火箭一定要高频应用。三级递推一定是高频推低频，没有低频推高频的。</strong></p><p>比如招商银行App用户量很大，但是它能做第一级火箭吗？它太低频了，只能推更低频的产品，比如出国、理财等。但陌陌是个高频应用，陌陌推直播，直播变现，这就是陌陌的三级火箭。斗鱼是个非常火的直播平台，它能推短视频吗？不行，短视频比直播高频，它难以作为一个高频应用的一级火箭，但是如果它做游戏分发，也许可以。因为大家下游戏，一两个月才下一个，比看游戏直播低频。<strong>总原则就是一级比一级低频。</strong></p><p><strong>第二，通过第一级火箭获得大量用户之后，要快速展开一个能够沉淀用户的商业场景。</strong></p><p>比如，共享单车看上去是一个非常好的头部流量，用户量大，又足够高频。但是在这样一个头部流量很大的基础上，如何顺滑地建设出能够沉淀用户的商业场景？这是共享单车的运营企业需要面临的考题。</p><p><strong>第三，操盘三级火箭的人，一定是个势能积累到一定程度的人。</strong></p><p>为什么？首先，他要有强大的融资能力。一级火箭是不赚钱的，你需要用免费来支撑一个庞大的用户服务系统，还要保障用户满意，这是一笔很大的钱。没有势能的人，很难募到这个规模的钱。其次，当一级火箭铺开头部流量，他需要快速张开，短时间聚拢资源的能力是要有一定的势能积累才能做到的。得到App快速扩展了这么多的好老师，这并不是随便可以做到的事。</p><p><strong>第四，操盘三级火箭的人，一定是个狠人。</strong></p><p>因为你的一级火箭就是抢流量的，就是把别人河里的水都抢到自己的水渠里，成就自己的河流生态。你想想，这得多少人恨你。所以，干三级火箭，不是偶然干成的，而是一开始就想着颠覆现有的行业，干掉现有的企业。所以如果不是狠人，不是积蓄已久的人，不是有高频应用场景的人，不是能承受指责的人，三级火箭还是没法轻易玩。</p><h4 id="三级火箭的原理"><a href="#三级火箭的原理" class="headerlink" title="三级火箭的原理"></a>三级火箭的原理</h4><p>我们一直在说三级火箭，火箭为什么是三级的？</p><p>因为火箭和汽车、飞机目的不一样，所以动力原理不一样。汽车、飞机一节燃料就够了，但只有一节燃料，火箭没办法突破大气层。火箭是靠自己把自己推起来，这就跟咱们这些没有靠山的创业者一样。你凭什么有势能，其中一点就是靠割让自己的利益。别人挣钱，我不挣钱，我获得的用户多一点，我才拥有了势能。</p><p>火箭如果只有一节，里面又装燃料，又装要发射的卫星，会怎样？结论是，按照传统模式，火箭是飞不起来的，它无法突破大气。二战时，德国研制的火箭，不能突破到外大气层，飞不到地球同步轨道，只能在大气层里飞。解决方案就是做一个动态系统，喷射燃料，抛出火箭壳，降低负载。</p><p>如果火箭只有二节，飞一块丢掉一块，第二块再飞上去，需要多重呢？以1吨重的卫星为例，需要149吨燃料，三级需要77吨，四级65吨。<strong>火箭级数越多，需要的燃料越少。但每增加一级，不可控程度越高。</strong>就好像咱们做商业，模型过于复杂，变现链条过长，就容易玩脱了。如果只做二级火箭，149吨才能推1吨，三级只需要77吨。如果三级火箭能够省一半的重量，危险程度也提升一倍。然而到了四级火箭，燃料重量可以省10吨，危险程度却变成了四倍。所以，<strong>三级火箭是一个成本和可控性平衡后的选择。</strong></p><h4 id="在人类的天空放上星星"><a href="#在人类的天空放上星星" class="headerlink" title="在人类的天空放上星星"></a>在人类的天空放上星星</h4><p>我还想说两件事：</p><p>第一件事，火箭是自己把自己推起来的，它的一级就是一个巨大的燃料堆，目的是给自己制造势能。但火箭的目的不是飞得越高越好，而是为了放卫星，是为了把一颗星星放到星空上。</p><p>无数有权力、有钱的人，都拥有巨大的势能，就好像拥有一级火箭。但很多人只是享受无限上升的乐趣，完全没有概念要把一颗星星放到人类文明的天顶上，所以当他们势能耗散，也会被快速遗忘。</p><p>我想说说我崇敬的一个人，就是诺贝尔。诺贝尔奖发了100多年，其实没多少钱。中关村有很多比诺贝尔奖基金更有钱的基金、企业，但中关村的那些故事早就消失了，或者10年后20年后就消失了。分析一下诺贝尔奖，他一生的财富、心愿是一级火箭；忠实执行的管理机构是二级火箭；而一次次发放的奖金，往人类的天顶上安放的星星，这才是真正有价值的三级火箭。终我们的一生，追逐金钱、创建人脉、获得权力、积蓄势能，一切其实成就了你的势能，打造了你的一级火箭。但是你的一生是无限享受上升的乐趣，还是有一颗星星想放到人类的天顶上，这是一个问题。</p><p>另外，需要说的是，关于三级火箭的事，是张云帆给我讲的。张云帆是完美世界控股集团董事、纵横文学CEO。他给我讲了他对三级火箭模式的完整理解，我觉得非常棒。我就问他能不能把他的三级火箭模式，放到得到App里来讲，他同意了。感谢张云帆。</p><h4 id="本讲小结-19"><a href="#本讲小结-19" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>这节课就到这里，总结一下，商业模式的三级火箭：</p><p><strong>第一级，搭建高频头部流量；</strong></p><p><strong>第二级，沉淀用户的商业场景；</strong></p><p><strong>第三级，完成商业闭环。</strong></p><p>课后作业</p><p>留一个作业互动一下：</p><p>火箭是自己把自己推起来的，它的第一级是给自己建立势能。</p><p>你觉得你身边的谁，或者你知道的谁，特别擅长给自己去建设势能？</p><p>欢迎在讨论区跟我分享一下。</p><h3 id="27-颠覆式创新：成败价值网"><a href="#27-颠覆式创新：成败价值网" class="headerlink" title="27 颠覆式创新：成败价值网"></a>27 颠覆式创新：成败价值网</h3><p>这是我们创新模块的最后一讲，我们讲颠覆式创新。</p><p>讲创新不能不谈颠覆式创新，颠覆式创新5年前还是非常新的概念，现在已经成了一个互联网的热词了。马克思说：人的本质在其现实性上是一切社会关系的总和。你不是一个孤立的个体，你是你一切社会关系的总和。企业是其赖以生存的价值网的某一节点。不管人还是企业都生活在一个网里。</p><h4 id="价值网与颠覆式创新"><a href="#价值网与颠覆式创新" class="headerlink" title="价值网与颠覆式创新"></a>价值网与颠覆式创新</h4><p>什么叫价值网？《创新者的窘境》里有这样一段话：</p><p>真正决定企业未来发展方向的是市场价值网，而非管理者；真正主导企业发展进程的是机构以外的力量，而非机构内部的管理者。管理者只是扮演一个象征性的角色。企业真正的管理者，就是识别自己赖以生存的价值网。这个管理者应该建立一个组织，与这个价值网进行资源对接。一个好的组织结构，它的每一个组织部门，都是为了和某一个社会价值网的分支进行对接而设计的。<u>一个失败的企业的组织结构，是管理者按照自己需求设置的。</u></p><p><strong>谈颠覆式创新，为什么要先谈价值网？</strong></p><p>因为很多没落的企业，在自己的价值网上依然是优秀的，只是它依附的价值网过时了；搭载在新的价值网上的企业，实现了自己的颠覆式创新。就好像你是你社会关系的总和，你的社会关系哺育塑造了你，同时他们也锁定、限制和束缚了你。一个企业成就于自己不同部门和它依附价值网之间，资源与资金的输入输出。但它赖以存在的价值网，也会锁死这家企业。马化腾说：“也许你什么错都没有，只是老了。”很多没落的企业，也是什么错都没有，只是它的价值网过时了。</p><p><strong>计算机行业的价值网更迭</strong></p><p>我先讲一个古老的故事，其实是一连串古老的故事。</p><p>1940年代，世界第一台计算机UNIVAC(通用自动计算机)被研制出来。这一伟大产品被认为是专为科研工作而设计的，因此对企业级商业市场毫无兴趣。1950年左右，UNIVAC的公司市场调研结论：到2000年，电脑的销售量将达到1000台。为什么会出现这样的市场预判？因为它是基于自己的价值网做的预判，而UNIVAC的公司的价值网就是为顶级科研服务，从这个角度而言，他并没有错。IBM和其他早期的美国计算机一样，也是专门为科研设计的。但是不同的是，IBM积极拥抱了企业对计算机的强烈需求。它其实用的就是UNIVAC的技术，但是为会计工作做了优化，所以IBM公司叫国际商业机器公司，靠着服务会计起家。</p><p>10年以后，UNIVAC仍然拥有当时最先进的计算机。但是，IBM却几乎拥有了整个计算机市场。因为大家选择了不同的价值网，你可以认为IBM颠覆式创新，颠覆了UNIVAC的市场。UNIVAC的价值网在科研，而IBM公司的价值网在商业企业。80年代，有句话说，“任何公司向IBM业已占据的领先地位直接发起挑战都无望获得成功。”</p><p>然而PC出现了，苹果电脑诞生了，联想诞生了。后来的故事，就是我自己亲身经历的故事了，中国出了联想。1997年联想电脑在中国市场打败IBM、惠普、康柏位列中国市场占有率第一的时候，乔布斯刚返回苹果不久。2004年，联想收购了IBM的PC业务，成为了全球PC的老大。IBM曾经是神一般的存在，而PC行业皇冠上的明珠ThinkPad，被联想摘下了。苹果手机现在是手机行业皇冠上的明珠，如果有一天，小米把iPhone买了，一举成为全球手机行业老大，那成就和2004年联想收购了IBM的PC业务是类似的。2004年，联想的杨元庆做到这件事的时候，只有40岁，雷军是40岁才刚刚创办了小米。所以杨元庆在40岁就已经取得了一个较高的成就。但是之后的十几年，他一直被牢牢地锁死在PC的这张价值网里，错过了移动互联网。</p><p>大家都说雷军是劳模，极其勤奋，如果说我还见过一个勤奋程度不逊于雷军的人，就是杨元庆。杨元庆以一个中国本土企业，去整合高贵傲慢的IBM全球资源，两年的时间，持续两个星期飞3个洲，睡觉都在飞机上，下了飞机就开会，还练好了英语，用英语直接管理IBM分布在全球的经理人。可见价值网的力量多么强大，即使像杨元庆这样超级优秀的人都难以挣脱。</p><h4 id="价值网的三大要素"><a href="#价值网的三大要素" class="headerlink" title="价值网的三大要素"></a>价值网的三大要素</h4><p>混沌大学的李善友教授是专门讲颠覆式创新的，他对价值网的解释是：</p><p><strong>价值网里，至少有三个角色：一是客户，二是对手，三是投资人。</strong></p><p>就是这三个核心力量，加上其他千丝万缕的牵制，牢牢地捆住一个大企业。为什么IBM没有推出小型计算机？因为它的客户是大型机构的核算和数据处理部门，不需要小型计算机。他们因为服务客户而错过了另外一个大的增长。IBM没有进入小型机，因为背后的价值网是顾客决定的。企业第一目的是生存，生存必须获取资源，而资源是顾客提供的。<strong>客户是我们最重要的资产，但也可能是我们最主要的创新盲区。</strong>所以资源分配流程其实不是管理者定义的，而是来自价值网中的客户需求与对手挤压。并不是有技术、有人才就什么都能做。</p><p>价值网里的第二个要素，是对手。在江湖里做企业，很多时候对手对你的刺激是直接刺激。生物学说共同进化，两个人与其说是相互竞争，不妨说是跟竞争对手构成一个网，我恨你，你恨我，互相作为参照物，谁也离不开谁，眼里全是竞争对手。比如360公司2011年上市，2012年全力以赴做搜索，在这之前是周鸿祎与李彦宏十一年的缠斗，这在周鸿祎最近出的自传中有提到。但事实上，其实我们应该警醒。我们会被思维遮蔽，真正缠住你视野的，有时候不是客户，而是你的对手。所以，<strong>放下贪婪、愤怒</strong>，这也许真的要靠智慧。</p><p>价值网里的第三个要素：是投资人。我想所有的创业者尤其是上市公司，对此深有体会。这也是为什么窝窝团要上市的时候，美团说谁先上市谁就输了。因为资本所要求的增长是个魔咒。联想2014年财务报告很漂亮，但是之后股价就大跌，为什么？因为没有达到分析师预测的增长。股市是一个很丑陋的游戏，增长是一个魔咒，所有企业都丧失在里边，只有10%的企业能够维持良好的增长势头，而只有2%的企业长期超过市场绩效。</p><p>在资本的增长压力下，大公司很难进入小市场。李彦宏说过，对于百度来讲，低于1%收入比例的市场是不看的。</p><p>埃隆·马斯克做特斯拉的时候，电动车的销售额占据大型汽车厂商销量的不到1%。所以，大型汽车厂商会因增长魔咒的控制而眼睁睁地放任了特斯拉的崛起。而小市场一旦启动指数级的爆发增长，大公司就再也追不上了。</p><h4 id="组织心智"><a href="#组织心智" class="headerlink" title="组织心智"></a>组织心智</h4><p>很多极其优秀的公司为什么失败了？</p><p>管理的书一定会告诉你是管理出问题了。但是写《创新者的窘境》的克里斯坦森的说法是，良好的管理恰恰是他们未能保持行业领先地位的最重要的原因。所以，所谓管理得好的公司，往往是与现有价值网的紧密对接。响应现有客户需求，紧盯对手，满足投资人。所有的弦都绷得高效、流畅，没有冗余和浪费，管理得无比完美。整个公司的管理设计，都是为了高效服务现有价值网。公司的资源配置如此，公司组织流程的设计也是类似，公司财务评估的方式更是如此。然后就这样长期循环下去。资源要这样安排，组织流程必须这样才合理，财务评估要按照这种价值判断，以上因素加在一起，这是什么？</p><p>这就形成了“组织心智”！虽然一般说用感叹号很粗鲁，我忍不住用了感叹号，这也是这门课唯一一次使用感叹号的地方。</p><p>联想是我的第一份工作，我19岁就在联想上班，我对这家公司有强烈的情感。当年它要做手机的时候，我就知道没戏，因为我了解这家公司的“组织心智”。一系列在这个组织里无比合理的决定，让这家曾经伟大的企业，无法从现有的PC价值网中逃出来。</p><p>一个组织的心智模式定下来就真的很难以改变，像我们的基因一样看不见，但决定组织的整体思考方式。这也是为什么新经济给了我们这些没背景，只会琢磨用户体验的人机会。我们的机会就是看到新崛起、新展开的价值网。因为如果是一个新的增量市场，意味着这是一个新的价值网。传统老企业，它的组织心智不一样，所以它没有办法和你一样去做出反应，因此我们创业者充满机会。</p><p>iPhone开启了移动互联网，iPhone是第一台智能手机吗？当然不是。诺基亚早就开始了开发智能手机，并且智能心智开发的很好。但是诺基亚对手机的定义是通信产品，iPhone对手机的定义是互联网手机，是移动互联网的终端。看上去是一样的产品，但代表了完全不同的两张价值网。</p><p>联想从PC到移动互联网叫做遇到了非连续；诺基亚曾经是手机霸主，遇到了苹果也叫遇到了非连续。<strong>什么是非连续？就是整个社会在发展，整体社会能力升级，新的需求被释放催生新的价值网。</strong>传统企业在它传统的价值网里依然可以生存，例如联想依然是PC价值网的霸主，但它在新的价值网里是边缘企业。新崛起的价值网，才是新大陆。</p><h4 id="什么是颠覆式创新？"><a href="#什么是颠覆式创新？" class="headerlink" title="什么是颠覆式创新？"></a>什么是颠覆式创新？</h4><p>颠覆式创新最重要的标准就是，是否开启了一个新的价值网？你是不是到了“新大陆”？也许它刚一开始很小，不到传统企业的1%。</p><p>1990年新浪来跟联想谈合作，我们会感到奇怪，当时它显然不如《计算机世界》《计算机报》，但是它是新的价值网。特拉斯刚启动，不到传统汽车厂商的1%。iPhone一代刚发布，包括微软的鲍尔默在内的整个硅谷，都对它冷嘲热讽。但是，它一旦开始，就不可逆。</p><p>我之前讲的产品方法，都是教你怎么从零到一做一个产品，安身立命赚点钱，继续服务、迭代。</p><p>颠覆式创新是屠龙术，是产生新帝国的机会。概率非常之小，但我希望听我课程的你，有机会做这样的事。</p><h4 id="本章小节"><a href="#本章小节" class="headerlink" title="本章小节"></a>本章小节</h4><p>我们的创新模块就到此结束了。总结一下：</p><p>第一节课，我们谈了用户价值公式。用户价值＝新体验－旧体验－用户迁移成本，存量市场的打法就是拼体量，创业公司唯一的机会就是创新、去增量市场。</p><p>第二节课，我们谈了未来已来，只是分布得不均匀。根据小鸡孵化器，可以做出人类婴儿的恒温箱。其实我们需要的很多解决方案，就在你旁边已经出现了，需要的是你的思考和洞察。</p><p>第三节课，我们谈了新要素、新物种。所有的新产品，都会有些新要素，有些是产品本身的升级，有些是把整个社会升级的新能力纳入企业，使企业看上去在提供原来的服务，但它的内在商业运作机理已经非常不同，甚至已经变成了一个新物种。</p><p>第四节课，我们谈了互联网圈很爱使用的三级火箭模型。第一级火箭是头部流量，第二级火箭是沉淀用户的商业场景，第三级火箭是交易变现。</p><p>最后这节课，我们讲创新模式的帝王术——颠覆式创新，开启新的价值网。</p><p>课后作业</p><p>这节课就到这里，我们还是留一个作业互动一下。</p><p>到这节课，我们创新的这个板块就讲完了，不管是个人还是公司，你有没有在做创新呢？</p><p>欢迎把你所做的创新，在留言区分享给我。</p><h3 id="28-看产品的微观、中观与宏观视角"><a href="#28-看产品的微观、中观与宏观视角" class="headerlink" title="28 看产品的微观、中观与宏观视角"></a>28 看产品的微观、中观与宏观视角</h3><p>前面五大模块，我就<em>同理心</em>、<em>机会判断</em>、<em>系统能力</em>、<em>用户体验</em>和<em>创新模式</em>，把做一个产品五大块的思考框架介绍了一遍。</p><p>有人问我，你怎么判断一个人是不是产品高手？怎么评估这个人厉害在哪里，不厉害在哪里？我把好产品体系用三个层次再总结一下，分别是：<strong>中观</strong>、<strong>微观</strong>、<strong>宏观</strong>。你可以对照看一下自己，或者你要评估的人，在这个三个层面水平如何？</p><h4 id="中观套路：学习招数"><a href="#中观套路：学习招数" class="headerlink" title="中观套路：学习招数"></a>中观套路：学习招数</h4><p>什么叫中观？就是套路。第二模块之后的内容，有大量的套路：用户画像、痛点和痒点、整体流程图、用户体验地图和服务蓝图。书店里有很多讲套路的书：用户需求、产品策略、功能定义、流程图制作、产品原型制作、项目管理、数据分析、产品运营……</p><p>大公司是学习套路的好地方。一家公司能系统培养某一类人，说明这家公司在这个领域有与众不同的套路，比如：联想出销售、腾讯出产品经理、阿里出运营、百度出技术。</p><p>所以大学毕业去大公司是有价值的，因为套路有价值。套路像武功招数一样，是前人总结的有效经验。比如用户体验，如果你不懂用户画像、用户体验地图、用户体验这些套路性动作，按照自己的模糊感觉做，也许也能接近用户体验的完整。但练好套路可以自我排查问题，便于和团队沟通。</p><p>除非你打算在大公司呆一辈子，否则最好不要超过5年。</p><p>为什么？因为大公司教你套路，同时也会深深地把你角色化，让你只能作为系统的一个角色，习惯系统内的生存。</p><p>创业企业也不要迷信大公司的套路，最典型的就是从腾讯挖个产品经理，创业者就觉得可以把自己的产品交给他。甚至与这个产品经理PK的时候，还不自信，觉得对方是大公司出来的更专业。</p><p>因为，靠套路成不了高手。套路可以让你更有章法地展现自己，更容易搞定面试官，成为系统内按指令行事的公司中层。如果你为既定资源，既定需求的系统服务，套路足以胜任。因为一件事做到什么程度，多一点少一点的刻度，有领导控制，有系统控制。</p><p>但是如果你想依靠这门手艺，自立门户，博得名利，那么你面对的是整个市场的竞争与用户的分流。你每时每刻，都需要面对每一个细节的取舍。没有人告诉你“可以了”，没人告诉你对与错，甚至用户给你的反馈都是混杂的。</p><p>你如何做出每一个微小的决策，持续迭代，持续优化？</p><h4 id="微观体感：成为高手"><a href="#微观体感：成为高手" class="headerlink" title="微观体感：成为高手"></a>微观体感：成为高手</h4><p>要成为能够自我决策的好手，我们就需要产品经理能力的第二个维度：微观体感。</p><p>每一个微小的动作选择叠加起来，就是你拿出来的产品，就是你活出来的样子。那么日常中，我们做每一个细小选择，靠的是什么？靠微观体感，就是真实地感知每一个微小瞬间。前面的课程很多是讲微观体感的，尤其是开篇的第一模块。</p><p>产品是一种被动的艺术。一个产品只能在被动中，默默把握每一个微小的主动机会，在每一个接触的瞬间，每一次的交互里，让用户顺畅地深入下来。用户动力不足，要放弃这个产品，你是没有任何办法的。最挑剔的人，其实就是最有防御意识的人。如果产品突然碰触用户的某个意识神经，让用户产生防御，那流失的几率就会加大。</p><p>举一个并不新鲜的例子，日本一位做寿司的师傅叫小野二郎，一部有关他的纪录片叫《寿司之神》。</p><p>小野二郎做寿司时间超过55年，直到70多岁，他还对寿司有很多新想法。纪录片里讲小野怎么带徒弟：</p><p>在小野二郎的店里做学徒，首先必须学会用手拧毛巾，毛巾很烫，一开始会烫伤手。没学会拧毛巾，就不可能碰鱼；然后，要学会用刀、料理鱼。十年之后，徒弟才能煎蛋。纪录片里的学徒说：“我练习煎蛋很久了，以为自己没问题，但在实际操作时，却不断搞砸。他们一直说‘不行，不够好’。”</p><p>十年的基础训练完毕，一名学徒终于够格煎蛋，却发现自己似乎永远无法满足师傅们的标准。他又花了4个月，经历200多个失败品后，做出了第一个合格的煎蛋。小野二郎说：“这才是应该有的样子”。终于承认这名学徒为“职人”时，他高兴哭了。</p><p>如果是你，你能清晰地说出那200个失败品的不同吗？能说出那200个失败品和唯一的合格品之间，微妙的临界点在哪吗？小野二郎可以真切地判断——来自他的微观体感。</p><p>为什么花10年学习拧毛巾、用刀和料理鱼？为了建立精微的微观体感。</p><p>达·芬奇为什么要练习画鸡蛋？为了建立精微的观察和手感。</p><p>用普通人的视角来看，鸡蛋都一样。但要是成为一个伟大的画家，就要不断练习，在最不容易建立观察的地方，建立每一个微小处的觉察。</p><p>反思什么样的设计才能让用户满足？复盘用户是否产生了防御心？为什么会在这里卡顿？产品应该怎么做才自然？成为天才的一万小时都干了些什么？大量的时间都是在建立细微的微观体感，建立长在自己身体上的真实感觉，眨眼之间的好恶判断。</p><p>很多爱好者、发烧友是有微观体感的，他们需要补中观的套路，才能够有系统、有层次地释放他的感受。而在大公司也好，看书纸上谈兵也好，拥有了中观套路的人，一定要补微观体感。否则，说起来都对，做事却都不到位。</p><p>如果能够同时拥有微观体感和中观套路，那就是一个产品好手了。</p><h4 id="宏观能力：打大仗"><a href="#宏观能力：打大仗" class="headerlink" title="宏观能力：打大仗"></a>宏观能力：打大仗</h4><p>那什么是宏观能力？就是打大仗的能力。</p><p>你说锤子手机的微观体感和中观套路如何？很好啊。比起小米手机，差在宏观能力。</p><p>你说易到用车当时的用户体验和口碑如何？很好啊。比起滴滴，差在宏观能力。</p><p>在这套课里的<strong>点线面体、创新模式都是宏观能力</strong>。</p><p>几家定位相似、体验相似的产品，靠优化用户体验，其实是无法终结战争的。大仗拼胜负，靠的是宏观能力。</p><h4 id="本讲小结-20"><a href="#本讲小结-20" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>练好套路，在大公司做到中层没问题。要想自己为结果负责，开门立户创业，必须有长在自己身上的微观体感。没有微观体感，靠套路判断，就是自欺欺人。但打大仗，做顶级高手，其实宏观能力也要强。</p><p>这是我们对之前的内容，用微观、中观、宏观三个层级做的一个小小的总结。</p><h3 id="29-人生逻辑大于商业逻辑"><a href="#29-人生逻辑大于商业逻辑" class="headerlink" title="29 人生逻辑大于商业逻辑"></a>29 人生逻辑大于商业逻辑</h3><p>这是我这套课的倒数第二讲。一晃到了尾声，我还有点不舍的感觉。</p><p>产品能力是现实的、功利的能力。做产品要求你判断客观条件和机会、盘点资源、按照用户体验的方式，有层次地整合起来，向世界交付价值获得报偿。</p><p>在这一节课的时间，我想和你分享一下我的一些观察和感受，就是：<strong>人生逻辑大于商业逻辑。</strong></p><p>我为了把课串起来，做了一套扑克牌。那就会面临问题是谁是大王、小王？刚一开始，我想用“点线面体”做大王，“依赖”做小王。“点线面体”的战略选择，属于宏观能力，打大仗，靠的得是宏观视野、势能的使用和趋势的把握。但心里还是有些不确定，和很多朋友沟通后，最后选择“确定性”做大王，“依赖”做小王。</p><h4 id="雷军和“风口论”"><a href="#雷军和“风口论”" class="headerlink" title="雷军和“风口论”"></a>雷军和“风口论”</h4><p>为什么次序是这样的？</p><p>不得不提雷军那句广泛传播的名言：“只要站在风口，猪也能飞起来。”这些年，风口论成了最著名的成功学。抢风口几乎成了创业的规定动作，你在不在风口上成了所有资源方判断你的标尺，成了社交场面里介绍每个人必须有的一个标签。</p><p>不过，我给我的女性朋友们创业建议时，我的说法是：“女性创业，不要抢风口。”</p><p>抢风口，背后的一个核心能力是<strong>抢资源</strong>的能力：争夺最好的团队，争夺最大笔的投资，争夺公众最大化的关注，争夺合作伙伴最优质的资源与配合……</p><p>争夺这件事上，基本上女性的能力是弱于男性的。男生从小就会有推推打打的游戏，踢足球、打篮球，与人协作去争抢一个东西，甚至经常磕蹭受伤，所以从小就习惯争夺。而女生从小玩的是安安静静的游戏，对如何主动去争夺，如何组织团队去集体争夺，甚至在争夺过程中，自己与队友如何应对有意无意的碰撞与伤害，几乎是完全没有概念的。</p><p>很多人看到一个资本的风口，觉得自己有认知能力，有一些所谓的资源，有不甘心于人后的心气，就冲上去。但其实对“争夺”这件事，无论是历史训练，还是心理准备其实都是不足的，很难不败下阵来。2014年到现在，咱们看到了几次风口，O2O上门服务、打车大战、外卖大战、网络金融、共享单车……所有的“风口争夺战”挺到最后并飞上天的那个，其实真没有谁是碰了运气的猪，全部是创业了好久，磨炼了好久的老手。</p><p>雷军会说这句话，其实是因为他曾经是个内心非常骄傲的人。如果你当自己是一只雄鹰，就不需要依赖风，不论自己做什么随时随地都可以成功。但是，2007年金山上市，对一般人来讲已经非常成功了，而雷军却郁闷得要死，因为这不是他要的大成。所以他做小米时谈飞猪理论，把自我矮化成一头猪，时刻提醒自己：我个体能力只能达到这个点，如果我想大成，需要依赖机会、环境、势能。</p><p>我们上一课谈了中观、微观、宏观能力，就能否大成要靠宏观能力，个体的能力之于机遇其实微不足道。</p><h4 id="确定性和不确定性"><a href="#确定性和不确定性" class="headerlink" title="确定性和不确定性"></a>确定性和不确定性</h4><p>宏观能力、点线面体的战略选择当然很重要。但是它是最重要的吗？</p><p>当你对自己根据“点线面体”做了一个宏观判断，是否真的能不论自己准备是否成熟，内心是否确定，就冲到那个风口去？</p><p>我想讲一个我自己的故事。熟悉我的一些朋友都了解，2016年我差点和一个投资界的大佬一起做一个母基金。折腾了近一年，连第一笔钱都筹齐了，最后我还是选择不做了。这个过程很狼狈，算我人生的教训之一。我选择做母基金肯定是点线面体的战略选择，合作伙伴T先生是业界资深人士，我们之间有很多共同的朋友。母基金又很高端，算是一个上流社交圈，客观来讲我应该做这件事。</p><p>接着，就要抛出这副扑克牌的王牌“确定性”和作为红桃k的“不确定性”。</p><p>说“确定性”和“不确定性”之前，我说一下马云的组织观：</p><ul><li><p>三级组织是共同规则。一般的公司职员、学生、生产线的工人、军人、犯人都是共同规则管理。</p></li><li><p>二级组织是共同利益。平时管士兵是共同规则；打仗要攻城了，谁先进城有赏，这算一种共同利益。老板和员工之间，是共同规则；和股东之间是共同利益。</p></li><li><p>一级组织是共同信仰。共产党早期的故事，就是有信仰的组织。</p></li></ul><ul><li>顶级组织呢？是至情至性。桃园结义是中国最美的图景之一。我算了一下时间，他们三个人从公元184年起兵征讨黄巾军，到公元214年入蜀建立了自己的稳定地盘，整整30年一直在四处征战，没有根据地。刘备三顾茅庐去请诸葛亮是公元207年，隆中对的重要性在于确定了天下三分的战略。刘关张三个人在没有清晰战略，一直辗转征战的情况下合作了23年。23年，一直都在不确定、受挫的状态里，核心团队没有散，我们扪心自问一下这有多难？这真是至情至性。</li></ul><p>所以我为什么没和T先生做母基金？因为母基金周期较长，至少10年。我和T先生至情至性肯定谈不上，共同信仰好像也没有，剩下的就只有共同利益。10年，充满了各种不确定的冲击，我们对彼此的价值和利益的认定，一定会有分歧。这就是一个极其脆弱的合作。我知道母基金是符合点线面体的好选择，但是我对我和T先生的关系没有确定感。于是我没有办法因为一瞬间看到了一件事的好，就把自己交给这个很脆弱的关系，一起面对未来10年的不确定。<u>这其实是我把“点线面体”变成了黑桃K，而把“确定性”做成了大王的原因。</u></p><p>世界是多维的，到处是此起彼伏的点线面体，各种机会呈现出的就是各种变幻，各种不确定。你会因为对于机会和利益的判断，而在各种不确定中坚持多久呢？那什么样的人、东西、感觉会给你确定感，让你觉得可依赖，其实是极其重要的。</p><p>为什么有人画秘密花园填色图会觉得治愈？有人做饭会觉得治愈？因为这些都是有确定感的东西。对一个产品的使用，对一个人的关系，持续收到确定感的反馈，就会觉得安全，觉得可以依赖。如果突然变得不确定，就会有被伤害的感觉。这也是网站不要轻易改版的原因。</p><p>我们的课是产品课，是否符合点线面体的大趋势，固然是大成的标准；但如果你无法持续输出确定感，无法让人依赖，其实连小成都达不到。</p><h4 id="点线面体VS确定性依赖"><a href="#点线面体VS确定性依赖" class="headerlink" title="点线面体VS确定性依赖"></a>点线面体VS确定性依赖</h4><p>说完确定性，那什么是依赖呢？依赖是一种真实的长期关系。</p><p>你观察你的父母，你身边的伴侣，你认识的创业合伙人，谁是完美的？他们之间有没有抱怨、不满？肯定的。他们之间有依赖吗？有的。</p><p>所谓“完美的产品”“极致的产品”就像“完美的人”一样，只是一种追求，但世上并不存在。</p><p><strong>重要的不是完美，而是对方要的那个确定性你是否还能提供，对方是否还依赖你，这才是关系的关键。</strong>就好像我们对我们的父母，当我们不依赖他们，即使千恩万谢，也是会离开。产品和用户之间也是如此。所以，红桃K是“不确定性”，它是生活的一部分，是我们不能畏惧，需要勇敢拥抱的东西。黑桃K是“点线面体”，是宏观格局的判断，是你做人生选择题时可以采用的思考框架。而大王是确定性，小王是依赖。这就是我们最后确定的4张牌。</p><p>如果你内心没有“确定感”，如果没有人依赖你，你也没有人可以依赖，点线面体、价值网、三级火箭这些创新战略，即使你看到了也是空无而不可持续的。</p><h4 id="本讲小结-21"><a href="#本讲小结-21" class="headerlink" title="本讲小结"></a>本讲小结</h4><p>所以，为什么会有很多企业家，很多事看上去可以做、应该做，但没有做，这就是“非不为也，是不能也”。成功学给出的逻辑虽都很对，但是我实在是干不来。</p><p>其实正确的做法就是，自己真实能做到的。商业是以利润为中心，人生是以意义为中心。商业并非人生的全部。人死前盘点自己的一生，其实没有人看这一生赚了多少利润。</p><p>做你有内心确定感的事，人生逻辑大于商业逻辑。</p><h3 id="30-产品连接客观世界、过去与将来"><a href="#30-产品连接客观世界、过去与将来" class="headerlink" title="30 产品连接客观世界、过去与将来"></a>30 产品连接客观世界、过去与将来</h3><p>一晃到了最后一节课，我们聊聊天吧。</p><p>我的好朋友李学凌曾经有个签名档，是“make things，change things”，简单可以翻译为“做东西，改变东西”。另外一个好朋友王兴也曾经有个签名档，“create as god，work as slave”可以翻译为“像奴隶一样去工作，像上帝一样去创造。”这都是他们很久很久以前的签名档，但是因为我非常喜欢，所以一直记得。因为这两句话，“做东西，改变东西”，“像奴隶一样去工作，像上帝一样去创造”就是一个产品经理的人生。</p><p>应罗胖和脱不花之邀，很高兴在得到上做这套产品课，讲了作为一个产品经理，应该具备的概念点和思考框架。但可能我个人的心愿还不止于此。我希望中国有更多产品经理，有更多动手工作，改变现实、优化世界的人。</p><h4 id="海中之盐"><a href="#海中之盐" class="headerlink" title="海中之盐"></a>海中之盐</h4><p>我讲一个盐的故事。1914年冬天，有个年轻人叫范旭东，他独自一个人到了天津塘沽。塘沽靠海，海滩上一片白，但那不是冬天的冰雪，而是盐。你想象一下那个景象：无人的海边，海里的盐一坨一坨凝结在沙滩上，放眼望去白茫茫一片。范旭东是湖南人，他看到这一幕非常激动。日后他对伙伴说：“一个化学家，看到这样丰富的资源，如果还没有雄心，未免太没有志气了。”咱们国家有漫长的海岸线，但是几千年来咱们的祖先一直都没盐吃。古代盐就是钱，钱镠、程咬金都贩过私盐，《金瓶梅》中西门庆赚的最大一笔钱是从盐上来的。但是这些盐，这些钱，就这样像冰雪一样堆在沙滩上。为什么面对资源却不能处理？任何一个学过高一化学的人，如果穿越回古代，都可以找个无人的海岸，从大海里取出盐。而就生活在海边的渔民，是古代最惨的人，他们只认识鱼，而不知道在身边滚滚而来的海浪里，就有盐，就有资源的本身。缺乏专业化视角和专业化能力会导致什么呢？仅从产品结果看，我们中国人一直吃土法制作的粗盐，盐氯化钠含量不足50%。当时西方发达国家已经明确规定，氯化钠含量不足85%的盐不许拿来做饲料。因此，有西方人讥笑我们是“食土民族”。直到1915年范旭东开办久大精盐公司，中国才做出了95%以上纯度的盐。中国人吃到像回事的盐，才刚刚100年。今天我们中国人对自己美食真实的自信，但是100年前连像回事的盐都没有，更谈何自信。所谓自信是在不断的创造与反馈中建立的。盐是如此。互联网也是如此。</p><h4 id="产品能力，大海取盐"><a href="#产品能力，大海取盐" class="headerlink" title="产品能力，大海取盐"></a>产品能力，大海取盐</h4><p>我们不谈过去60年或者20年，互联网对这个世界的优化，只谈最近7年。7年前的2011年，有两个重要的产品，微信和小米手机。微信的意义是什么，对于每个人都有体会。</p><p>小米手机有两个意义：</p><ul><li><p>它开启了低端智能手机的市场，直接推动了中国智能手机的普及。之后的一年2012年，被定义为中国的移动互联网元年。</p></li><li><p>小米的极致化单品。创始人社会化网络粉丝经济的系列爆发，开启了中国的新品牌浪潮。</p></li></ul><p>这7年，因为智能手机的普及，微信这种超级应用的拉动，中国8亿人成为了高频的网民。</p><p>基于移动场景的商业O2O、新闻、娱乐都在重构。很多人学习小米的爆品策略，推出的网红品牌层出不穷，例如社会化营销的网红奶茶、网红洗发水、网红内衣、网红面膜等。</p><p>今天你已经习以为常，成为生活依赖的应用，放到7年前，其实统统都是还没有的。你有专业化视角，你有专业化能力，你可以从大海里取出盐，你可以在一间会议室里做出微信，你可以在一个小屋子里定义出小米手机。自此，无数人有了不同的机会，无数人的生活因此改变。这就是一个产品经理的荣耀。</p><h4 id="中国产品的大航海时代"><a href="#中国产品的大航海时代" class="headerlink" title="中国产品的大航海时代"></a>中国产品的大航海时代</h4><p>前一段我和雷军、曾鸣都做了深度沟通，大家的共识是：互联网时代结束了。</p><p>2018年以后，新公司应该是以互联网为基础设施的科技公司，新品牌公司。这些年，新品牌已经冒出来很多了，但是一定还会更多，还会更强。我坚信下一个时代，由中国原生的品牌一定会像宝洁、雀巢一样走向全世界。</p><p>为什么我有这个信心？大家有没有注意，美国网红品牌没有中国多，因为美国没有消费升级。美国的消费升级，是由现在已经成为国际大牌的这些企业主导完成的。它们借助了美国的内需和工业能力，建设了企业对用户的服务能力，借助资本能力、设计能力、心理优势，快速实现全球化。在上一时代，国际大品牌碾轧中国消费品、快消品、日化品的时候，因为我们资本能力、设计能力、心理优势、产业链掌控度全面低微。但是今天时代变了，整个中国商业的基础能力，发生变化了。淘宝一个90后女孩创立的网红女装，一个公司400人，充分使用社会化网络协同，一年可以做到20亿的交易额。雷军、杨元庆、余承东这些国际化先行者的竞争擂台，已经到了在印度市场论输赢，在印尼市场较高低，在巴西在北美分胜负。今天的中国不少领域的产品人，在中观套路、在微观体感、在宏观视野，都已经不输于那些国际大厂的产品经理。</p><p>如果你抛开惯性化的仰视和妄自菲薄，我们客观评估一下，曾经横吞了整个中国日化、消费品类的那些国际大牌，你会感受到中国还在孕育奇迹。我们一定会孕育出下一个宝洁，下一个雀巢，下一个ZARA。这是我为什么要分享这个课程的原因。</p><p>不管是20年前我在联想，亲历联想如何同时打败四五十个国内品牌和十余个国际大牌，成为中国第一的过程。还是今天我站在这里讲，怎么从零做一个产品，怎么拥有第一个用户，怎么与用户连接，怎么在用户驱动里迭代。20多年来，我从来都没有改变过，对我们自己的创造力，对我们自己做东西能力的信心。100年前中国人对中国美食有自信吗？那会儿连像样的盐都没有。就好像1997年，或者2007年一样，站在一个新的机会窗口，我相信这又是一个中国原生品牌井喷的时代。</p><h4 id="愿你伟大时代，置身局内"><a href="#愿你伟大时代，置身局内" class="headerlink" title="愿你伟大时代，置身局内"></a>愿你伟大时代，置身局内</h4><p>这是另外一个伟大的时代，你我，都不应该置身局外。</p><p>愿你拥有专业化视角和专业化能力。看到时代的浪潮，不再抱怨波涛滚滚的凶险，而能看到大海的本身就是资源。不需要哀怨自己没有出身背景，没有干爹，在这个时代，只要你拥有一个用户，你就拥有了一个开始。</p><p>愿你能够使用这套方法，建立自己的动手能力。动动手，你所在的小世界就会优化一点点。</p><p>愿你在这个时代，把握真正属于你的那个机会。把你一生积累的认知、审美、好恶全部用上，为这个世界提供一个不一样的产品，向世界交付你的价值。</p><p>愿你拥有自信、财富与荣耀。</p><p>让我们相信，明天会更好。</p><h3 id="结课辞-我想跟你继续的事"><a href="#结课辞-我想跟你继续的事" class="headerlink" title="结课辞 我想跟你继续的事"></a>结课辞 我想跟你继续的事</h3><p>亲爱的你，</p><p>一晃《产品思维30讲》到了结课的时候，此刻的心情很轻松，有点开心，还有些意犹未尽。</p><p>表扬学完每一课的你，其实每一课知识点都挺硬的，岁末又是极忙的时刻，每天跟上进度，要付出很大努力，真心赞一个。</p><p>这些知识点，是过去20年我们互联网圈一仗一仗打出来的真功夫，所以如果你能领会，与你的实际工作和生活对照，一定不白学。</p><p>表扬认真写作业的你，后台留言作业数量和质量让我惊到，很多作业都非常棒。也许是得到已经形成了良好的学习气氛，也许是因为你信任我，愿意把自己的真实感受告诉我。</p><p>表扬认真写作业的你，得到的同学的作业数量和质量，让我惊到。也许是得到已经形成的学习气氛，也许是因为你信任我，愿意把自己的真实感受告诉我。很多作业都非常棒。因为篇幅有限，非常多的好内容没有办法放出。但是可以保证的一件事是，每一篇作业，每一条留言，我都读了。</p><p>感谢在后台留言中给我肯定的你。“产品思维”是互联网经济快速崛起的重要思考框架，但放在得到这样的一个广众平台，受众面还是太窄了。曾经担心会不会没有人来学，或者听不懂。你们的肯定，很大地安慰了我，让我觉得半年的打磨，还是值得的。谢谢。</p><p>很多同学问到第二季，我想如果在得到平台的订阅超过10万，我就做第二季。</p><h4 id="等你“泄密”"><a href="#等你“泄密”" class="headerlink" title="等你“泄密”"></a>等你“泄密”</h4><p>做完这30讲，我和你一样意犹未尽。</p><p>从2018年3月开始，我想继续与你保持线上的互动，为期三个月。</p><p>我和你一起按照《产品思维30讲》的思考框架，分析一些正在运营中的真实产品，包括但不限于互联网产品、餐饮、日用消费品、电子科技产品、影视娱乐等。</p><p>具体分析什么产品？我希望是：你“泄密”，我分析。</p><p>如果你是一个产品的参与者，你可以把你观察到的，这个产品的优秀点、成功之处或者经验告诉我。你可以选择匿名，也可以选择公开。你可以告诉我这是什么产品，也可以保密。但是，你一定要讲被验证的干货经验。</p><p>只要你的内容被选中，大礼奉上。</p><p>我会不定期汇总，在课程内更新。</p><p>课程的部分，暂时就到这了。后面案例分析的部分，就等你的“泄密”啦～</p><p>梁宁2018.2.3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;01-产品能力是每个人的底层能力&quot;&gt;&lt;a href=&quot;#01-产品能力是每个人的底层能力&quot; class=&quot;headerlink&quot; title=&quot;01 产品能力是每个人的底层能力&quot;&gt;&lt;/a&gt;01 产品能力是每个人的底层能力&lt;/h3&gt;&lt;p&gt;你好，欢迎来到《梁宁·产品思
      
    
    </summary>
    
      <category term="产品运营" scheme="http://gnbyj.cn/categories/%E4%BA%A7%E5%93%81%E8%BF%90%E8%90%A5/"/>
    
    
      <category term="产品思维" scheme="http://gnbyj.cn/tags/%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础知识点</title>
    <link href="http://gnbyj.cn/2018/07/16/Java/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://gnbyj.cn/2018/07/16/Java/Java基础/</id>
    <published>2018-07-16T10:00:00.000Z</published>
    <updated>2018-07-25T04:02:47.187Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux常用命令："><a href="#Linux常用命令：" class="headerlink" title="Linux常用命令："></a><strong>Linux常用命令</strong>：</h4><p>​    pwd：用于显示当前工作目录。<br>    ls：用于查看当前工作目录内容。<br>    cd：用于改变当前工作目录。 </p><hr><p><strong>相对路径</strong>：文件或目录相对于当前工作目录的位置。</p><p>​        “.”表示当前目录，“..”表示上一级目录。</p><p><strong>绝对路径</strong>：文件或目录相对于根目录的位置，绝对路径都从“/”开始。</p><hr><h4 id="先编译、后执行的原则"><a href="#先编译、后执行的原则" class="headerlink" title="先编译、后执行的原则"></a>先编译、后执行的原则</h4><p>通过javac命令将JAVA源程序(.java)先编译成字节码文件(.class)，</p><p>​    编译错误即为javac过程出现的错误，主要是由于语法问题导致的</p><p>通过java命令启动JVM，由JVM来加载.class文件并运行.class文件。</p><hr><p><strong>JDK</strong>（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。</p><p><strong>JRE</strong>（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。</p><p><strong>JVM</strong>（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。</p><hr><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>内存中数据的代词，指代在内存中开辟的存储空间。</p><p>变量的声明：用特定语法声明一个变量，让运行环境为其分配空间。 </p><p>变量的命名：需要有个见名知意的名字，而且要符合Java语言规范：</p><ul><li>可以在一条语句中声明多个同类型变量，中间使用逗号分隔。</li><li>可以由字母、数字、“_”或“$”符组成，但是不能以数字开头。 </li><li>中文可以作为变量名，但不提倡使用。 </li><li>Java大小写敏感，即：严格区分大小写，在给命名变量时需要注意。 </li><li>不能使用Java保留字（一些Java语言规定好的，有特殊含义的字符），如：int、if、else、for、break等。 </li><li>“见名知意”，采用“驼峰命名法”。</li></ul><p>变量的初始化：变量声明后，要为其赋一个确定的初值后再使用。 </p><ul><li>变量在使用之前必须初始化，即必须给该变量赋予特定的值。</li><li>在声明变量时初始化；</li><li>在第一次使用变量前初始化；</li></ul><p>变量的访问：可以对变量中的数据进行存取、操作，但必须和其类型匹配。</p><hr><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>主要分为4大类 （整数类型、浮点类型、char、boolean）： </p><ul><li>整数类型又分为了4小类（byte、short、int（默认类型）、long）, </li><li>浮点类型也分了2小类（float、double（默认类型）），</li><li>char，</li><li>boolean</li></ul><p>double类型的精度值是float类型的两倍，因此而得名双精度。double运算时会出现舍入误差。</p><p>字符类型char一个16位无符号整数，对应字符的编码，Unicode是世界通用的定长字符集，所有的字符都是16位来表示。</p><p>对char型变量赋值：</p><ul><li>字符直接量</li><li>整型直接量</li><li>Unicode形式</li></ul><hr><p>自动类型转换（隐式类型转换）</p><ul><li>int直接量可以直接赋值给byte、char和short，只要不超过其表示范围。</li><li>byte、char、short三种类型参与运算时，先一律转换成int类型再进行运算。</li></ul><p>强制类型转换（显式类型转换）</p><hr><p>switch-case-break</p><p>在很多情况下,switch-case可以代替else if结构，而switch-case实现分支功能的效率要高于else if结构，并且结构更清晰，所以推荐使用。从JDK 7.0开始，switch-case可以支持字符串表达式，将更加方便程序的操作。</p><p>break用在循环体中用于退出循环结构</p><p>return结束方法</p><p>continue结束本次循环</p><p>固定次数的循环，这种情况，优先考虑使用for语句来实现。</p><p>“当”循环——while(){…}</p><p>“直到”循环——do{…}while()</p><p>固定次数循环——for(;;){…}</p><hr><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组为相同数据类型的元素组成的集合，</p><p>数组元素按线性顺序排列，</p><p>所谓线性顺序是指除第一个元素外，每一个元素都有唯一的前驱元素；除最后一个元素外，每一个元素都有唯一的后继元素（“一个跟一个”），</p><p>可以通过元素所在位置的顺序号（下标）做标识访问每一个元素（下标从0开始，最大到元素个数-1），</p><p>定义基本类型数组的要点包括：</p><ul><li>确切的数据类型：用于开辟空间大小 </li><li>整体的数组名字：用于对数据的引用 </li><li>不能缺少的“[]”</li></ul><p>基本类型的数组创建后，默认为其数组元素设置了初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 初始化后有默认值0</span></span><br></pre></td></tr></table></figure><p>手动设置初始值，可以在数组声明的同时进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">10</span>,<span class="number">23</span>,<span class="number">30</span>,-<span class="number">10</span>,<span class="number">21</span> &#125;; <span class="comment">// 只能用于声明时的初始化，不能用于先声明后赋值的情况</span></span><br></pre></td></tr></table></figure><p>对于已声明的数组，数组类型变量进行初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">10</span>,<span class="number">23</span>,<span class="number">30</span>,-<span class="number">10</span>,<span class="number">21</span> &#125;;</span><br></pre></td></tr></table></figure><p>数组有length属性</p><p>通过下标访问数组元素</p><p>for循环遍历数组元素</p><h4 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">10</span> ,<span class="number">20</span> ,<span class="number">30</span> ,<span class="number">40</span> ,<span class="number">50</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>] ;</span><br><span class="line">System.arraycopy( a , <span class="number">1</span> , a1 , <span class="number">0</span> , <span class="number">4</span> ); </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * src：源数组 </span></span><br><span class="line"><span class="comment"> * srcPos：源数组中的起始位置 </span></span><br><span class="line"><span class="comment"> * dest：目标数组 </span></span><br><span class="line"><span class="comment"> * destPos : 目标数组中的起始位置 </span></span><br><span class="line"><span class="comment"> * length：要复制的数组元素的数量 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Arrays.copyOf()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] a1 = Arrays.copyOf(a, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>生成的新数组是原始数组的副本； </p><p>newLength小于源数组，则进行截取；（自己通过代码演示效果）； </p><p>newLength大于源数组，则用0或 null进行填充； </p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>所谓的扩容实际上是指创建一个更大的新数组并将原有数组的内容复制到其中。</p><h4 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h4><p>一般情况下，通过排序过程中数组元素的交换次数来衡量排序算法的优劣。</p><p>常用排序算法有：插入排序、冒泡排序、快速排序等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">89</span>,<span class="number">50</span>,<span class="number">84</span>,<span class="number">57</span>,<span class="number">61</span>,<span class="number">20</span>,<span class="number">86</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                   &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrays.sort方法用于数组排序</p><p>int[] arr = new int[3]</p><p>在堆内存中分配了数组对象，分配三个int型空间，并将每个元素赋初始值为0，栈中存储对堆中数据的引用，即堆中int数组的首地址。</p><p>引用类型数组，即数组元素的类型不是基本类型，而是引用类型。初始值为null。</p><hr><p>方法用于封装一个特定的功能，</p><p>定义时需要考虑五个要素：</p><p>修饰词、public/protected/private static final</p><p>返回值类型、void/…</p><p>方法名、xxx</p><p>参数列表、(args)</p><p>方法体 {…}</p><hr><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>以对象为中心来构建软件系统</p><p>面向对象的第一步就是抽象数据类型——将不同类型的数据的集合组成一个整体用来描述一种新的事物。</p><p>类定义了一种抽象数据类型，包括抽象数据类型的组成（成员变量/属性）和该类型可以干的事（方法）。</p><p>类是一种引用数据类型。类为对象的模板。</p><p>类的定义包括“成员变量”的定义和“方法”的定义，</p><p>“成员变量”用于描述一类对象共同的数据结构;</p><p>定义方法，用于描述对象的形为，封装对象的功能。</p><p>实例化——使用new关键字来创建对象</p><p>引用——对实例化的对象进行访问控制，特殊的变量</p><p>引用类型变量可以存储该类对象的地址信息，通常称为“指向该类的对象”，</p><p>当一个引用类型变量指向该类的对象，就可以通过这个变量对对象实施访问。 </p><p>除8种基本类型之外，用类、接口、数组等声明的变量都称为引用类型变量，简称“引用”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point  p       =  <span class="keyword">new</span> Point();</span><br><span class="line">类       引用       对象</span><br></pre></td></tr></table></figure><p>引用类型变量之间的赋值不会创建新的对象，但有可能会使两个以上的引用指向同一个对象。</p><p>当一个引用的值为null的时候，通过引用访问对象成员变量或者调用方法会产生NullPointerException（空指针异常）。</p><hr><p>方法的签名：方法名和参数列表。</p><p>一个类中不可以有两个方法签名完全相同的方法！</p><p>在Java语言中，允许多个方法的名称相同，但参数列表不同，此种方式称为方法的重载(overload)。</p><p>编译时根据签名绑定调用方法，编译器会在编译时根据签名的不同来绑定调用不同的方法，编译期多态！</p><hr><p>构造方法</p><p>构造方法的名称必须与类名相同。 </p><p>构造方法没有返回值，但也不能写void。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【访问修饰符】类名()&#123;</span><br><span class="line">         // 构造方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java语言中的构造方法常常<strong>用于实现对对象成员变量的初始化！</strong></p><p>在创建对象时，构造方法写在new关键字之后，可以理解为：</p><p>“new”创建了对象，而构造方法对该对象进行了初始化。</p><p>this关键字用在方法体中，用于指代<u>调用该方法</u>的当前对象。在没有歧义的情况下可以省略this。</p><p>在构造方法中，用来初始化成员变量的参数一般和成员变量取相同的名字，这样会有利于代码的可读性，但此处就必须通过this关键字来区分成员变量和参数。</p><p>JAVA语法规定，任何一个类都必须含有构造方法，假如源程序中没有定义，则编译器在编译时将为其添加一个无参的空构造方法（此方法称之为“默认的构造方法”）。</p><p>构造方法的重载</p><p>在构造方法中可以通过this关键字来调用另外的一个重载的构造方法。</p><hr><p>java程序所需内存均由JVM进行管理分配，开发者只需关心JVM是如何管理内存的</p><p>JVM会将申请的内存从逻辑上划分为三个区域：堆、栈、方法区。</p><p>对象存储在堆中——存储使用new关键字所创建的对象。</p><p>引用类型变量在栈内存中——方法中的变量即为局部变量，是在栈内存中分配，若变量为值类型，则在栈中存储的就是该变量的值。若变量为引用类型，则在栈中存储的是堆中对象的地址。</p><p>方法区用于存放类的信息——Java程序运行时，首先会通过类装载器载入类文件的字节码信息，经过解析后将其装入方法区。</p><p>类在实例化对象时，多个对象会拥有各自在堆中的空间，但所有实例对象是共用在方法区中的一份方法定义的。意味着，方法只有一份。</p><p>static成员变量和类的信息一起存储在方法区。</p><hr><p><strong>成员变量的生命周期</strong></p><p>从对象在堆中创建开始到对象从堆中被回收结束。</p><p>当一个对象没有任何引用时，该对象被视为废弃的对象，属于被回收的范围，同时该对象中的所有成员变量也随之被回收。</p><p><strong>局部变量的生命周期</strong></p><p>一个运行的Java程序从开始到结束会有多次方法的调用。</p><p>JVM会为每一个方法的调用在栈中分配一个对应的空间，这个空间称为该方法的栈帧。</p><p>一个栈帧对应一个正在调用中的方法，栈帧中存储了该方法的参数、局部变量等数据。</p><p>当某一个方法调用完成后，其对应的栈帧将被清除，局部变量即失效。</p><p><strong>成员变量：</strong></p><p>1)定义在类中，方法外；</p><p>2)由系统设定默认初始值，可以不显式初始化；</p><p>3)所在类被实例化后，存在堆中，对象被回收时，成员变量失效；</p><p><strong>局部变量：</strong></p><p>1)定义在方法中；</p><p>2)没有默认值，必须自行设定初始值；</p><p>3)方法被调用时，存在栈中，方法调用结束时局部变量从栈中清除；</p><hr><p>垃圾回收器（Garbage Collection，GC）是JVM自带的一个线程（自动运行着的程序），用于回收没有任何引用所指向的对象。</p><p>内存泄露是指，不再被使用的内存没有被及时的回收。</p><p>当确定该对象不再使用时，应该及时的将其引用设置为null，该对象即不再被引用，属于可回收的范围。</p><p>当我们需要GC线程即刻回收无用对象时，可以调用System.gc()方法。此方法用于建议JVM马上调度GC线程回收资源。</p><hr><h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><p>将公共的信息存放在父类中，子类继承父类，子类即可以共享父类的数据。这个过程就是泛化的过程。</p><p>Java语言不支持多重继承，即：一个类只能继承一个父类，但一个父类可以有多个子类。</p><p>在java语言中，需要通过<strong>extends</strong>关键字实现类的继承。</p><p>使用继承可以实现代码的复用。</p><hr><p>java规定，子类在构造之前必须先构造父类。</p><p>子类的构造方法中是必须要通过super关键字来调用父类的构造方法的。</p><p>super();为编译器自动加入的，并且super关键字必须位于子类构造方法的第一行，否则会有编译错误。</p><p>若父类没有提供无参的构造方法，则会出现编译错误。</p><p>方案一：在父类中添加无参的构造方法，</p><p>方案二：在子类构造方法中显式调用父类的有参构造方法（常常使用）。</p><hr><p>一个子类的对象可以向上造型为父类的类型。即，</p><p>定义父类型Foo的引用obj可以指向子类的对象new Goo()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;...&#125;</span><br><span class="line">class Goo extends Foo &#123;...&#125;</span><br><span class="line">Foo obj = new Goo(100,3);</span><br></pre></td></tr></table></figure><p><strong>通过父类的引用只能访问父类所定义的<u>成员</u>，而不能访问子类所扩展的部分。</strong></p><p>在java语言中，子类可以重写（覆盖）继承自父类的方法，即方法名和参数列表与父类的方法相同，但是方法的实现不同。</p><p>当子类重写了父类的方法后，该重写方法被调用时（无论是通过子类的引用调用还是通过父类的引用调用），<strong>运行的都是子类重写后的版本</strong>。</p><hr><p>o 重载： 是指在一个类中定义多个方法名相同但参数列表不同的方法，在编译时，根据参数的个数和类型来决定绑定哪个方法。 </p><p>o 重写： 是指在子类中定义和父类完全相同的方法，在程序运行时，根据对象的类型（而不是引用类型）而调用不同的方法。</p><p>重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。</p><p>重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法。</p><hr><p>在Java语言中，命名冲突问题是用包（package）的概念来解决的。</p><p>类的全称应该是“包名.类名”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.lang.StringUtil</span><br><span class="line"><span class="comment">// org.apache表示公司或组织的信息（是这个公司或组织域名的反写）；</span></span><br><span class="line"><span class="comment">// commons表示项目的名称信息；</span></span><br><span class="line"><span class="comment">// lang表示模块的名称信息。</span></span><br></pre></td></tr></table></figure><hr><h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h4><p>降低代码出错的可能性，更便于维护。 </p><p>当内部实现细节改变时，只要保证对外的功能定义不变，其他的模块不需要更改。</p><p>在软件系统中，封装常常需要依靠一些访问控制修饰符来实现。</p><p>访问控制符修饰类：</p><ul><li>对于类的修饰可以使用public和默认方式。其中，public修饰的类可以被任何一个类使用，而默认访问控制的类只可以被同一个包中的类使用。</li><li>而protected和private访问修饰符是不可以修饰类的，但其可以修饰内部类。</li></ul><p>访问控制符修饰成员：</p><ul><li>public 修饰符，在任何地方都可以访问；</li><li>protected可以在本类、同一包中的类、子类中访问，除此之外的其它类不可以访问；</li><li>默认方式为可以本类及同一包中的类访问，除此之外其它类不可以访问；</li><li>private只可以在本类中访问，其它任何类都不可以。</li></ul><hr><p>static修饰成员变量，属于类的变量，通常通过类名来引用static成员。</p><p>static成员变量和类的信息一起存储在方法区, 而不是在堆中。</p><p>一个类的static成员变量只有“一份”（存储在方法区），无论该类创建了多少对象。</p><p>static修饰方法，在static方法中是不可以使用this关键字的。</p><p>static方法的作用在于提供一些“工具方法”和“工厂方法”。</p><p>由于static在调用时没有具体的对象，因此在static方法中不能对非static成员（对象成员）进行访问。</p><p>static块为属于类的代码块，在类加载期间执行的代码块，只执行一次，可以用来在软件中加载静态资源（图像、音频等等）。</p><p>在类加载时，先运行了静态块，而后执行了构造方法，即，static块是在创建对象之前执行的。</p><hr><p>final修饰变量，意为不可改变。</p><p>final修饰成员变量时，有两种初始化方式：</p><ul><li>声明同时初始化；</li><li>构造函数中初始化；</li></ul><p>final关键字修饰局部变量，在使用之前初始化即可。</p><p>final关键字修饰的方法不可以被重写。防止子类在定义新方法时造成的“不经意”重写。</p><p>final关键字修饰的类不可以被继承。使一个类不能被继承的意义在于：可以保护类不被继承修改，可以控制滥用继承对系统造成的危害。</p><p>static final 修饰的成员变量称为常量，必须声明同时初始化，并且不可被改变。常量建议所有字母大写。常量在编译期被替换的。节约开支。</p><hr><p>由abstract修饰的方法为抽象方法，抽象方法即只有方法的定义，没有方法体实现，用一个分号结尾。不完整的方法。</p><p>若将抽象方法包含在类中，则该类也应该为抽象的，该类也不完整。</p><p>抽象类由abstract关键字声明。</p><p><strong>抽象类是不能实例化对象的</strong>，需要定义类来继承抽象类，重写其抽象方法。</p><p>即使一个类中没有抽象方法，也可以将其定义为抽象类，该类也不可以实例化。</p><p><u>abstract和final关键字不可以同时用于修饰一个类，因为final关键字使得类不可继承，而abstract修饰的类如果不可以继承将没有任何意义。两者放在一起，会起冲突。</u></p><p>抽象类的意义：</p><ul><li>为其子类提供一个公共的类型（父类引用指向子类对象）； </li><li>封装子类中的重复内容（成员变量和方法）; </li><li>定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的。(子类需要实现此抽象方法)。</li></ul><hr><p>接口可以看成是特殊的抽象类。</p><p>即只包含抽象方法和常量的抽象类。</p><p>可以通过interface关键字来定义接口。</p><p>一个类可以实现多个接口，实现的接口直接用逗号分隔。</p><p>该类需要实现这些接口中定义的所有方法；</p><p>接口可以作为一种类型声明变量，一个接口类型的变量可以引用实现了该接口的类的对象；通过该变量可以调用该接口中定义的方法。</p><p>class AmericanCurl implements Runner , … {}</p><p>Runner runner = new AmericanCurl(); </p><p>一个接口类型变量，引用了子类的对象。调用时，调用的是子类对象的具体的实现。</p><p>接口间可以存在继承关系，一个接口可以通过extends关键字继承另外一个接口。</p><p>子接口继承了父接口中定义的所有方法。</p><p>一个类只能继承一个抽象类，但可以实现多个接口。 </p><p>抽象类中可以包含抽象方法和非抽象方法，而接口中的所有方法均为抽象的。 </p><p>子类继承抽象类必须实现抽象类中所有抽象方法，否则子类也必须是抽象类。而子类实现接口则必须实现接口中的所有抽象方法。 </p><hr><p>多态即多种形态</p><p>同样类型，当指向不同的对象时，可以有不同的表现。</p><p>同样一个对象，造型成不同的类型时，会有不同的功能。</p><p>向上造型：父类的引用指向子类的对象</p><p>一个类的对象可以向上造型的类型有：父类的类型及其实现的接口类型。</p><p>强制转换将父类型变量转换为子类型变量，前提是该变量指向的对象确实是该子类类型。</p><p>也可通过强制转换将变量转换为某种接口类型，前提是该变量指向的对象确实实现了该接口。</p><p>在强制转型中，为了避免出现ClassCastException，可以通过instanceof关键字判断某个引用指向的对象是否为指定类型。先通过instanceof关键字判断，而后再转型。这样则可以避免发生ClassCastException，因为只要instanceof为true，则强制转换一定成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> Object</span><br></pre></td></tr></table></figure><p>一个类可以定义在另外一个类的内部，定义在类内部的类称之为Inner，其所在的类称之为Outer；Inter定义在Outer的内部，通常只服务于Outer，对外不具备可见性，Inter可以直接调用Outer的成员及方法（包括私有的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeInc</span><span class="params">()</span></span>&#123;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类可以不必命名，称之为匿名内部类。</p><hr><p>常用的文档注释规范</p><p>@author</p><p>@deprecated</p><p>@since</p><p>@param</p><p>@return</p><hr><p>String对象为不可变对象，这样做的目的是可以最大程度的重用相同内容的字符串以减小系统资源的开销。</p><p>字符串常量池(一个JVM内部维护的内存区域，用来保存已经创建过的字符串对象)</p><p>当我们通过字面量，常量来初始化一个字符串时，JVM首先会从常量池中查询用来保存该字符串的对象是否存在，若存在则直接引用，若不存在则创建该字符串对象并存入常量池，然后引用它。</p><hr><p>java存储每一个字符均使用2个字节保存；</p><p>任何一个字符(无论是英文还是汉字)每个字符的长度都是1；</p><p>字符串的长度就是该字符串所有的字符个数。</p><p>返int</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.length())； //返回当前字符串的长度。这是一个方法。</span><br><span class="line">str.indexOf(&apos;W&apos;)); //第一次出现的下标位置，无则返-1。</span><br></pre></td></tr></table></figure><p>返String</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.substring(0,5);  //从哪里开始，截取到哪里。含头不含尾的。</span><br><span class="line">str.trim(); //将字符串两边的空白去除</span><br><span class="line">str.toLowerCase(); //变小写</span><br><span class="line">str.toUpperCase(); //变大写</span><br><span class="line">String valueOf(); //将其他基本类型的值以字符串的形式描述</span><br></pre></td></tr></table></figure><p>返char</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(5); //获取这个位置的字符</span><br></pre></td></tr></table></figure><p>返boolean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startsWith(String suffix) //是否是以给定的字符串开始</span><br><span class="line">str.endsWith(&quot;.jpg&quot;) //是否是以给定的字符串结束</span><br></pre></td></tr></table></figure><p>StringBuilder是可变字符串。</p><p>专门用于修改字符串内容的类:StringBuilder/StringBuffer</p><p>封装了可变的字符串</p><p>StringBuilder类的常用方法有：</p><p>append(String str)：追加字符串； </p><p>insert (int dstOffset，String s)：将给定的字符串插入到指定的位置； </p><p>delete(int start，int end)：删除字符串，含头不含尾； </p><p>replace(int start，int end，String str): 替换字符串； </p><p>reverse()：字符串反转。</p><p>将StringBuilder转换为String：sb.toString();</p><p>StringBuffer 和StringBuilder的区别：</p><p>StringBuffer是线程安全的，同步处理的，性能稍慢； </p><p>StringBuilder是非线程安全的，并发处理的，性能稍快。 </p><hr><p>正则表达式</p><blockquote><p>“.”点儿，在正则表达式中表示任意一个字符。</p><p>“\”在正则表达式中是转意字符，当我们需要描述一个已经被正则表达式使用的特殊字符时，我们就可以通过使用”\”将其转变为原本的意思。</p><p>\d：表示任意一个数字 </p><p>\w：表示任意一个单词字符（只能是 数字，字母，下划线） </p><p>\s：表示任意一个空白字符(\t \r \n \f \x0B) </p><p>\D：表示任意一个非数字字符 </p><p>\W：表示任意一个非单词字符 </p><p>\S：表示任意一个非空白字符 </p><p>“[]”用来描述单一字符</p><p>[abc]: 表示该字符只能是a或者b或者c；</p><p>[123]: 表示该字符只能是1或者2或者3；</p><p>[a-z]，表示该字符可以是任意一个小写字母；</p><p>[0-9] 来表示该字符可以是任意一个数字；</p><p>[a-zA-Z0-9_] 表示该字符可以是任意字母，数字以及”下划线”。</p><p>“+”：表示内容可以连续出现至少1次以上 </p><p>“*”：表示内容出现0-若干次 </p><p>“?”：表示内容出现0-1次 </p><p>{n}：表示内容必须出现n次 </p><p>{n,m}：表示内容出现n-m次 </p><p>{n,}：表示内容出现至少n次 </p><p>分组”()”</p><p>() 可以将内容看做一个整体，()中可以使用”|”来表示或关系。</p><p>例如，(+86|0086) 表示这里可以是+86或者0086。</p><p>开始添加”^”以及末尾添加”$”来表示一个整体</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str.matches(regEx)</span><br><span class="line"></span><br><span class="line">String[] split(String regex)</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex,String replacement)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String emailRegEx </span>= <span class="string">"^[a-zA-Z0-9_.-]+@([a-zA-Z0-9-]+\\.)+[a-zA-Z0-9]&#123;2,4&#125;$"</span>;</span><br></pre></td></tr></table></figure><hr><p>Object类是java中所有类的顶级父类。</p><p>String toString():该方法java希望我们重写时返回一个字符串，这个字符串的原则为:用一个字符串来描述当前对象。</p><p>Object实现了toString()方法，返回的是当前对象的“句柄”。</p><p>格式为:类的完全限定名@hashcode。</p><hr><h4 id="如何重写equals方法？"><a href="#如何重写equals方法？" class="headerlink" title="如何重写equals方法？"></a>如何重写equals方法？</h4><p>重写equals方法应遵循几个规则:</p><p>任何对象与null比较都应返回false </p><p>两个对象不属于同一个类时应返回false </p><p>同一个对象equals比较应当恒等为true</p><h4 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与 == 的区别"></a>equals与 == 的区别</h4><p>“==”是值比较，对于引用类型变量而言，该变量保存的是对象的地址，所以使用”==”比较时，意思为两个变量的地址是否相等，换句话说就是看两个变量引用的是否为同一个对象</p><p>equals是内容比较，对于两个引用变量而言，是比较两个变量所引用的对象内容是否相同。</p><p>“==”是判断是否为同一个，而”equals”是判断像不像。</p><hr><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>java.lang.Byte</td></tr><tr><td>short</td><td>java.lang.Short</td></tr><tr><td>int</td><td>java.lang.Integer</td></tr><tr><td>long</td><td>java.lang.Long</td></tr><tr><td>float</td><td>java.lang.Float</td></tr><tr><td>double</td><td>java.lang.Double</td></tr><tr><td>char</td><td>java.lang.Character</td></tr><tr><td>boolean</td><td>java.lang.Boolean</td></tr></tbody></table><p>除了Character与Boolean的父类是Object之外，其余的都是继承自:java.lang.Number</p><p>Number是一个抽象类。本身不能实例化。Number 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法</p><p>Integer有一个静态方法static int parseInt(String s)。</p><p>该方法的作用是将一个描述整数的字符串解析为该整数，并用int形式返回。该方法可能会抛出NumberFormatException异常:当给定的字符串里边含有非整数字符时。</p><p>Double有一个静态方法static double parseDouble(String s)。</p><p>该方法的作用是将一个描述小数的字符串解析为该小数，并用double形式返回。该方法可能会抛出NumberFormatException异常: 如果字符串不包含可解析的 double 值。</p><hr><p>装箱：</p><p>静态方法valueOf()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">Double d = Double.valueOf(<span class="number">1.1</span>);</span><br></pre></td></tr></table></figure><p>拆箱：</p><p>包装类的方法xxxValue()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> n = i.intValue();</span><br><span class="line">Double d = <span class="keyword">new</span> Double(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">double</span> dn = d.doubleValue();</span><br></pre></td></tr></table></figure><p>自动拆装箱</p><p>JVM不支持该特性，自动拆装箱只是编译器在编译过程中的”预处理”操作。编译器在看到需要在包装类与基本类型之间转换时，会在编译为字节码时进行改变。</p><hr><p>java.util.Date 类封装日期及时间信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();             <span class="comment">// 系统当前的日期及时间信息   </span></span><br><span class="line">System.out.println(date);           <span class="comment">// Sun Jan 06 11:52:55 CST 2013   </span></span><br><span class="line"><span class="keyword">long</span> time = date.getTime();       <span class="comment">//1970年1月1日至今的毫秒数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span> <span class="comment">//毫秒差</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> <span class="comment">//毫秒差</span></span></span><br></pre></td></tr></table></figure><p>SimpleDateFormat就是根据一个特定的日期格式在字符串与Date之间相互转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Date格式化为String</span></span><br><span class="line">Date now = <span class="keyword">new</span> Date();<span class="comment">//默认实例化的Date表示当前系统时间</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String str = sdf.format(now);</span><br><span class="line">System.out.println(str);<span class="comment">//2014-01-06 13:21:12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将String解析为Date</span></span><br><span class="line">String str = <span class="string">"2008年08月08日 12:22:46"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">Date date = sdf.parse(str);</span><br><span class="line">System.out.println(date);<span class="comment">// Fri Aug 08 12:22:46 CST 2008</span></span><br></pre></td></tr></table></figure><p>java.util.Calendar 类用于封装日历信息，其主要作用在于其方法可以对时间分量进行运算。</p><p>Calendar是抽象类，其提供了一个工厂方法:Calendar getInstance()。</p><p>该方法可以根据当前系统所在地区获取一个适当的Calendar的子类实现。在实际开发中，也推荐使用该方法来实例化Calendar的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置日期及时间分量</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();<span class="comment">//创建出的Calendar表示当前系统时间</span></span><br><span class="line"><span class="comment">//设置年为2008年</span></span><br><span class="line">calendar.set(Calendar.YEAR,<span class="number">2008</span>);</span><br><span class="line"><span class="comment">//设置月为5月</span></span><br><span class="line">calendar.set(Calendar.Month,<span class="number">4</span>);<span class="comment">//月份从0开始</span></span><br><span class="line">calendar.set(Calendar.Month,Calendar.MAY);<span class="comment">//也可以使用常量来设置</span></span><br><span class="line"><span class="comment">//设置日为30日</span></span><br><span class="line">caneldar.set(Calendar.DAY_OF_MONTH,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//获取时间分量对应的值</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> year = calendar.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = calednar.get(Calendar.Month);</span><br><span class="line"><span class="keyword">int</span> date = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"><span class="comment">//需要注意，月份要加1，因为月份是从0开始的</span></span><br><span class="line">System.out.println(year+<span class="string">"-"</span>+(month+<span class="number">1</span>)+<span class="string">"-"</span>+date);<span class="comment">//2014-1-4</span></span><br></pre></td></tr></table></figure><p>获取给定时间分量所允许的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> max = calendar. getActualMaximum(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(<span class="string">"当前月的最后一天为:"</span>+max+<span class="string">"日"</span>);<span class="comment">//当前月的最后一天为31日</span></span><br></pre></td></tr></table></figure><p>对某个时间分量的值进行计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();<span class="comment">//计算明天(在日的基础上加一天)</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_YEAR,<span class="number">1</span>);<span class="comment">//当前Calendar表示的为2014-02-01，月进位了</span></span><br></pre></td></tr></table></figure><p>Calendar的void setTime(Date date),允许我们为Calendar设置Date对象所表示的时间。</p><p>Calendar的 Date getTime(),允许我们获取一个使用Date对象描述的Calendar所表示的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure><hr><p>集合框架</p><p>Collection是一个接口，其定义了集合的相关功能方法。</p><p>Collection派生出了两个子接口，一个是List另一个则是Set。</p><p>List:称为可重复集，该集合中是允许存放重复元素的；</p><p>Set:称为不可重复集，该集合中是不能将相同的元素存入集合两次。</p><p>集合只存储了元素对象在堆中的地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>boolean contains(Object o)</p><p>该方法会用于判断给定的元素是否被包含在集合中。</p><p>List集合contains方法和对象的equals方法相关</p><p>size方法用于获取当前集合中的元素总数。该方法定义为:int size()</p><p>clear方法用于清空集合。该方法定义为:void clear()</p><p>isEmpty方法用于判断当前集合中是否不 包含元素。该方法定义为:boolean isEmpty()</p><p>addAll方法用于将给定集合中的所有元素添加到当前集合中</p><p>boolean addAll(Collection c)</p><p>containsAll方法用于判断当前集合是否包含给定集合中的所有元素，若包含则返回true。boolean containsAll(Collection c)</p><hr><p>Iterator 迭代器</p><p>遍历集合应遵循“先问后取”的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">c.add(<span class="string">"java"</span>);</span><br><span class="line">c.add(<span class="string">"cpp"</span>);</span><br><span class="line">c.add(<span class="string">"php"</span>);</span><br><span class="line">c.add(<span class="string">"c#"</span>);</span><br><span class="line">c.add(<span class="string">"objective-c"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123; <span class="comment">//判断集合是否还有元素可以遍历</span></span><br><span class="line">    String str = it.next(); <span class="comment">//返回迭代的下一个元素</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器还提供了一个方法:void remove()。在使用迭代器遍历集合时是不能通过集合自身提供的remove方法删除元素的，否则迭代器在迭代时会抛出异常。</p><hr><p>增强for循环,也称为新循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 e : 集合或数组)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>泛型的本质是参数化类型</p><p>所操作的数据类型被传入的参数指定。</p><p>Java编译器可以据此进行类型检查，这样可以减少代码在运行时出现错误的可能性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//泛型E在这里被指定为String类型</span></span><br></pre></td></tr></table></figure><hr><p>线性表</p><p>将List理解为存放对象的数组，元素个数可以动态的增加或减少，并且List是可重复集。</p><p>List接口的两个常见实现类为ArrayList和LinkedList，分别用动态数组和链表的方式实现了List接口。</p><p>ArrayList更适合于随机访问而LinkedList更适合于插入和删除。</p><p>E get(int index):获取集合中指定下标对应的元素，下标从0开始。 </p><p>E set(int index, E elment):将给定的元素存入给定位置，并将原位置的元素返回。</p><p>void add(int index,E element):将给定的元素插入到指定位置，原位置及后续元素都顺序向后移动。</p><p>E remove(int index):删除给定位置的元素，并将被删除的元素返回。</p><p>List<e> subList(int fromIndex, int toIndex):subList获取的子List与原List占有相同的存储空间，对子List的操作会影响的原List。下标含头不含尾。</e></p><h4 id="List与数组互转"><a href="#List与数组互转" class="headerlink" title="List与数组互转"></a>List与数组互转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = list.toArray(<span class="keyword">new</span> String[] &#123;&#125;); </span><br><span class="line"></span><br><span class="line">String[] strArr = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;; </span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArr);</span><br></pre></td></tr></table></figure><p>返回的集合我们不能对其增删元素，否则会抛出异常。</p><p>解决方法：新建一个list1，将数组转化的list中元素添加list1中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list1.addAll(Arrays.asList(strArr));</span><br></pre></td></tr></table></figure><hr><h4 id="List排序"><a href="#List排序" class="headerlink" title="List排序"></a>List排序</h4><p>Collections.sort(list); //自然排序(按照元素的由小至大的顺序)</p><hr><p>Comparable是一个接口，用于定义其子类是可以比较的。因为该接口有一个抽象方法:int compareTo(T t)</p><p>所有子类都需要重写该方法来定义对象间的比较规则。</p><p>该方法要求返回一个整数，这个整数不关心具体的值，而是关注取值范围。</p><p>当返回值&gt;0时，表示当前对象比参数给定的对象大。 </p><p>当返回值&lt;0时，表示当前对象比参数给定的对象小。 </p><p>当返回值=0时，表示当前对象和参数给定的对象相等。 </p><p>一旦Java类实现了Comparable，其比较逻辑就已经确定；如果希望在排序的操作中临时指定比较规则，可以采用Comparator接口回调的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照col值的大小排序</span></span><br><span class="line">Collections.sort(cells, <span class="keyword">new</span> Comparator&lt;Cell&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cell o1, Cell o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.col - o2.col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>队列（Queue）：只能从线性表的一端添加（offer）元素，从另一端取出（poll）元素。队列遵循先进先出（FIFO First Input First Output ）的原则。</p><p>LinkedList实现Queue接口：Queue经常要进行插入和删除的操作，而LinkedList在这方面效率较高。</p><p>boolean offer(E e):将元素追加到队列末尾,若添加成功则返回true。 </p><p>E poll():从队首删除并返回该元素。 </p><p>E peek():返回队首元素，但是不删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue.offer(<span class="string">"a"</span>);</span><br><span class="line">queue.peek();</span><br><span class="line">queue.poll();</span><br><span class="line">queue.size();</span><br></pre></td></tr></table></figure><p>双端队列Deque，从队列的两端分别可以入队（offer）和出队（poll），LinkedList实现了该接口。</p><p>void push(E e):将给定元素”压入”栈中。存入的元素会在栈首。即:栈的第一个元素 </p><p>E pop():将栈首元素删除并返回。</p><p>E peek():返回队首元素，但是不删除。 </p><p>栈——将Deque限制为只能从一端入队和出队，入栈称之为push，出栈称之为pop。栈遵循先进后出（FILO First Input Last Output）的原则。</p><hr><p>查询表Map</p><p>以键值对(key-value)的形式存储数据的数据结构。</p><p>Map对存入的元素有一个要求，就是key不能重复，不能包含两个equals为true的key。</p><p>Map对于key,value的类型没有严格要求，只要是引用类型均可。使用泛型去约束key与value的类型。</p><p>V put(K k,V v)</p><p>若当次存入的key已经在Map中存在，则是替换value操作，而返回值则为被替换的元素。若此key不存在，那么返回值为null。</p><p>V get(Object key)</p><p>boolean containsKey(Object key)</p><p>HashMap是Map的一个常用的子类实现。其实使用散列算法实现的。</p><p>key–hashcode()–返回值 散列算法–数字即散列数组下标–存入对应位置链表节点</p><p>HashMap会将每组键值对封装为一个Entry的实例，然后将该实例存入链表。</p><blockquote><p>重写一个类的hashcode()方法有以下注意事项:</p><p>1、若一个类重写了equals()方法，那么就应当重写hashcode()方法。</p><p>2、若两个对象的equals()方法比较为true,那么它们应当具有相同的hashcode值。</p><p>3、对于同一个对象而言，在内容没有发生改变的情况下，多次调用hashCode()方法应当总是返回相同的值。</p><p>4、对于两个对象equals比较为false的，并不要求其hashcode值一定不同，但是应尽量保证不同，这样可以提高散列表性能。</p></blockquote><p>LinkedHashMap实现有序的Map</p><p>LinkedHashMap维护着一个双向循环链表。此链表定义了迭代顺序，该迭代顺序通常就是存放元素的顺序。</p><hr><h4 id="文件操作——File"><a href="#文件操作——File" class="headerlink" title="文件操作——File"></a>文件操作——File</h4><p>通过java.io.File类在程序中操作硬盘上的文件和目录，只能访问文件或目录的相关属性，不能对文件的内容进行访问。</p><p>File(String pathname)</p><p>提示:抽象路径应尽量使用相对路径，并且目录的层级分隔符不要直接写”/”或”\”,应使用File.separator这个常量表示，以避免不同系统带来的差异。</p><p>File(File parent,String child)</p><p>根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</p><p>boolean isFile()</p><p>该方法若返回true,这表示File表示的是一个文件。</p><p>long length() </p><p>该方法返回的long值表示该文件所占用的字节量。</p><p>boolean exists() </p><p>若该File表示的文件或目录存在则返回true,否则返回false。</p><p>boolean createNewFile()</p><p>返回值:如果指定的文件不存在并成功地创建，则返回 true；如果指定的文件已经存在，则返回 false 。</p><p>boolean delete()</p><p>返回值:当且仅当成功删除文件或目录时，返回 true；否则返回 false。</p><p>需要注意的是，若此File对象所表示的是一个目录时，在删除时需要保证此为空目录才可以成功删除(目录中不能含有任何子项)。</p><p>boolean isDirectory()</p><p>返回值:若File对象表示的是一个目录，则返回true</p><p>boolean mkdir()</p><p>返回值：当且仅当已创建目录时，返回 true；否则返回 false</p><p>boolean mkdirs()</p><p>返回值：当且仅当已创建目录以及所有必需的父目录时，返回 true；否则返回 false</p><p>File[] listFiles() </p><p>返回值：抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件和目录。如果目录为空，那么数组也将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 null。</p><p>File[] listFiles(FileFilter  filter)</p><p>FileFilter是用于抽象路径名的过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File[] list = dir.listFiles(<span class="keyword">new</span> FileFilter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathname.getName().startsWith(<span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h4 id="文件操作——RandomAccessFile"><a href="#文件操作——RandomAccessFile" class="headerlink" title="文件操作——RandomAccessFile"></a>文件操作——RandomAccessFile</h4><p>RandomAccessFile——对文件随机访问的操作，访问包括读和写操作。该类的读写是基于指针的操作。</p><p>只读模式(只读取文件数据)</p><p>RandomAccessFile(File file,String mode)    </p><p>RandomAccessFile(String filename,String mode)</p><p>读写模式(对文件数据进行读写)。</p><p>RandomAccessFile raf = new RandomAccessFile(file,”rw”);</p><hr><h4 id="字节数据读写操作"><a href="#字节数据读写操作" class="headerlink" title="字节数据读写操作"></a>字节数据读写操作</h4><p>void write(int d)</p><p>该方法会根据当前指针所在位置处写入一个字节，是将参数int的”低8位”写出。</p><p>int read()</p><p>该方法会从RandomAccessFile当前指针位置读取一个byte(8位) 填充到int的低八位, 高24位为0, 返回值范围正数: 0~255,</p><p>如果返回-1表示读取到了文件末尾EOF(EOF:End Of File)! </p><p>每次读取后自动移动文件指针, 准备下次读取。</p><p>向文件中写出一组字节：</p><p>void write(byte[] d)</p><p>void write(byte[] d,int offset,int len)</p><p>从文件中批量读取字节：</p><p>int read(byte[] b)</p><p>该方法会从文件中尝试最多读取给定数组的总长度的字节量，并从给定的字节数组第一个位置开始，将读取到的字节顺序存放至数组中，返回值为实际读取到的字节量 。</p><p>void close()</p><p>RandomAccessFile在对文件访问的操作全部结束后，要调用close()方法来释放与其关联的所有系统资源。</p><p>long getFilePointer()</p><p>获取当前指针位置</p><p>void seek(long pos)</p><p>使用该方法可以移动指针到指定位置</p><p>int skipBytes(int n)</p><p>跳过输入的 n 个字节以丢弃跳过的字节</p><hr><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>我们编写的程序除了自身会定义一些数据信息外，经常还会引用外界的数据，或是将自身的数据发送到外界。</p><p>相对程序来讲：</p><p>输入是用来读取数据的；</p><p>输出是用来写出数据的；</p><p>按照流是否直接与特定的地方(如磁盘、内存、设备等)相连，分为节点流和处理流两类。</p><p>节点流：可以从或向一个特定的地方（节点）读写数据。</p><p>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。</p><p>处理流的构造方法总是要带一个其他的流对象做参数。</p><p>一个流对象经过其他流的多次包装，称为流的链接。</p><p>InputStream是所有字节输入流的父类</p><p>int read()</p><p>int read(byte[] d)</p><p>OutputStream是所有字节输出流的父类</p><p>void write(int d)</p><p>void write(byte[] d)</p><p>FileOutputStream是文件的字节输出流，继承自OutputStream</p><p>创建FOS对象(重写模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIle file = <span class="keyword">new</span> File(<span class="string">"demo.dat"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br></pre></td></tr></table></figure><p>若指定的文件已经包含内容，那么当使用FOS对其写入数据时，会将该文件中原有数据全部清除。</p><p>创建FOS对象(追加模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"demo.dat"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>第二个参数若为true,那么通过该FOS写出的数据都是在文件末尾追加的。</p><p>FileInputStream是文件的字节输入流，继承自InputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"demo.dat"</span>);</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);<span class="comment">//创建一个用于读取demo.dat文件的输入流</span></span><br></pre></td></tr></table></figure><h4 id="批量读写字节到文件"><a href="#批量读写字节到文件" class="headerlink" title="批量读写字节到文件"></a>批量读写字节到文件</h4><p>int read(byte[] b)</p><p>void write(byte[] d)</p><p>void write(byte[] d,int offset,int len)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="string">"HelloWorld"</span>.getBytes();</span><br><span class="line">fos.write(data);<span class="comment">//会将HelloWorld的所有字节写入文件。</span></span><br></pre></td></tr></table></figure><h4 id="BOS缓冲输出流"><a href="#BOS缓冲输出流" class="headerlink" title="BOS缓冲输出流"></a>BOS缓冲输出流</h4><p>一次性批量写出若干数据减少写出次数来提高写出效率。</p><p>BufferedOutputStream缓冲输出流内部维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(&quot;demo.dat&quot;);</span><br><span class="line">//创建缓冲字节输出流</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br><span class="line">//所有字节被存入缓冲区，等待一次性写出    </span><br><span class="line">bos.write(&quot;helloworld&quot;.getBytes());    </span><br><span class="line">//关闭流之前，缓冲输出流会将缓冲区内容一次性写出    </span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><p>void flush()</p><p>清空缓冲区，将缓冲区中的数据强制写出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bos.flush();</span><br></pre></td></tr></table></figure><h4 id="BIS缓冲字节输入流"><a href="#BIS缓冲字节输入流" class="headerlink" title="BIS缓冲字节输入流"></a>BIS缓冲字节输入流</h4><p>BufferedInputStream——其内部维护着一个缓冲区(字节数组)，使用该流在读取一个字节时，该流会尽可能多的一次性读取若干字节并存入缓冲区，然后逐一的将字节返回，直到缓冲区中的数据被全部读取完毕，会再次读取若干字节从而反复。这样就减少了读取的次数，从而提高了读取效率。</p><p>BIS是一个处理流，该流为我们提供了缓冲功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"java.zip"</span>);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy_java.zip"</span>);</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"><span class="keyword">int</span> d = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((d = bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    bos.write(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bis.close();//读写完毕后要关闭流，只需要关闭最外层的流即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bos.close();</span><br></pre></td></tr></table></figure><p>对象序列化：将对象转换为一个字节序列</p><p>对象的反序列化</p><p>作用：将对象保存在硬盘上或传输到另一台计算机上</p><p>ObjectOutputStream是用来对对象进行序列化的输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Emp emp = <span class="keyword">new</span> Emp(<span class="string">"张三"</span>,<span class="number">12</span>，<span class="string">"男"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"Emp.obj"</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(emp);<span class="comment">//将emp对象序列化后写入文件</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure><p>ObjectInputStream是用来对对象进行反序列化的输入流。</p><p>从流中读取字节并转换为对应的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"Emp.obj"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Emp emp = (Emp)ois.readObject();<span class="comment">//将Emp对象从文件中读取并反序列</span></span><br><span class="line">....</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>ObjectOutputStream在对对象进行序列化时有一个要求，就是需要序列化的对象所属的类必须实现Serializable接口。</p><p>只是作为可序列化的标志。</p><p>通常实现该接口的类需要提供一个常量serialVersionUID，表明该类的版本。</p><p>若向跨平台，都应显示的声明版本号。</p><p>关键字 transient——被该关键字修饰的属性在序列化时其值将被忽略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;<span class="comment">//该属性在序列化时会被忽略</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="comment">//getter and setter and other</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>Reader是所有字符输入流的父类，</p><p>Writer是所有字符输出流的父类。</p><p>字符流是以字符(char)为单位读写数据的，一次处理一个unicode。</p><p>字符流都是高级流</p><p>底层是依靠字节流进行读写数据的，所以底层仍然是基于字节读写数据的。</p><p>Reader</p><p>int read()——读取一个字符，返回的int值”低16”位有效。</p><p>int read(char[] chs)——存入该数组，返回值为实际读取到的字符量</p><p>Writer</p><p>void write(int c)——写出给定int值”低16”位表示的字符</p><p>void write(char[] chs)——将给定字符数组中所有字符写出</p><p>void write(String str)——将给定的字符串写出</p><p>void write(char[] chs,int offset,int len)——将给定的字符数组中从offset处开始连续的len个字符写出</p><h4 id="字符转换流"><a href="#字符转换流" class="headerlink" title="字符转换流"></a>字符转换流</h4><p>InputStreamReader：字符输入流， 使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。</p><p>OutputStreamWriter:字符输出流，使用该流可以设置字符集，并按照指定的字符集将字符转换为对应字节后通过该流写出。</p><p>ISR</p><p>InputStreamReader(InputStream in,String charsetName)</p><p>OSW</p><p>OutputStreamWriter(OutputStream out,String charsetName)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"demo.txt"</span>);    </span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"UTF-8"</span>);<span class="comment">//这里使用的字符编码为UTF-8</span></span><br><span class="line">String str = <span class="string">"大家好!"</span>;<span class="comment">//UTF-8中文为3个字节，英文符号占1个字节</span></span><br><span class="line">writer.write(str);<span class="comment">//写出后该文件大小应该为10字节</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  这里设置了字符编码为GBK    </span></span><br><span class="line"><span class="comment">*  之后再通过ISR读取demo.txt文件时    </span></span><br><span class="line"><span class="comment">*  就使用GBK编码读取字符了    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">"GBK"</span>);</span><br><span class="line"><span class="keyword">int</span> c = -<span class="number">1</span>;    </span><br><span class="line"><span class="keyword">while</span>((c = reader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure><h4 id="PrintWriter-BufferedReader"><a href="#PrintWriter-BufferedReader" class="headerlink" title="PrintWriter/BufferedReader"></a>PrintWriter/BufferedReader</h4><p>PrintWriter是具有自动行刷新的缓冲该字符输出流。</p><p>PrintWriter(File file)</p><p>PrintWriter(String fileName)</p><p>PrintWriter(OutputStream out)</p><p>PrintWriter(OutputStream out,boolean autoFlush)</p><p>PrintWriter(Writer writer)</p><p>PrintWriter(Writer writer,boolean autoFlush)</p><p>boolean autoFlush该参数用于表示PrintWriter是否具有自动行刷新</p><p>使用PrintWriter写出字符串时使用print和println等方法</p><p>使用PW输出字符数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"UTF-8"</span>);<span class="comment">//创建带有自动行刷新的</span></span><br><span class="line">PWPrintWriter pw = <span class="keyword">new</span> PrintWriter(osw,<span class="keyword">true</span>);</span><br><span class="line">pw.println(<span class="string">"大家好!"</span>);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure><p>BufferedReader是缓冲字符输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br></pre></td></tr></table></figure><p>当我们想基于一个字节流进行读取时，要先将字节流转换为字符流后方可创建缓冲字符输入流BufferedReader。</p><p>String readLine()——读取一行字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"demo.txt"</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><hr><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>Java异常结构中定义有Throwable类，</p><p>Exceotion和Error是其派生的两个子类。</p><p>Exception表示由于网络故障、文件损坏、设备错误、用户输入非法等情况导致的异常，这类异常是可以通过Java异常捕获机制处理的。</p><p>Error表示Java运行时环境出现的错误，例如:JVM内存溢出等。</p><p>每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常。</p><p>catch捕获的异常类型由上至下的捕获异常类型的顺序应是子类到父类的。</p><p>finally语句块只能定义在try语句块之后，或者最后一个catch语句块之后，且只能定义一次。</p><p>若想要自行抛出异常，可以使用“throw”关键词，并生成指定的异常对象。</p><p>throw new ArithmeticException();</p><p>使用“throws”关键词来声明这个方法将会抛出异常，让调用它的方法来统一处理。</p><p>public static void stringToDate(String str) throws  ParseException{…}</p><p><strong>重写方法时的throws</strong></p><p>当使用继承时，在父类的某个方法上声明了throws抛出某些异常，而在子类中重写该方法时，我们可以做以下的操作:</p><p>不处理异常（重写方法时不声明throws） </p><p>可仅在throws中声明父类中声明的部分异常 </p><p>可在throws中声明父类方法中抛出的异常的子类异常</p><p>但是不能做以下操作：</p><p>重写方法时在throws中声明抛出额外的异常 </p><p>重写方法时在throws中声明父类方法中声明的抛出异常的父类异常 </p><p>Java异常可以分为可检测异常，非检测异常：</p><p>可检测异常：可检测异常经编译器验证，对于声明抛出异常的任何方法，编译器将强制执行处理或声明规则，不捕捉这个异常，编译器就通不过，不允许编译</p><p>非检测异常：非检测异常不遵循处理或者声明规则。在产生此类异常时，不一定非要采取任何适当操作，编译器不会检查是否已经解决了这样一个异常</p><p>RuntimeException 类属于非检测异常，常见RuntimeException：</p><blockquote><p>IllegalArgumentException</p><p>抛出的异常表明向方法传递了一个不合法或不正确的参数</p><p>NullPointerException</p><p>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p><p>ArrayIndexOutOfBoundsException</p><p>当使用的数组下标超出数组允许范围时，抛出该异常</p><p>ClassCastException</p><p>当试图将对象强制转换为不是实例的子类时，抛出该异常</p><p>NumberFormatException</p><p>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</p></blockquote><p>e.printStackTrace();//输出执行堆栈信息</p><p>System.out.println(e.getMessage());//有关异常事件的信息</p><p>Throwable getCause() 获取该异常出现的原因</p><p><strong>自定义异常</strong></p><p>1.声明一个类并继承自Exception </p><p>2.右键点击Source </p><p>3.选择Generate Constructors from Superclass </p><p>4.选中父类中所有构造方法后确认生成 </p><hr><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>进程（process）就是一块包含了某些资源的内存区域，一个进程是一个应用程序。</p><p>进程中所包含的一个或多个执行单元称为线程（thread）。</p><p>线程只能归属于一个进程并且它只能访问该进程所拥有的资源。</p><p>一个线程是进程的一个顺序执行流</p><p>线程也被称为轻负荷进程（切换负荷小）。</p><p>一个进程中可以包含多个线程。</p><p>线程通常用于在一个程序中需要同时完成多个任务的情况。</p><p>进程和线程是并发运行的，OS的线程调度机制将时间划分为很多时间片段（时间片），尽可能均匀分配给正在运行的程序，获取CPU时间片的线程或进程得以被执行，其他则等待。而CPU则在这些进程或线程上来回切换运行。微观上所有进程和线程是走走停停的，宏观上都在运行，这种都运行的现象叫并发。</p><p><strong>线程生命周期</strong></p><p>New：当我们创建一个线程时，该线程并没有纳入线程调度，其处于一个new状态。</p><p>Runnable:当调用线程的start方法后，该线程纳入线程调度的控制，其处于一个可运行状态，等待分配时间片段以并发运行。</p><p>Running:当该线程被分配到了时间片段后其被CPU运行，这是该线程处于running状态。</p><p>Blocked:当线程在运行过程中可能会出现阻塞现象，比如等待用户输入信息等。但阻塞状态不是百分百出现的，具体要看代码中是否有相关需求。</p><p>Dead:当线程的任务全部运行完毕，或在运行过程中抛出了一个未捕获的异常，那么线程结束，等待GC回收</p><p><strong>使用Thread创建线并启动线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread thread = <span class="keyword">new</span> TestThread();<span class="comment">//实例化线程</span></span><br><span class="line">thread.start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure><p><strong>使用Runnable创建并启动线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> TestRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);<span class="comment">//实例化线程并传入线程体</span></span><br><span class="line">thread.start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure><p><strong>使用内部类创建线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p><strong>获取运行当前代码片段的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread current = Thread.currentThread();</span><br></pre></td></tr></table></figure><p><strong>获取线程信息</strong></p><table><thead><tr><th>返回值类型</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>long</td><td>getId()</td><td>返回该线程的标识符</td></tr><tr><td>String</td><td>getName()</td><td>返回该线程的名称</td></tr><tr><td>int</td><td>getPriority()</td><td>返回线程的优先级</td></tr><tr><td>Thread.state</td><td>getState()</td><td>获取线程的状态</td></tr><tr><td>boolean</td><td>isAlive()</td><td>测试线程是否处于活动状态</td></tr><tr><td>boolean</td><td>isDaemon()</td><td>测试线程是否为守护线程</td></tr><tr><td>boolean</td><td>isInterrupted()</td><td>测试线程是否已经中断</td></tr></tbody></table><p><strong>线程优先级</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> priority)</span> <span class="comment">//1-10，1最低，10最高</span></span></span><br><span class="line"><span class="function">Thread.MIN_PRIORITY</span></span><br><span class="line"><span class="function">Thread.MAX_PRIORITY</span></span><br><span class="line"><span class="function">Thread.NORM_PRIORITY</span></span><br></pre></td></tr></table></figure><p><strong>守护线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span>)</span></span></span><br></pre></td></tr></table></figure><p>当参数为true时该线程为守护线程。</p><p>守护线程的特点是，当进程中只剩下守护线程时，所有守护线程强制终止。</p><p>GC就是运行在一个守护线程上的。</p><p>需要注意的是，设置线程为后台线程要在该线程启动前设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemonThread = <span class="keyword">new</span> Thread();</span><br><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure><p>Thread的静态方法sleep用于使当前线程进入阻塞状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> ms)</span></span></span><br></pre></td></tr></table></figure><p>该方法会使当前线程进入阻塞状态指定毫秒，当指定毫秒阻塞后，当前线程会重新进入Runnable状态，等待分配时间片。</p><p>该方法声明抛出一个InterruptException，所以在使用该方法时需要捕获这个异常。</p><p>Thread的静态方法yield：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>该方法用于使当前线程主动让出当次CPU时间片回到Runnable状态，等待分配时间片。</p><p>join()用于等待当前线程结束。此方法是一个阻塞方法。</p><p>该方法声明抛出InterruptException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//一些耗时的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();<span class="comment">//这里t2线程会开始阻塞，直到t1线程的run方法执行完毕</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以下是当前线程的任务代码,只有t1线程运行完毕才会运行。            </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果条件不满足，则等待。当条件满足时，等待该条件的线程将被唤醒。</p><p>在Java中，这个机制的实现依赖于wait/notify。</p><p>等待机制与锁机制是密切关联的。</p><p>常见的临界资源:</p><ul><li><p>多线程共享实例变量 </p></li><li><p>多线程共享静态公共变量</p></li><li><p>多个线程并发读写同一个临界资源时候会发生”线程并发安全问题”</p></li></ul><p>所谓异步操作是指多线程并发的操作，相当于各干各的。</p><p>所谓同步操作是指有先后顺序的操作，相当于你干完我再干。</p><p>java中有一个关键字名为:synchronized，</p><p>该关键字是同步锁，用于将某段代码变为同步操作，</p><p>从而解决线程并发安全问题。</p><p>若方法所有代码都需要同步也可以给方法直接加锁。</p><p>获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。</p><p>多个需要同步的线程在访问该同步块时，看到的应该是同一个锁对象引用。</p><p>静态方法锁，该方法锁的对象是类对象</p><p>获取类对象的方式:类名.class</p><p>静态方法与非静态方法同时声明了synchronized，他们之间是非互斥关系的。原因在于，静态方法锁的是类对象而非静态方法锁的是当前方法所属对象。</p><p>StringBuffer 是同步的 synchronized append();</p><p>StringBuilder 不是同步的 append();</p><p>Vector 和 Hashtable 是线程安全的，ArrayList 和 HashMap则不是线程安全的。</p><p>将集合或Map转换为线程安全的：</p><p>Collections.synchronizedList():获取线程安全的List集合</p><p>Collections.synchronizedMap():获取线程安全的Map</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>首先创建一些线程，它们的集合称为线程池，</p><p>当服务器收到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，</p><p>服务完后不关闭该线程，而是将该线程还回到线程池中。</p><p>使用线程池来解决问题：</p><p>创建大量线程，并在任务结束后销毁，给系统带来过度消耗资源；</p><p>过度切换线程的危险，可能导致系统崩溃。</p><p>线程池的作用：</p><ul><li>控制线程数量；</li><li>重用线程；</li></ul><p>在线程池的编程模式下，任务是提交给整个线程池，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务</p><p>ExecutorService是java提供的用于管理线程池的类。</p><p>实现策略：</p><p>Executors.newCachedThreadPool()</p><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</p><p>Executors.newFixedThreadPool(int nThreads)</p><p>创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程。</p><p>Excutors.newScheduledThreadPool(int corePoolSize)</p><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p><p>Executors.newSingleThreadExecutor()</p><p>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">30</span>);<span class="comment">//创建具有30个线程的线程池</span></span><br><span class="line">Runnable r1 = <span class="keyword">new</span> Runable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//线程体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">threadPool.execute(r1);<span class="comment">//将任务交给线程池，其会分配空闲线程来运行这个任务。</span></span><br></pre></td></tr></table></figure><p>BlockingQueue是双缓冲队列</p><p>BlockingQueue内部使用两条队列，可允许两个线程同时向队列一个做存储，一个做取出操作。在保证并发安全的同时提高了队列的存取效率。</p><p>ArrayBlockingDeque</p><p>规定大小的BlockingDeque,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。</p><p>LinkedBlockingDeque</p><p>大小不定的BlockingDeque,若其构造函数带一个规定大小的参数,生成的BlockingDeque有大小限制,若不带大小参数,所生成的BlockingDeque的大小由Integer.MAX_VALUE来决定.其所含的对象是以FIFO(先入先出)顺序排序的。</p><p>PriorityBlockingDeque</p><p>类似于LinkedBlockDeque,但其所含对象的排序不是FIFO,而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序。</p><p>SynchronousQueue</p><p>特殊的BlockingQueue,对其的操作必须是放和取交替完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//queue.offer("A");//立即向队列末尾追加元素                       </span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 向队列末尾追加元素，指定可延迟5秒。</span></span><br><span class="line"><span class="comment">         * 若5秒钟内成功将元素加入队列返回true</span></span><br><span class="line"><span class="comment">         * 若超时后元素仍然没有加入队列则返回flase</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue.offer(<span class="string">"A"</span>,<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>socket通常称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。</p><p>每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。</p><p>ServerSocket用于服务端，Socket是建立网络连接时使用的。</p><p>在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。</p><p>获取本地地址和端口号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSocket</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8088</span>);</span><br><span class="line">    InetAddress add = socket.getLocalAddress();<span class="comment">//获取本地地址信息</span></span><br><span class="line">    System.out.println(add.getCanonicalHostName());<span class="comment">//获取此 IP 地址的完全限定域名</span></span><br><span class="line">    System.out.println(add.getHostAddress());<span class="comment">//返回 IP 地址字符串（以文本表现形式）</span></span><br><span class="line">    System.out.println(socket.getLocalPort());<span class="comment">//获取本地使用的端口号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取远端地址和端口号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSocket</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8088</span>);</span><br><span class="line">    InetAddress inetAdd = socket.getInetAddress();<span class="comment">//获取套接字绑定的远端地址</span></span><br><span class="line">    System.out.println(inetAdd.getCanonicalHostName());</span><br><span class="line">    System.out.println(inetAdd.getHostAddress());</span><br><span class="line">    System.out.println(socket.getPort());<span class="comment">//获取远端使用的端口号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取网络输入流和网络输出流</p><p>封装了TCP协议的Socket是基于流进行通讯的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSocket</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8088</span>);</span><br><span class="line">    InputStream in = socket.getInputStream();<span class="comment">//返回此套接字的输入流</span></span><br><span class="line">    OutputStream out = socket.getOutputStream();<span class="comment">//返回此套接字的输出流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用Socket进行通讯完毕后，要关闭Socket以释放系统资源</p><p>void close()</p><p>当关闭了该套接字后也会同时关闭由此获取的输入流与输出流。</p><p><strong>Server端ServerSocket监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ServerSocket并申请服务端口8088</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8088</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*方法会产生阻塞，直到某个Socket连接,并返回请求连接的Socket*/</span></span><br><span class="line">Socket socket = server.accept();</span><br></pre></td></tr></table></figure><p>该方法是一个阻塞方法，直到一个客户端通过Socket连接后，accept会封装一个Socket，该Socket封装与表示该客户端的有关的信息。通过这个Socket与该客户端进行通信。</p><p><strong>Client端Socket连接</strong></p><p>创建Socket的同时就发起连接，若连接异常会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1：服务端的IP地址，参数2:服务端的服务端口</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(“localhost”,<span class="number">8088</span>);</span><br></pre></td></tr></table></figure><p><strong>C-S端通信模型</strong></p><blockquote><p>1.服务端创建ServerSocket </p><p>2.通过调用ServerSocket的accept方法监听客户端的连接 </p><p>3.客户端创建Socket并指定服务端的地址以及端口来建立与服务端的连接 </p><p>4.当服务端accept发现客户端连接后，获取对应该客户端的Socket </p><p>5.双方通过Socket分别获取对应的输入与输出流进行数据通讯 </p><p>6.通讯结束后关闭连接。</p></blockquote><p>Server端多线程模型</p><p>一个服务端可以同时支持多个客户端</p><p>创建一个线程类ClientHandler</p><h4 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h4><p>DatagramPacket：UDP数据报基于IP建立的,每台主机有65536个端口号可以使用。数据报中字节数限制为65536-8 。包含8字节的头信息。</p><p><strong>创建接收包</strong></p><p>DatagramPacket(byte[] buf, int length)</p><p>将数据包中Length长的数据装进Buf数组。</p><p>DatagramPacket(byte[] buf, int offset, int length) </p><p>将数据包中从Offset开始、Length长的数据装进Buf数组。</p><p><strong>创建发送包</strong></p><p>DatagramPacket(byte[] buf, int length, InetAddress clientAddress, int clientPort)</p><p>从Buf数组中，取出Length长的数据创建数据包对象，目标是clientAddress地址，clientPort端口,通常用来发送数据给客户端。</p><p>DatagramPacket(byte[] buf, int offset, int length, InetAddress clientAddress, int clientPort)</p><p>从Buf数组中，取出Offset开始的、Length长的数据创建数据包对象，目标是clientAddress地址，clientPort端口，通常用来发送数据给客户端。</p><p>DatagramSocket 用于接收和发送UDP的Socket实例 。</p><p><strong>服务端接收</strong></p><p>DatagramSocket(int port)</p><p>创建实例，并固定监听Port端口的报文。通常用于服务端。</p><p>receive(DatagramPacket d)</p><p>接收数据报文到d中。receive方法产生 “阻塞”。会一直等待知道有数据被读取到。</p><p><strong>客户端发送</strong></p><p>无参的构造方法DatagramSocket()通常用于客户端编程，它并没有特定监听的端口，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。</p><p>send(DatagramPacket dp)</p><p>该方法用于发送报文dp到目的地。</p><hr><h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>XPath 是一门在 XML 文档中查找信息的语言。</p><p>斜杠（/）作为路径内部的分割符。</p><p>同一个节点有绝对路径和相对路径两种写法: </p><p>​    绝对路径（absolute path）必须用”/“起首，后面紧跟根节点，比如/step/step/…。 </p><p>​    相对路径（relative path）则是除了绝对路径以外的其他写法，比如 step/step， 也就是不使用”/“起首。 </p><blockquote><p>“.”表示当前节点。 </p><p>“..”表示当前节点的父节点 </p><p>nodename（节点名称）：表示选择该节点的所有子节点 </p><p>“/“：表示选择根节点 </p><p>“//“：表示选择任意位置的某个节点 </p><p>“@”： 表示选择某个属性 </p></blockquote><p>“谓语条件”，就是对路径表达式的附加条件。所有的条件，都写在方括号”[]”中，表示对节点进行进一步的筛选。</p><blockquote><p>/book[1]</p><p>/book[last]</p><p>//title[@lang=’eng’]</p><p>/book[price]</p></blockquote><p>通配符:</p><blockquote><p>“*”表示匹配任何元素节点。 </p><p>“@*”表示匹配任何属性值。 </p><p>node()表示匹配任何类型的节点。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Linux常用命令：&quot;&gt;&lt;a href=&quot;#Linux常用命令：&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令：&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux常用命令&lt;/strong&gt;：&lt;/h4&gt;&lt;p&gt;​    pwd：用于显示当前工作目录。&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://gnbyj.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://gnbyj.cn/tags/Java/"/>
    
      <category term="JavaSE" scheme="http://gnbyj.cn/tags/JavaSE/"/>
    
      <category term="IO" scheme="http://gnbyj.cn/tags/IO/"/>
    
      <category term="Thread" scheme="http://gnbyj.cn/tags/Thread/"/>
    
      <category term="数据结构" scheme="http://gnbyj.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 整合 MyBatis</title>
    <link href="http://gnbyj.cn/2018/07/12/Spring%20Boot/SpringBoot%20%E6%95%B4%E5%90%88MyBatis/"/>
    <id>http://gnbyj.cn/2018/07/12/Spring Boot/SpringBoot 整合MyBatis/</id>
    <published>2018-07-12T09:10:00.000Z</published>
    <updated>2018-07-12T09:13:20.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据准备"><a href="#一、数据准备" class="headerlink" title="一、数据准备"></a>一、数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_user`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'ID'</span>,</span><br><span class="line">    <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">    <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">    <span class="string">`ctm`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`db_test`</span>.<span class="string">`tb_user`</span> (<span class="string">`username`</span>, <span class="string">`age`</span>, <span class="string">`ctm`</span>) <span class="keyword">VALUES</span>(<span class="string">'张三'</span>, <span class="string">'18'</span>, <span class="keyword">NOW</span>()) ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`db_test`</span>.<span class="string">`tb_user`</span> (<span class="string">`username`</span>, <span class="string">`age`</span>, <span class="string">`ctm`</span>) <span class="keyword">VALUES</span>(<span class="string">'李四'</span>, <span class="string">'20'</span>, <span class="keyword">NOW</span>()) ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`db_test`</span>.<span class="string">`tb_user`</span> (<span class="string">`username`</span>, <span class="string">`age`</span>, <span class="string">`ctm`</span>) <span class="keyword">VALUES</span>(<span class="string">'王五'</span>, <span class="string">'19'</span>, <span class="keyword">NOW</span>()) ;</span><br></pre></td></tr></table></figure><h3 id="二、引入依赖"><a href="#二、引入依赖" class="headerlink" title="二、引入依赖"></a>二、引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring-Mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MySQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外web依赖也需要，因为我们采用MVC模式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Add typical dependencies for a web application --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、数据库配置文件"><a href="#三、数据库配置文件" class="headerlink" title="三、数据库配置文件"></a>三、数据库配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    datasource:</span></span><br><span class="line"><span class="attr">        driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">jdbc:mysql://localhost:3306/db_user</span></span><br><span class="line"><span class="attr">        username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">        password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><h3 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h3><p>最开始使用mybati比较麻烦，各种配置文件、实体类、dao层映射关联、还有一大推其它配置。当然mybatis也发现了这种弊端，初期开发了generator可以根据表结果自动生产实体类、配置文件和dao层代码，可以减轻一部分开发量；后期也进行了大量的优化可以使用注解了。</p><p>于是两种使用方式都介绍一下，一、无配置注解版 二、配置文件版</p><h4 id="1-无配置文件注解版"><a href="#1-无配置文件注解版" class="headerlink" title="1.无配置文件注解版"></a>1.无配置文件注解版</h4><p>加入配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">    type-aliases-package:</span> <span class="string">cn.saytime.bean</span></span><br></pre></td></tr></table></figure><p>实体类User.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saytime.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> cn.saytime.bean.User</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-07-04 22:47:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date ctm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.ctm = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Getter、Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saytime.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.saytime.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Mapper 这里可以使用@Mapper注解，但是每个mapper都加注解比较麻烦，所以统一配置@MapperScan在扫描路径在application类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM tb_user WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM tb_user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into tb_user(username, age, ctm) values(#&#123;username&#125;, #&#123;age&#125;, now())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"UPDATE tb_user SET username = #&#123;user.username&#125; , age = #&#123;user.age&#125; WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"user"</span>)</span> User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"DELETE from tb_user where id = #&#123;id&#125; "</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Mybatis 注解使用 <a href="http://www.mybatis.org/mybatis-3/zh/java-api.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/java-api.html</a></p></blockquote><p>UserService.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saytime.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.saytime.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> cn.saytime.service.UserService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Integer id, User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceimpl.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saytime.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.saytime.bean.User;</span><br><span class="line"><span class="keyword">import</span> cn.saytime.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> cn.saytime.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> cn.saytime.service.impl.UserServiceImpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Integer id, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.update(id, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JsonResult.class 通用json返回类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saytime.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String status = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">status</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter Setter</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserController.class（Restful风格）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saytime.web;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> cn.saytime.bean.JsonResult;</span><br><span class="line"><span class="keyword">import</span> cn.saytime.bean.User;</span><br><span class="line"><span class="keyword">import</span> cn.saytime.service.UserService;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParams;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过这里配置使下面的映射都在/users下，可去除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gnkevin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 20180712</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;());</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"获取用户列表"</span>, notes=<span class="string">""</span>)</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=&#123;<span class="string">""</span>&#125;, method= RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JsonResult jr = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;User&gt; users = userService.getUserList();</span><br><span class="line">            jr.setResult(users);</span><br><span class="line">            jr.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            jr.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            jr.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(jr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"获取用户详细信息"</span>, notes=<span class="string">"根据url的id来获取用户详细信息"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"id"</span>, value = <span class="string">"用户ID"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"Long"</span>)</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getUserById</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        JsonResult jr = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user = userService.getUserById(id);</span><br><span class="line">            jr.setResult(user);</span><br><span class="line">            jr.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            jr.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            jr.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(jr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"创建用户"</span>, notes=<span class="string">"根据User对象创建用户"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"user"</span>, value = <span class="string">"用户详细实体user"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"User"</span>)</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">""</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">add</span> <span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> orderId = userService.add(user);</span><br><span class="line">            <span class="keyword">if</span> (orderId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                r.setResult(orderId);</span><br><span class="line">                r.setStatus(<span class="string">"fail"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.setResult(orderId);</span><br><span class="line">                r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id修改用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"更新用户详细信息"</span>, notes=<span class="string">"根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParams</span>(&#123;</span><br><span class="line">            <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"id"</span>, value = <span class="string">"用户ID"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"Long"</span>),</span><br><span class="line">            <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"user"</span>, value = <span class="string">"用户详细实体user"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"User"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.PUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">update</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id, @RequestBody User user)</span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = userService.update(id, user);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                r.setResult(ret);</span><br><span class="line">                r.setStatus(<span class="string">"fail"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.setResult(ret);</span><br><span class="line">                r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"删除用户"</span>, notes=<span class="string">"根据url的id来指定删除对象"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"id"</span>, value = <span class="string">"用户ID"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"Long"</span>)</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.DELETE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">delete</span> <span class="params">(@PathVariable(value = <span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = userService.delete(id);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                r.setResult(ret);</span><br><span class="line">                r.setStatus(<span class="string">"fail"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.setResult(ret);</span><br><span class="line">                r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Application.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saytime;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"cn.saytime.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootMybaitsApplication</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(SpringbootMybaitsApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PostMan通过测试。</p><h4 id="2-配置文件版"><a href="#2-配置文件版" class="headerlink" title="2.配置文件版"></a>2.配置文件版</h4><p>加入配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">    mapper-locations:</span> <span class="attr">classpath:mybatis/mapper/*.xml</span></span><br><span class="line"><span class="attr">    config-location:</span> <span class="attr">classpath:mybatis/mybatis-config.xml</span></span><br></pre></td></tr></table></figure><blockquote><p>代码部分，相比于上面那种方式，改变的只有配置文件以及下面几个部分。</p></blockquote><p>UserMapper.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saytime.mapper;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> cn.saytime.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> cn.saytime.mapper.UesrMapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"user"</span>)</span> User user)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>userMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.saytime.mapper.UserMapper"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.saytime.bean.User"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"ctm"</span> <span class="attr">property</span>=<span class="string">"ctm"</span> <span class="attr">jdbcType</span>=<span class="string">"TIMESTAMP"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span> &gt;</span></span><br><span class="line">        id, username, age, ctm</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserList"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>  &gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">        FROM tb_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> &gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">        FROM tb_user</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"add"</span> <span class="attr">parameterType</span>=<span class="string">"cn.saytime.bean.User"</span> &gt;</span></span><br><span class="line">        INSERT INTO</span><br><span class="line">        tb_user</span><br><span class="line">        (username,age,ctm)</span><br><span class="line">        VALUES</span><br><span class="line">        (#&#123;username&#125;, #&#123;age&#125;, now())</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.Map"</span> &gt;</span></span><br><span class="line">        UPDATE</span><br><span class="line">        tb_user</span><br><span class="line">        SET</span><br><span class="line">        username = #&#123;user.username&#125;,age = #&#123;user.age&#125;</span><br><span class="line">        WHERE</span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span> &gt;</span></span><br><span class="line">        DELETE FROM</span><br><span class="line">        tb_user</span><br><span class="line">        WHERE</span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这种方式也使用PostMan通过测试。</p><h3 id="五、简要说明"><a href="#五、简要说明" class="headerlink" title="五、简要说明"></a>五、简要说明</h3><p>不知道大家有没有注意到一点，就是引入Springboot-mybatis依赖的时候，并不是spring官方的starter，往常的springboot集成的依赖，比如web，redis等，groupId以及artifactId的地址如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而这里是mybatis为spring提供的starter依赖，所以依赖地址是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>而且值得注意的是，这里必须要指定版本号，往常我们使用springboot之所以不需要指定版本号，是因为我们引入的Maven Parent 中指定了SpringBoot的依赖，SpringBoot官方依赖Pom文件中已经指定了它自己集成的第三方依赖的版本号，对于Mybatis，Spring官方并没有提供自己的starter，所以必须跟正常的maven依赖一样，要加版本号。</p></blockquote><p>SpringBoot自己集成的starter依赖，可以查看 <a href="http://docs.spring.io/spring-boot/docs/1.5.4.RELEASE/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/1.5.4.RELEASE/reference/htmlsingle/#using-boot-starter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、数据准备&quot;&gt;&lt;a href=&quot;#一、数据准备&quot; class=&quot;headerlink&quot; title=&quot;一、数据准备&quot;&gt;&lt;/a&gt;一、数据准备&lt;/h3&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://gnbyj.cn/categories/Spring-Boot/"/>
    
    
      <category term="Mybatis" scheme="http://gnbyj.cn/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>解决端口被占用问题</title>
    <link href="http://gnbyj.cn/2018/07/12/%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98/%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E9%97%AE%E9%A2%98/"/>
    <id>http://gnbyj.cn/2018/07/12/程序问题/端口被占问题/</id>
    <published>2018-07-12T09:00:00.000Z</published>
    <updated>2018-07-12T09:12:35.793Z</updated>
    
    <content type="html"><![CDATA[<ol><li>开始—-&gt;运行—-&gt;cmd，或者是window+R组合键，调出命令窗口；</li><li><p>输入命令：<code>netstat -ano</code>，列出所有端口的情况。在列表中我们观察被占用的端口，比如是49157，首先找到它；</p></li><li><p>查看被占用端口对应的PID，输入命令：<code>netstat -aon|findstr &quot;49157&quot;</code>，回车，记下最后一位数字，即PID，这里是2720；</p></li><li><p>继续输入<code>tasklist|findstr &quot;2720&quot;</code>，回车，查看是哪个进程或者程序占用了2720端口，结果是：svchost.exe；</p></li><li><p>或者是我们打开任务管理器，切换到进程选项卡，在PID一列查看2720对应的进程是谁；</p></li><li>如果看不到PID这一列，则我们点击查看—&gt;选择列，将PID(进程标示符)前面的勾打上，点击确定；</li><li><p>这样我们就看到了PID这一列标识，看一下2720对应的进程是谁，如果没有，我们把下面的显示所有用户的进程前面的勾打上，就可以看到了，映像名称是svchost.exe，描述是，Windows的主进程,与上面命令查看的完全一致；</p></li><li><p>结束该进程：在任务管理器中选中该进程点击”结束进程“按钮，或者是在cmd的命令窗口中输入：<code>taskkill /f /t /im Tencentdl.exe</code>。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano|findstr <span class="string">"port"</span></span><br><span class="line">tasklist|findstr <span class="string">"pid"</span></span><br><span class="line">taskkill /f /t /im java.exe</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;开始—-&amp;gt;运行—-&amp;gt;cmd，或者是window+R组合键，调出命令窗口；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输入命令：&lt;code&gt;netstat -ano&lt;/code&gt;，列出所有端口的情况。在列表中我们观察被占用的端口，比如是49157，首先找到它；&lt;/p&gt;

      
    
    </summary>
    
      <category term="问题集" scheme="http://gnbyj.cn/categories/%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="端口被占用" scheme="http://gnbyj.cn/tags/%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>精力管理</title>
    <link href="http://gnbyj.cn/2018/07/07/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/%E7%B2%BE%E5%8A%9B%E7%AE%A1%E7%90%86/"/>
    <id>http://gnbyj.cn/2018/07/07/自我管理/精力管理/</id>
    <published>2018-07-07T08:00:00.000Z</published>
    <updated>2018-07-07T08:00:47.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分-如何做到全情投入"><a href="#第一部分-如何做到全情投入" class="headerlink" title="第一部分 如何做到全情投入"></a>第一部分 如何做到全情投入</h2><h3 id="第一章-什么是精力及如何管理精力"><a href="#第一章-什么是精力及如何管理精力" class="headerlink" title="第一章 什么是精力及如何管理精力"></a>第一章 什么是精力及如何管理精力</h3><p>精力就是做事情的能力。包括体能、情感、思维、意志四个方面。</p><p>如果精力运用不恰当，一切事情的效果都会大打折扣。例如你今天参加了一场长达4小时的会议，虽然会议从头到尾没有一句废话，但是刚到下半场你的注意力就急剧下降，连理解语句都变得非常困难。</p><blockquote><p>管理精力，而非时间，才是是高效表现的基础。</p><p>fully engaged: energy, not time, is our most precious resource</p></blockquote><p>面临的问题：</p><ul><li>我们生活在数字时代，节奏如电光火石般迅猛，似乎永不间断，时间被打碎成了比特和字节；</li><li>我们对广度的热爱超过了对深度的关注，注重反应速度却不愿深入思考；</li><li>我们流连于事物的表象，满足浅尝辄止的片刻欢愉，却几乎从不久留；</li><li>我们在人生的道路上争先恐后，却吝于用片刻思考目标或方向；</li><li>我们事务缠身，却又总是筋疲力尽；</li></ul><p>时间永远不够用，我们的唯一办法只有在每一天里最大程度地生挤硬塞。然而新的问题出现了，<strong>再高效的时间管理也无法确保我们有足够的精力处理每一件事</strong>。</p><blockquote><p>有技巧的精力管理是高度表现、健康和幸福的基础</p></blockquote><ul><li>如果明天早晨你醒来的时候，带着对工作和家人的积极、专注的精力，你的状态会有多大程度改善？</li><li>如果你是领导或经理，积极的精力和激情将会给公司环境精力带来多大的价值？</li><li>如果员工们拥有更多的积极精力，同事关系、客户服务质量又会有多大的提升？</li></ul><p><strong>领导是组织精力的统筹人，在公司、机构及家庭中均是如此。要想树立威信，首先要依靠个人精力管理，然后才是调动、集中、投入和发展团队集体的精力。依靠对个人和团体的有效精力管理，我们才能实现全情投入。</strong></p><p>全情投入需要身体活跃、情感联动、思维集中，并且达到超出个人短期利益的意志高度。</p><h4 id="精力管理的四个基本原则"><a href="#精力管理的四个基本原则" class="headerlink" title="精力管理的四个基本原则"></a>精力管理的四个基本原则</h4><p>是什么让运动员在高强度竞争压力下保持高水准的表现？精力！</p><p>专业运动员通常90%的时间都在训练，为了在剩余10%时间里取得结果。他们的生活围绕着增强、保持和恢复精力的主题，为短期的高强度竞技做准备。以实用为出发点，他们精确规划的日常作息也为各方面的精力管理设定了严格的程序——吃饭睡觉，训练休息，情绪控制，心理准备，保持专注，定期自查目标完成情况，等等。</p><p>优秀表现的难度在于，它需要从各个方面更有效地管理精力，达到最终目标。这个过程由四条关键的精力管理法则驱动：</p><p>原则一：全情投入需要调动四种独立且相关联的精力源：体能，情感，思维和意志</p><p>原则二：因为使用过度和使用不足都会削弱精力，必须不时更新精力以平衡消耗</p><blockquote><p>最丰富、最快乐和最高产的生命的共通之处，是全情应对眼前的挑战，同时能够间断地放松，留给精力再生的空间。</p><p>我们必须学会将自己的生活看作一系列短跑冲刺，在某些时间段全情投入，在另外一些时间段闲云野鹤，更新精力储备，以应对下一个挑战。</p></blockquote><p>原则三：为了提高能力，我们必须突破自己的惯常极限，学会模仿运动员进行系统训练。</p><blockquote><p>压力并非是我们生活中的敌人，相反，它是我们成长的关键。</p><p>通过突破极限和休整恢复，我们可以在各个方面获得成长。</p><p>任何会导致不适的压力都可能帮助我们提升能力——在体能、思维、情感和意志上都是如此——只要事后得到有效的恢复。</p><p>尼采说过的：“打不倒我们的会让我们变得更强。”对“公司运动员”的要求比对专业运动员的更高，时间也更长，因此他们更有必要学会系统地训练自己。</p></blockquote><p>原则四：积极的精力仪式习惯，即细致具体的精力管理方法，是全情投入、保持高效表现的诀窍。</p><blockquote><p>“仪式习惯”指的是定义明确、具有高度计划性的行为。比如刷牙。</p><p>仪式习惯的优势在于，确保我们在非必要情况下尽量减少意识精力的消耗，节省下来用在其他需要的方面。</p><p>逐渐成为自然的积极仪式习惯，扎根于我们的深层价值观。</p><p>为了确保全情投入，建立良好的仪式习惯是精力管理的最有效方式。</p></blockquote><h4 id="管理精力的三个步骤"><a href="#管理精力的三个步骤" class="headerlink" title="管理精力的三个步骤"></a>管理精力的三个步骤</h4><p>变革过程的第一步：明确目标</p><blockquote><p>如何依照我们最深层次的价值取向分配精力？</p><p>梳理人生中最重要的事情，并在人生和工作方面构建切合实际的愿景。</p></blockquote><p>变革的第二步：正视现实</p><blockquote><p>当前你的精力管理情况如何？制定变革的计划离不开对个人现状的清醒认知。</p><p>面对现实从可靠的数据收集开始，尽可能准确地评价他们管理体能、情感、思维和意志精力的方式。</p><ul><li>进行多项体能测试；</li><li>细致分析他们的饮食；</li><li>提供一份详尽的问卷；</li><li>请他们最亲近的5个人填写一份相似的问卷。</li></ul><p>这些数据让我们得以直观地衡量他们当下的能力，找出阻碍他们全情投入的罪魁祸首。</p></blockquote><p>变革的第三步：付诸行动</p><blockquote><p>用实际行动缩小“现实的我”与“理想的我”之间的差距。</p><p>建立以良好精力仪式习惯为基础的个人发展计划。</p><p>养成精力仪式习惯需要在具体时间发起明确的行动，由深层价值观驱动。</p></blockquote><blockquote><p>“我们每一个人都是由自己一再重复的行为所铸造的。”——亚里士多德</p></blockquote><h3 id="第二章-成功人士罗杰遇到的障碍"><a href="#第二章-成功人士罗杰遇到的障碍" class="headerlink" title="第二章 成功人士罗杰遇到的障碍"></a>第二章 成功人士罗杰遇到的障碍</h3><p>罗杰有5个基本障碍困扰着他：精力低下，焦躁，消极，人际关系淡薄，还缺乏激情。</p><p>透过表面看清客户的生活中实质发生了什么：</p><ul><li>“全情投入问卷”，一系列精心设计的问题构筑客户的行为模式，量化各方面精力的消耗及恢复情况。</li><li>简明用药史和完整的营养表，详尽记录了指定3天内的饮食情况。</li><li>数项体能测试，指标包括心血管容量、力量、灵活性、体脂比例以及血液生化指数，比如胆固醇水平。</li></ul><p>体能不足是罪魁祸首；情感账户告急；徒劳地强打精神；不知什么对自己最重要；</p><blockquote><p>生活中最能给他带来激情和满足的是什么？</p></blockquote><h3 id="第三章-高效表现有节奏——劳逸结合的平衡"><a href="#第三章-高效表现有节奏——劳逸结合的平衡" class="headerlink" title="第三章 高效表现有节奏——劳逸结合的平衡"></a>第三章 高效表现有节奏——劳逸结合的平衡</h3><p>生活已极其单线化——长时间工作，极少休息，即便在家里他也不停消耗自己的思想精力，从来不给自己恢复的时间。</p><p>疲倦带来焦虑、易怒和自我怀疑。</p><p>事实上，人需要顺应消耗与恢复的节奏，运动与休息的交替进行可以最大限度提高表现。</p><p>“张弛有度”是全情投入、维持机能和保持健康的关键。</p><h4 id="人类最基本的需求是精力的消耗与恢复"><a href="#人类最基本的需求是精力的消耗与恢复" class="headerlink" title="人类最基本的需求是精力的消耗与恢复"></a>人类最基本的需求是精力的消耗与恢复</h4><p>过度消耗而恢复不足最终将导致精力衰竭崩溃，恢复超出消耗则导致萎缩和衰弱。</p><p>情感的深度和适应力取决于外界交往的积极程度和内省习惯。</p><p>思维的敏锐度会因为缺乏思维挑战而减退。</p><p>意志精力依赖于不断温习深层价值取向，为自我行为负责。</p><p>全情投入需要在各个层面培养精力消耗（压力）和精力再生（恢复）的动态平衡。我们称之为有节奏的波动，它代表了生命的本质脉动，波动越强，我们越能够做到全情投入。</p><blockquote><p>鼓励人们适度休息的企业文化不仅能够提高员工的忠诚度，也会给组织带来更高的效率。</p></blockquote><p>20世纪50年代初，研究员阿瑟林斯基和克莱特曼发现，睡眠有90～120分钟的周期，从浅层睡眠——大脑活动频繁和做梦的阶段，到深度睡眠——大脑静止并深层修复。这个过程称作“活跃-休整基础循环”（BRAC）。</p><p>到了70年代，进一步的研究表明，大脑清醒状态下也存在同样的90～120分钟的周期，即次昼夜节律。</p><h4 id="利用碎片时间见缝插针地休息"><a href="#利用碎片时间见缝插针地休息" class="headerlink" title="利用碎片时间见缝插针地休息"></a>利用碎片时间见缝插针地休息</h4><p>学习短跑运动员，就是把生活拆分成一系列可以掌控的阶段，既满足生理需求，又符合自然规律。最佳选手们在比赛期间有固定的行为模式，包括得分后走回基线时头和肩膀如何摆正，视线看向哪里，呼吸模式，甚至自言自语的习惯等。</p><p>要点：</p><blockquote><p>精力的消耗与恢复是人类最基本的需求，我们称其为波动。</p><p>波动的反面是直线：精力消耗大于恢复，或者精力恢复大于消耗。</p><p>压力与恢复的平衡对于个人或团体的高效表现都至关重要。</p><p>我们必须在四个层面都保持健康波动的节奏，即“效能金字塔”的组成部分：体能，情感，思维和意志。</p><p>我们培养情感、思维和意志能力的方法与体力相同，必须系统性地将自己置于超出惯常极限的压力当中，并在过后得到充分恢复。</p><p>拓展能力需要为了长期回报接受短期的不适。 </p><p>能力拓展的关键在于，既要超出日常的极限，又要定期休整恢复，二者兼备才能成长。</p></blockquote><h2 id="第二部分-精力的四个来源"><a href="#第二部分-精力的四个来源" class="headerlink" title="第二部分 精力的四个来源"></a>第二部分 精力的四个来源</h2><h3 id="第四章-体能精力——为身体添柴加火"><a href="#第四章-体能精力——为身体添柴加火" class="headerlink" title="第四章 体能精力——为身体添柴加火"></a>第四章 体能精力——为身体添柴加火</h3><p>吃得好睡得好又积极锻炼显然有很多益处，包括减重、获得漂亮的外形和健康，更能带来积极情绪。体能不仅是敏锐度和生命力的核心，还影响着我们管理情绪、保持专注、创新思考甚至投入工作的能力。 </p><blockquote><p>体能精力是生活最基本的精力源。</p><p>体能精力通过氧气和葡萄糖的化学作用获得。</p><p>体能精力最关键的两项调节器是呼吸和进食。</p><p>每天吃5～6顿低热量高营养的食物，能够为机体持续供应葡萄糖和必须的营养。</p><p>每天喝64盎司的水是有效管理体力的关键要素。</p><p>大多数人需要每晚7～8小时的睡眠，方可正常运作。</p><p>早睡早起可以优化效能表现。</p><p>间歇训练比稳态训练在锻炼体力方面更有效，在体力恢复方面更高效。</p><p>为了保持全情投入的状态，我们必须工作90～120分钟就休息片刻。</p></blockquote><h3 id="第五章-情感精力——把威胁转化为挑战"><a href="#第五章-情感精力——把威胁转化为挑战" class="headerlink" title="第五章 情感精力——把威胁转化为挑战"></a>第五章 情感精力——把威胁转化为挑战</h3><p>从精力角度来看，负面情感代价昂贵且效率低下。对于领导者和管理层来说，由于负面情感极易传染，如果我们激起了他人的恐惧、愤怒和戒备心，也等同于损害了他们的工作能力。</p><p>相对而言，正面情感可以更有效地支配个人表现，所有能带来享受、满足和安全感的活动都能够激发正面情感。从更实际的角度看，快乐本身便是奖赏，也是维持最佳表现的重要因素。</p><blockquote><p>为了达到最佳表现，我们必须汲取愉悦、积极的情感，享受挑战、冒险和机遇。</p><p>正面情感精力的关键因素是自信、自控、人际关系与共情。</p><p>负面情感也可以维持我们的生活，但相比于正面情绪代价巨大，事倍功半。</p><p>在高强度压力下调动积极情感的能力是领导力的核心。</p><p>利用情感肌肉支配表现，需要依靠定期锻炼和间歇恢复的平衡。</p><p>任何带来享受、令人满足和安心的活动都可以作为情感的再生和恢复方式。</p><p>练习耐心、共情、自信等情感肌肉的方法与锻炼二头肌或三头肌的方法相同：越过当前的极限，留出充足的恢复空间。</p></blockquote><h3 id="第六章-思维精力——保持专注和乐观"><a href="#第六章-思维精力——保持专注和乐观" class="headerlink" title="第六章 思维精力——保持专注和乐观"></a>第六章 思维精力——保持专注和乐观</h3><p>为了发挥出最好的水平，我们必须保持专注，在整体方向和局部目标之间灵活游走。我们还需要调用现实的乐观主义，一方面看清事物的本质，另一方面还能朝着目标成果积极努力。</p><blockquote><p>我们使用思维精力规划生活、集中精力。</p><p>最有益于全情投入的思维精力是现实乐观主义——看清事物真相，却仍朝目标积极努力。</p><p>优化思维精力的关键在于思想准备、构建想象、积极的自我暗示、高效的时间管理和创造力。</p><p>转换思维频道可以激活不同的大脑部分，提升创造力。</p><p>身体锻炼可以助长认知能力。</p><p>思维消耗与恢复的平衡可以帮助思维精力达到最大。</p><p>如果缺乏某种思维能力，需要系统地加以锻炼，不断突破自己的舒适区并充分休息。</p><p>持续挑战大脑可以有效预防老龄化思维衰退。</p></blockquote><h3 id="第七章-意志精力——活出人生的意义"><a href="#第七章-意志精力——活出人生的意义" class="headerlink" title="第七章 意志精力——活出人生的意义"></a>第七章 意志精力——活出人生的意义</h3><p>尼采有句名言 ：“知晓生命的意义，方能忍耐一切。”</p><p>任何能够点燃人类精神的事物都有助于全情投入、促进最佳表现。意志精力的关键动力在于性格品质——一个人如果有自己的人生目标，他的勇气和信念，即使面对艰难困苦和个人牺牲也会在所不惜。意志精力由激情、奉献、正直与诚实支持着。</p><blockquote><p>意志精力为所有层面的行为提供动力，带来激情、恒心和投入。</p><p>意志精力源于价值取向和超出个人利益的目标。</p><p>品质——依照价值取向生活的勇气——是意志力量的关键因素。</p><p>最强大的意志力量是激情、投入、正直和诚实。</p><p>意志精力的消耗与再生密不可分。</p><p>意志精力通过超越自身的目标和自我关心间的平衡得以维持。</p><p>意志功课会同时消耗和产生精力。</p><p>拓展意志力量与拓展体能的原理相同，都要突破我们的舒适区域。</p><p>人类的意志精力甚至可以弥补严重不足的体能精力。 </p></blockquote><h2 id="第三部分-精力管理训练系统"><a href="#第三部分-精力管理训练系统" class="headerlink" title="第三部分 精力管理训练系统"></a>第三部分 精力管理训练系统</h2><h3 id="第八章-明确目标——知道什么最重要才能全情投入"><a href="#第八章-明确目标——知道什么最重要才能全情投入" class="headerlink" title="第八章 明确目标——知道什么最重要才能全情投入"></a>第八章 明确目标——知道什么最重要才能全情投入</h3><p>只有树立目标，真正深刻地关心自己所做的事情，认为自己所为真正有意义，人们才有可能做到全情投入。使命感是我们的火种，我们的动力，也是我们的精神食粮。</p><p>如果说成长和发展是自下而上的——从体能到情感到思维再到意志，改变则是自上而下进行的。</p><p>意志力量是目标最充足的源泉，意志精力来源于深层价值取向和超越个人利益的目标。</p><p>目标会激发决心。它促成了我们的全情投入，希望将精力集中在某件事或某个目标上。</p><h4 id="衡量人生目标的力量"><a href="#衡量人生目标的力量" class="headerlink" title="衡量人生目标的力量"></a>衡量人生目标的力量</h4><p>人生目标是一种独特的精力源。正如我们之前所说，人生目标会带来专注、目标感、激情和恒心。为了快速了解自己的生命意义，请拿出笔和纸回答以下3个问题，分别从1到10进行打分。</p><blockquote><p>每天早晨上班时你的兴奋度是多少？</p><p>享受做事有多大程度是因为事情本身而非它带来的回报？</p><p>你认为自己对价值取向负有多大的责任？</p></blockquote><p>如果3道问题的总分达到27分以上，说明你已经带着强烈的人生目标生活了。如果总分在22分以下，说明你的生活只是走过场。问题的关键并非在于生活赋予你怎样的意义，而在于你是否主动将生活变成自己价值取向的载体。</p><p>正如维克多·弗兰克尔所说的：“毕竟，人类不应该询问生活的意义，因为他自己才是需要做出回答的人。每个人都要接受生活的质询。他只能为自己的生活作答，并负起相应的责任。”</p><p>意志的发展有许多层面，正如体能、情感和思维发展也有许多层面一样。</p><p>当客户的精力从弥补过失转向培养价值观、为自己树立目标时，他们的生活才有可能发生巨大的改变。正如网球选手阿什所说：“我们依生活所赐而谋生，依己之付出而生活。”</p><h4 id="积极的人生目标"><a href="#积极的人生目标" class="headerlink" title="积极的人生目标"></a>积极的人生目标</h4><p>当目标感从消极流向积极、从外部流向内部、从自己流向他人，它就成为生活中最强大也最持久的精力源。</p><p>消极的目标充满防备心理，它的本质基于缺陷，诞生于身体威胁或心理威胁。</p><blockquote><p>从有记载开始，追寻使命感就是人类文明长河中必不可少的主题。</p><p>“英雄之旅”需要调动、培养和更新我们最重要的资源——精力，才能协助我们完成最重要的使命。</p><p>如果缺乏强烈的使命感，我们很容易迷失在生活无常的风暴里。</p><p>当使命感从负面变成正面、从外部转向内部、从自我变成他人时，才能为我们提供更强大、更持久的精力。</p><p>负面目标源自缺陷，且充满防备性。</p><p>内部动机指的是我们对某件事物本身渴望，渴望仅仅源于其带给我们的满足感。</p><p>价值观能够提供实现目标的精力。它会带来精力管理标准的变革。</p><p>在行动中体现的价值叫作美德。</p><p>基于明确的价值观的设想蓝图可以指导我们如何投入精力。</p></blockquote><h3 id="第九章-正视现实——你的精力管理做得如何"><a href="#第九章-正视现实——你的精力管理做得如何" class="headerlink" title="第九章 正视现实——你的精力管理做得如何"></a>第九章 正视现实——你的精力管理做得如何</h3><p>我们常常在周围的人身上看到愤怒、憎恨、傲慢或贪婪，却很少承认这些情绪也存在于我们的内心。</p><p>古代希腊人在帕纳萨斯山一侧刻下两句警世名言，其中一句“认识你自己”最广为流传，另一句可以简单翻译为“认识你全部的自己”。我们只有满怀震惊地看到真实的自己，而不是看到我们希望或想象中的自己，才算迈向个人生活现实的第一步。</p><blockquote><p>面对真相能够释放精力。它发生在确立目标之后，是通往全情投入的第二阶段。</p><p>逃避真相会消耗大量精力。</p><p>我们会自我欺骗以保护自尊。</p><p>有些真相太难以承受，无法一次性消化。</p><p>不带怜悯的诚实是种残酷，对人对己均是如此。</p><p>我们不愿承认自己身上具有某些品质，却仍然会不自知地表现出来。</p><p>自我欺骗的常见形式是认定自己的看法就是真相，而它不过是我们解读世界的方式。</p><p>面对真相需要我们保持开放的心态，承认自己被蒙蔽的可能性。</p><p>过于坚持自己的一面之词是种假象，也是危险。我们都是光明与暗影、美德与恶行的混合体。</p><p>承认自己的局限性能帮助我们降低自我防御，增强积极精力。 </p></blockquote><h3 id="第十章-付诸行动——积极仪式习惯的力量"><a href="#第十章-付诸行动——积极仪式习惯的力量" class="headerlink" title="第十章 付诸行动——积极仪式习惯的力量"></a>第十章 付诸行动——积极仪式习惯的力量</h3><p>所有表现卓越的人都依靠积极的仪式习惯管理精力和规范行为。如果你一直久坐不动，打算开始锻炼身体，你可以最开始每周3次、每次步行15分钟，然后逐周增加步行时间或加快步伐。</p><blockquote><p>仪式习惯是有效的精力管理工具，可以协助我们完成任务。</p><p>仪式习惯帮助我们将价值观和优先级融入生活的各个方面。</p><p>所有表现卓越的人都依靠积极的仪式习惯管理精力和规范行为。</p><p>个人意愿和自制力之所以有局限性，是因为每一次自控都会耗费有限的资源。</p><p>我们可以通过养成自发的仪式习惯来抵消主观意愿和自制力的局限性。</p><p>仪式习惯最重要的角色是确保精力消耗和更新达到有效平衡，以更好地为全情投入服务。</p><p>我们面对的压力和挑战越大，越需要细致谨慎的仪式习惯。</p><p>精确性和具体性是在30～60天的周期里养成习惯的关键。</p><p>尽量避免做出快速消耗自制里的选择。</p><p>为了确保持久的变革，我们需要养成一系列仪式习惯，一次只作一项重大改变。 </p></blockquote><h3 id="第十一章-又见罗杰——重获新生"><a href="#第十一章-又见罗杰——重获新生" class="headerlink" title="第十一章 又见罗杰——重获新生"></a>第十一章 又见罗杰——重获新生</h3><p>在我们认识罗杰12个月后，他的事业迅速重新走上了正轨。他在日程里加入了一项重大改变。经老板批准，他可以每周有一天在家上班。在家那天，他会接送两个女儿上学、放学，承诺下午5点结束工作。与女儿们更紧密的沟通让他感到满足，这天的工作效率也非常高。</p><p>他最终树立了自己的价值观，构建了目标蓝图，并且受益匪浅。面对困难抉择时，它们既是动力的源泉又是可靠的试金石。</p><h4 id="人生目标是动力"><a href="#人生目标是动力" class="headerlink" title="人生目标是动力"></a>人生目标是动力</h4><p>在明确目标阶段，罗杰第一项晚间作业就是回答问题，找到自己最重视的价值观。其中一个问题是：“如果现在就是人生的尽头，你学到的最重要的3个道理是什么？”虽然生活已经很艰难，但罗杰是个复杂的人。下面是他的答案：</p><ol><li>与所爱之人组成家庭，把家人放在首要位置。身外之物总是来了又走，只有亲密关系才会永恒。</li><li>努力工作，高标准要求自己，永远不要在能力范围内退而求其次。</li><li>尊重并善待他人。</li></ol><p>在列举重要价值观时，他的回答也在意料之中——善良、卓越、家庭、正直和健康。</p><p>确立生命意义的最后一步是构建自己的蓝图。他是这样写的：</p><p>我的生命中最重要的是我的妻子和孩子。在我们团聚的时刻，我承诺献出自己的所有精力和关注。为了做到这一点，我必须照顾好自己的身体。在工作中，我要严格要求自己。作为领导者，我要表现出自己的价值观——善良、关心他人和正直。我要让他人感到备受关心，让他们感觉可以放心依靠我。不管我做什么事情，都要全心全意。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一部分-如何做到全情投入&quot;&gt;&lt;a href=&quot;#第一部分-如何做到全情投入&quot; class=&quot;headerlink&quot; title=&quot;第一部分 如何做到全情投入&quot;&gt;&lt;/a&gt;第一部分 如何做到全情投入&lt;/h2&gt;&lt;h3 id=&quot;第一章-什么是精力及如何管理精力&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="个人素质" scheme="http://gnbyj.cn/categories/%E4%B8%AA%E4%BA%BA%E7%B4%A0%E8%B4%A8/"/>
    
    
      <category term="自我管理" scheme="http://gnbyj.cn/tags/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法说明</title>
    <link href="http://gnbyj.cn/2018/06/21/%E5%85%B6%E4%BB%96/Markdown%20%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://gnbyj.cn/2018/06/21/其他/Markdown 语法说明/</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2018-07-06T04:33:37.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p><p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p><p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像<em>强调</em>。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p><h3 id="兼容-HTML"><a href="#兼容-HTML" class="headerlink" title="兼容 HTML"></a>兼容 HTML</h3><p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p><p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p><p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p><p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这是一个普通段落。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Foo<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">这是另一个普通段落。</span><br></pre></td></tr></table></figure><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p><p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p><p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p><h3 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p><p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://images.google.com/images?num=30&amp;q=larry+bird</span><br></pre></td></tr></table></figure><p>你必须要把网址转换写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://images.google.com/images?num=30&amp;amp;q=larry+bird</span><br></pre></td></tr></table></figure><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p><p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp</code>;。</p><p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;copy;</span><br></pre></td></tr></table></figure><p>Markdown 会保留它不动。而若你写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT&amp;T</span><br></pre></td></tr></table></figure><p>Markdown 就会将它转为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT&amp;amp;T</span><br></pre></td></tr></table></figure><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="http://wowubuntu.com/markdown/#html" target="_blank" rel="noopener">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 &lt; 5</span><br></pre></td></tr></table></figure><p>Markdown 将会把它转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 &amp;lt; 5</span><br></pre></td></tr></table></figure><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p><hr><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p><p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p><p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p><p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="http://wowubuntu.com/markdown/#blockquote" target="_blank" rel="noopener">区块引用</a> 和多段落的 <a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="noopener">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a> 形式。</p><p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is an H1</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">This is an H2</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p><p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这是 H1</span><br><span class="line"></span><br><span class="line">## 这是 H2</span><br><span class="line"></span><br><span class="line">###### 这是 H6</span><br></pre></td></tr></table></figure><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这是 H1 #</span><br><span class="line"></span><br><span class="line">## 这是 H2 ##</span><br><span class="line"></span><br><span class="line">### 这是 H3 ######</span><br></pre></td></tr></table></figure><h3 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h3><p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">&gt; id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; This is the first level of quoting.</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; This is nested blockquote.</span><br><span class="line">&gt;</span><br><span class="line">&gt; Back to the first level.</span><br></pre></td></tr></table></figure><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; ## 这是一个标题。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1.   这是第一行列表项。</span><br><span class="line">&gt; 2.   这是第二行列表项。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 给出一些例子代码：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br></pre></td></tr></table></figure><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号、加号或是减号作为列表标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>也等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><p>有序列表则使用数字接着一个英文句点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;Bird&lt;/li&gt;</span><br><span class="line">&lt;li&gt;McHale&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Parish&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p>如果你的列表标记写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">1.  McHale</span><br><span class="line">1.  Parish</span><br></pre></td></tr></table></figure><p>或甚至是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3. Bird</span><br><span class="line">1. McHale</span><br><span class="line">8. Parish</span><br></pre></td></tr></table></figure><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p><p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">    viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">    Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>但是如果你懒，那也行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code> 标签包起来，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*   Bird</span><br><span class="line">*   Magic</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;Bird&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Magic&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>但是这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Bird</span><br><span class="line"></span><br><span class="line">*   Magic</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span><br><span class="line">    mi posuere lectus.</span><br><span class="line"></span><br><span class="line">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span><br><span class="line">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span><br><span class="line">    sit amet velit.</span><br><span class="line"></span><br><span class="line">2.  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line">    This is the second paragraph in the list item. You&apos;re</span><br><span class="line">only required to indent the first line. Lorem ipsum dolor</span><br><span class="line">sit amet, consectetuer adipiscing elit.</span><br><span class="line"></span><br><span class="line">*   Another item in the same list.</span><br></pre></td></tr></table></figure><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line">    &gt; This is a blockquote</span><br><span class="line">    &gt; inside a list item.</span><br></pre></td></tr></table></figure><p>如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   一列表项包含一个列表区块：</span><br><span class="line"></span><br><span class="line">        &lt;代码写在这&gt;</span><br></pre></td></tr></table></figure><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1986. What a great season.</span><br></pre></td></tr></table></figure><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1986\. What a great season.</span><br></pre></td></tr></table></figure><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p><p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个普通段落：</span><br><span class="line"></span><br><span class="line">这是一个代码区块。</span><br></pre></td></tr></table></figure><p>Markdown 会转换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;这是一个普通段落：&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;这是一个代码区块。</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Here is an example of AppleScript:</span><br><span class="line"></span><br><span class="line">    tell application &quot;Foo&quot;</span><br><span class="line">        beep</span><br><span class="line">    end tell</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;</span><br><span class="line">    beep</span><br><span class="line">end tell</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p><p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">&amp;copy; 2004 Foo Corporation</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;</span><br><span class="line">    &amp;amp;copy; 2004 Foo Corporation</span><br><span class="line">&amp;lt;/div&amp;gt;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><hr><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p><p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p>要建立一个<em>行内式</em>的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is [an example](http://example.com/ &quot;Title&quot;) inline link.</span><br><span class="line"></span><br><span class="line">[This link](http://example.net/) has no title attribute.</span><br></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;</span><br><span class="line">an example&lt;/a&gt; inline link.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no</span><br><span class="line">title attribute.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">See my [About](/about/) page for details.</span><br></pre></td></tr></table></figure><p><em>参考式</em>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is [an example][id] reference-style link.</span><br></pre></td></tr></table></figure><p>你也可以选择性地在两个方括号中间加上一个空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is [an example] [id] reference-style link.</span><br></pre></td></tr></table></figure><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: http://example.com/  &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li></ul><p>下面这三种链接的定义都是相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[foo]: http://example.com/  &quot;Optional Title Here&quot;</span><br><span class="line">[foo]: http://example.com/  &apos;Optional Title Here&apos;</span><br><span class="line">[foo]: http://example.com/  (Optional Title Here)</span><br></pre></td></tr></table></figure><p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p><p>链接网址也可以用尖括号包起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[id]: http://example.com/longish/path/to/resource/here</span><br><span class="line">    &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p><p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[link text][a]</span><br><span class="line">[link text][A]</span><br></pre></td></tr></table></figure><p><em>隐式链接标记</em>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google][]</span><br></pre></td></tr></table></figure><p>然后定义链接内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google]: http://google.com/</span><br></pre></td></tr></table></figure><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Visit [Daring Fireball][] for more information.</span><br></pre></td></tr></table></figure><p>然后接着定义链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Daring Fireball]: http://daringfireball.net/</span><br></pre></td></tr></table></figure><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p><p>下面是一个参考式链接的范例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http://google.com/        &quot;Google&quot;</span><br><span class="line">  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">  [3]: http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure><p>如果改成用链接名称的方式写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google][] than from</span><br><span class="line">[Yahoo][] or [MSN][].</span><br><span class="line"></span><br><span class="line">  [google]: http://google.com/        &quot;Google&quot;</span><br><span class="line">  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure><p>上面两种写法都会产生下面的 HTML。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;</span><br><span class="line">title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from</span><br><span class="line">&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;</span><br><span class="line">or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)</span><br><span class="line">than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or</span><br><span class="line">[MSN](http://search.msn.com/ &quot;MSN Search&quot;).</span><br></pre></td></tr></table></figure><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p><p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code>包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*single asterisks*</span><br><span class="line"></span><br><span class="line">_single underscores_</span><br><span class="line"></span><br><span class="line">**double asterisks**</span><br><span class="line"></span><br><span class="line">__double underscores__</span><br></pre></td></tr></table></figure><p>会转成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;em&gt;single asterisks&lt;/em&gt;</span><br><span class="line"></span><br><span class="line">&lt;em&gt;single underscores&lt;/em&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double asterisks&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double underscores&lt;/strong&gt;</span><br></pre></td></tr></table></figure><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p><p>强调也可以直接插在文字中间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">un*frigging*believable</span><br></pre></td></tr></table></figure><p>但是<strong>如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*this text is surrounded by literal asterisks\*</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果要标记一小段行内代码，你可以用反引号把它包起来，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use the `printf()` function.</span><br></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``There is a literal backtick (`) here.``</span><br></pre></td></tr></table></figure><p>这段语法会产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A single backtick in a code span: `` ` ``</span><br><span class="line"></span><br><span class="line">A backtick-delimited string in a code span: `` `foo` ``</span><br></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>在代码区段内，<code>&amp;</code> 和尖括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please don&apos;t use any `&lt;blink&gt;` tags.</span><br></pre></td></tr></table></figure><p>转为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>你也可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.</span><br></pre></td></tr></table></figure><p>以产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded</span><br><span class="line">equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p><p>行内式的图片语法看起来像是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](/path/to/img.jpg)</span><br><span class="line"></span><br><span class="line">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure><p>详细叙述如下：</p><ul><li>一个惊叹号 <code>!</code></li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li></ul><p>参考式的图片语法则长得像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][id]</span><br></pre></td></tr></table></figure><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: url/to/image  &quot;Optional title attribute&quot;</span><br></pre></td></tr></table></figure><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://example.com/&gt;</span><br></pre></td></tr></table></figure><p>Markdown 会转为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address@example.com&gt;</span><br></pre></td></tr></table></figure><p>Markdown 会转成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;</span><br><span class="line">&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;</span><br><span class="line">&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;</span><br><span class="line">&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「<a href="mailto:address@example.com" target="_blank" rel="noopener">address@example.com</a>」链接。</p><p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*literal asterisks\*</span><br></pre></td></tr></table></figure><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;宗旨&quot;&gt;&lt;a href=&quot;#宗旨&quot; class=&quot;headerlink&quot; title=&quot;宗旨&quot;&gt;&lt;/a&gt;宗旨&lt;/h3&gt;&lt;p&gt;Mar
      
    
    </summary>
    
      <category term="Markdown" scheme="http://gnbyj.cn/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://gnbyj.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>在错误中成长</title>
    <link href="http://gnbyj.cn/2018/05/29/%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98/Error%20notes/"/>
    <id>http://gnbyj.cn/2018/05/29/程序问题/Error notes/</id>
    <published>2018-05-29T11:11:55.000Z</published>
    <updated>2018-07-16T05:00:36.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在ubuntu下安装SSH可以：  </p><p><code>apt-get install openssh-server</code>  </p><p>就是说在centos上可以这样来安装ssh：  </p><p><code># yum -y install openssh-server</code>  </p></blockquote><hr><blockquote><p>Eclipse 编译时报错：<br>Access restriction:The type JPEGCodec is not accessible due to restriction on required library C:/Program Files/Java/jre6/lib/rt.jar<br>解决方法：<br>Project -&gt; Properties -&gt; libraries，<br>先 remove 掉 JRE System Library，然后再 Add Library 重新加入。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在ubuntu下安装SSH可以：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;apt-get install openssh-server&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;就是说在centos上可以这样来安装ssh：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;# yum -
      
    
    </summary>
    
      <category term="问题集" scheme="http://gnbyj.cn/categories/%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="错误" scheme="http://gnbyj.cn/tags/%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>scrapy入门</title>
    <link href="http://gnbyj.cn/2018/05/21/%E7%88%AC%E8%99%AB/scrapy/"/>
    <id>http://gnbyj.cn/2018/05/21/爬虫/scrapy/</id>
    <published>2018-05-21T10:00:00.000Z</published>
    <updated>2018-05-27T15:27:00.726Z</updated>
    
    <content type="html"><![CDATA[<p>scrapy 是一个用 python 语言编写的，为了爬取网站数据，提取结构性数据而编写的应用框架。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>本文使用的环境：<br>python 3.5.2<br>pip 9.0.1<br>操作系统： Ubuntu 16.04  </p><p><strong>pythton 环境搭建</strong><br>在官网下载 Ubuntu 环境下的python3.5的安装包，安装完成后，检查一下 python 的安装情况，一般pyhton安装的时候，pip 也是一起安装好的，如果没有安装完全，再将 pip 也一起安装好。</p><p><strong>虚拟环境搭建</strong><br>现在Ubuntu默认是安装 python2.7 的，避免两个环境之间切换的麻烦，我们安装 python 虚拟环境来解决这个问题。</p><pre><code>pip install virtualenvpip install virtualwrapperpip list # 查看已安装</code></pre><p>virtualenv 能够通过根据不同的 python 版本创建对应不同版本的虚拟环境，virtualwrapper 能够方便的在不同的虚拟环境之间进行切换。安装完成之后，下面我们创建一个 python3.5.2 版本的虚拟环境：</p><pre><code>source /usr/local/bin/virtualwrapper.sh #这个与 windows 不一样，需要先执行一下脚本才能生效，大家可以打开这个文件看一下# 创建一个名为 py3Scrapy 的虚拟环境mkvirtualenv py3Scrapy -p /usr/bin/python3.5# workon 查看创建好的虚拟环境，虚拟环境的保存路径可以通过 `VIRTUALENV_PYTHON` 来配置workonworkon py3Scrapy # 进入选择的虚拟环境</code></pre><p>如下图所示：<br><img src="https://img-blog.csdn.net/20170709211559805?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2xpY3UxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>python的版本也能查看得到，进入虚拟环境之后，在shell前面会出现虚拟环境的名称，退出虚拟环境</p><pre><code>deactivate</code></pre><p>好了，创建好环境之后，现在来开始我们的 scrapy 之旅吧。</p><p><strong>scrapy 环境搭建</strong><br>scrapy 是基于 twisted 框架的，大家会发现，安装 scrapy 的时候，会需要安装很多包。</p><pre><code>pip install scrapy</code></pre><p>使用 pip 进行安装，方便，但是这种默认的安装方式，实在官网下载安装包来进行安装的，比较慢，大家可以使用豆瓣源来进行安装：</p><pre><code>pip install scrapy -i https://pypi.douban.com/simple</code></pre><p>这种方式，下载会非常的快，安装其他的包都可以使用这种方法，但是，如果使用豆瓣源安装的时候，提示找不到符合版本的安装包，那就使用第一种办法进行下载安装，因为豆瓣源可能没有官网那么及早更新。</p><p>因为每个人的环境都可能存在差异，安装过程中会出现一些问题。当如果报错，twisted 安装失败的时候，建议从官网下载 twisted 安装包，自行进行安装，安装完成之后，再接着继续上面 scrapy 的安装，安装完成之后，检查一些安装结果：</p><pre><code>scrapy -h</code></pre><p><strong>使用 scrapy 获取某一篇文章的信息</strong><br>好了，环境准备好之后，接下来我们来分析一下伯乐在线的文章网页结构</p><p><strong>分析伯乐在线某一篇文章的网页结构和url</strong><br>伯乐在线网站不需要我们先登录，然后才能访问其中的内容，所以不需要先模拟登录，直接就能访问网页。伯乐在线地址为 <a href="https://www.jobbole.com" target="_blank" rel="noopener">https://www.jobbole.com</a>，这上面的文章质量还是不错的，大家有时间可以看看。</p><p>我们随便找一篇文章试图来分析一下，比如 <a href="http://blog.jobbole.com/111469/" target="_blank" rel="noopener">http://blog.jobbole.com/111469/</a>，F12进入浏览器调试窗口，从全文分析，比如我们想获取文章标题，文章内容，文章创建时间，点赞数，评论数，收藏数，文章所属类别标签，文章出处等信息。</p><p><strong>使用 scrapy shell 的方法获取解析网页数据</strong><br>打开文章链接，我们获取到的是一个html页面，那么如何获取上面所说的那些数据呢，本文通过 CSS 选择器来获取(不了解 CSS selector的小伙伴可以先去熟悉一下 <a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/cssref/css_selectors.asp</a>)。 scrapy 为我们提供了一个 shell 的环境，可以方便我们进行调试和实验，验证我们的css 表达式能够成功获取所需要的值。下面启动 scrapy shell</p><pre><code>scrapy shell &quot;http://blog.jobbole.com/111469/&quot;</code></pre><p>scrapy 将会帮助我们将<a href="http://blog.jobbole.com/111469/这个链接的数据捕获，现在来获取一下文章标题，在浏览器中找到文章标题，inspect" target="_blank" rel="noopener">http://blog.jobbole.com/111469/这个链接的数据捕获，现在来获取一下文章标题，在浏览器中找到文章标题，inspect</a> element 审查元素，如下图所示：<br><img src="https://img-blog.csdn.net/20170709211703946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2xpY3UxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>文章标题为王垠：如何掌握所有的程序语言，从上图获知，这个位于一个 class 名为 entry-header 的 div 标签下的子标签 h1 中，那我们在 scrapy shell 通过 css 选择器来获取一下，如下图所示：<br><img src="https://img-blog.csdn.net/20170709211738506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2xpY3UxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>仔细查看上图，注意一些细节。通过 response.css 方法，返回的结果是一个 selector，不是字符串，在这个 selector 的基础上可以继续使用 css 选择器。通过 extract() 函数获取提取的标题内容，返回结果是一个 list，注意，这里是一个 list ，仍然不是字符串 str，使用 extract()[0] 返回列表中的第一个元素，即我们需要的标题。</p><p>但是，如果标题没有获取到，或者选择器返回的结果为空的话，使用 extract()[0] 就会出错，因为试图对一个空链表进行访问，这里使用 extract_first() 方法更加合适，可是使用一个默认值，当返回结果为空的时候，返回这个默认值</p><pre><code>extract_first(&quot;&quot;)   # 默认值为 &quot;&quot;</code></pre><p>此处仅仅是将 title 标题作为一个例子进行说明，其他的就不详细进行解释了，主要代码如下所示：</p><pre><code>title = response.css(&quot;.entry-header h1::text&quot;).extract()[0]match_date = re.match(&quot;([0-9/]*).*&quot;,                      response.css(&quot;.entry-meta-hide-on-mobile::text&quot;).extract()[0].strip())if match_date:    create_date = match_date.group(1)votes_css = response.css(&quot;.vote-post-up h10::text&quot;).extract_first()if votes_css:    vote_nums = int(votes_css)else:    vote_nums = 0ma_fav_css = re.match(&quot;.*?(\d+).*&quot;,                      response.css(&quot;.bookmark-btn::text&quot;).extract_first())if ma_fav_css:    fav_nums = int(ma_fav_css.group(1))else:    fav_nums = 0ma_comments_css = re.match(&quot;.*?(\d+).*&quot;,                           response.css(&quot;a[href=&apos;#article-comment&apos;] span::text&quot;).extract_first())if ma_comments_css:    comment_nums = int(ma_comments_css.group(1))else:    comment_nums = 0tag_lists_css = response.css(&quot;.entry-meta-hide-on-mobile a::text&quot;).extract()tag_lists_css = [ele for ele in tag_lists_css if not ele.strip().endswith(&apos;评论&apos;)]tags = &apos;,&apos;.join(tag_lists_css)content = response.css(&quot;.entry *::text&quot;).extract()</code></pre><p>解释一下 create_date，通过获取到的值，存在其他非时间的数据，通过 re.match 使用正则表达式来提取时间。</p><p>好了，所有需要的值都提取成功后，下面通过 scrapy 框架来创建我们的爬虫项目。</p><p><strong>创建爬虫项目</strong><br>开始我们的爬虫项目</p><pre><code>scrapy startproject ArticleSpider</code></pre><p>scrapy 会为我们创建一个名为 ArticleSpider 的项目<br>进入到 ArticleSpider 目录，使用basic模板创建</p><pre><code>scrapy genspider jobbole blog.jobbole.com</code></pre><p>创建完成之后，我们使用 pycharm 这个IDE打开我们创建的爬虫项目，目录结构如下所示： </p><pre><code>├── ArticleSpider│   ├── items.py│   ├── middlewares.py│   ├── pipelines.py│   ├── __pycache__│   ├── settings.py│   ├── spiders│   │   ├── __init__.py│   │   ├── jobbole.py│   │   └── __pycache__└── scrapy.cfg</code></pre><p>我们可以在 items.py 里面定义数据保存的格式，在 middlewares.py 定义中间件，在 piplines.py 里面处理数据，保存到文件或者数据库中等。在 jobbole.py 中对爬取的页面进行解析。</p><p>下面，我们首先需要做的，就是利用我们编写的 css 表达式，获取我们提取的文章的值。在 jobbole.py 中，我们看到</p><pre><code>class JobboleSpider(scrapy.Spider):    name = &apos;jobbole&apos;    allowed_domains = [&apos;blog.jobbole.com&apos;]    start_urls = [&apos;http://blog.jobbole.com/all-posts/&apos;]    def parse(self, response):        pass</code></pre><p>scrapy 为我们创建了一个 JobboleSpider 的类，name 是爬虫项目的名称，同时定义了域名以及爬取的入口链接。scrapy 初始化的时候，会初始化 <code>start_urls</code> 入口链接列表，然后通过 <code>start_requests</code> 返回 Request 对象进行下载，调用 parse 回调函数对页面进行解析，提取需要的值，返回 item。</p><p>所以，我们需要做的，就是将我们在上一小节编写的代码放在 parse 函数中，同时，将 <code>start_urls</code> 的值，改为上面我们在 scrapy shell 爬取的页面的地址<a href="http://blog.jobbole.com/111469/" target="_blank" rel="noopener">http://blog.jobbole.com/111469/</a>，因为我们这里还没有讲到通过 item 获取我们提取的值，此处你可以通过 print() 函数将值进行打印。在 shell 中启动爬虫（先进入我们的工程目录）</p><pre><code>scrapy crawl jobbole</code></pre><p>既然我们使用了 pycharm 这个IDE，那么我们就不用 shell 来启动爬虫，在 ArticleSpider 目录下创建一个 main.py 文件</p><pre><code>from scrapy.cmdline import executeimport sysimport ossys.path.append(os.path.dirname(os.path.abspath(__file__)))execute([&quot;scrapy&quot;, &quot;crawl&quot;, &quot;jobbole&quot;])</code></pre><p>上面的代码，就是将当前项目路径加入到 path 中，然后通过调用scrapy 命令行来启动我们的工程。然后，通过设置断点调试，一步一步查看我们的提取的变量的值是否正确。</p><blockquote><p>注意：启动之前，将 settings.py 中的 <code>ROBOTSTXT_OBEY</code> 这个参数设置为 False</p></blockquote><p>这样，我们就爬取到了伯乐在线的这一篇文章了。</p><p><strong>扩展，爬取所有的文章</strong><br>既然我们已经能够获取到某一篇文章的数据，那么下面就来获取所有文章的链接。</p><p><strong>扩展一：获取所有 url 链接</strong><br>伯乐在线所有文章链接的入口地址为 <a href="http://blog.jobbole.com/all-posts/" target="_blank" rel="noopener">http://blog.jobbole.com/all-posts/</a>，通过浏览器进入调试模式查看文章列表的链接，如下图所示<br><img src="https://img-blog.csdn.net/20170709212022073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2xpY3UxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>文章链接是在 id 为 archive 的 div 标签下的子 div 标签之下， class 为 post-thumb，这个下面的子标签 a 的 href 属性，仍使用上面说的 scrapy shell 的方法，如下图所示<br><img src="https://img-blog.csdn.net/20170709212057635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2xpY3UxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>可以看出，获得了当前页面所有的文章的 url，这仅仅是当前页面的所有 url，我们还需要获取下一页的 url，然后通过下一页的 url 进入到下一页，获取下一页的所有文章的 url，依次类推，知道爬取完所有的文章 url。</p><p>在文章列表的最后，有翻页，分析如下<br><img src="https://img-blog.csdn.net/20170709212114364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2xpY3UxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>下一页是 class 为 next page-numbers 的 a 标签中，如下图<br><img src="https://img-blog.csdn.net/20170709212131471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2xpY3UxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>既然现在所有的 url 都能够获取到了，那么现在我们将 jobbole.py 中的 parse 函数修改一下</p><pre><code>def parse(self, response):    post_nodes = response.css(&quot;#archive .floated-thumb .post-thumb&quot;)    # a selector, 可以在这个基础上继续做 selector    for post_node in post_nodes:        post_url = post_node.css(&quot;a::attr(href)&quot;).extract_first(&quot;&quot;)        yield Request(url=parse.urljoin(response.url, post_url),                      callback=self.parse_detail)    # 必须考虑到有前一页，当前页和下一页链接的影响，使用如下所示的方法    next_url = response.css(&quot;span.page-numbers.current+a::attr(href)&quot;).extract_first(&quot;&quot;)     if next_url:         yield Request(url=parse.urljoin(response.url, next_url), callback=self.parse)def parse_detail(self, response):    &quot;&quot;&quot;作为回调函数，在上面调用&quot;&quot;&quot;    title = response.css(&quot;.entry-header h1::text&quot;).extract()[0]    match_date = re.match(&quot;([0-9/]*).*&quot;,                          response.css(&quot;.entry-meta-hide-on-mobile::text&quot;).extract()[0].strip())    if match_date:        create_date = match_date.group(1)    votes_css = response.css(&quot;.vote-post-up h10::text&quot;).extract_first()    if votes_css:        vote_nums = int(votes_css)    else:        vote_nums = 0    ma_fav_css = re.match(&quot;.*?(\d+).*&quot;,                          response.css(&quot;.bookmark-btn::text&quot;).extract_first())    if ma_fav_css:        fav_nums = int(ma_fav_css.group(1))    else:        fav_nums = 0    ma_comments_css = re.match(&quot;.*?(\d+).*&quot;,                               response.css(&quot;a[href=&apos;#article-comment&apos;] span::text&quot;).extract_first())    if ma_comments_css:        comment_nums = int(ma_comments_css.group(1))    else:        comment_nums = 0    tag_lists_css = response.css(&quot;.entry-meta-hide-on-mobile a::text&quot;).extract()    tag_lists_css = [ele for ele in tag_lists_css if not ele.strip().endswith(&apos;评论&apos;)]    tags = &apos;,&apos;.join(tag_lists_css)    # cpyrights = response.css(&quot;.copyright-area&quot;).extract()    content = response.css(&quot;.entry *::text&quot;).extract()</code></pre><ol><li>获取文章列表页中的文章url，交给 scrapy 下载后并进行解析，即调用 parse 函数解析 </li><li>然后获取下一页的文章 url，按照1 2 循环</li></ol><p>对于 parse 函数，一般做三种事情:<br>a. 解析返回的数据 response data<br>b. 提取数据，生成 ITEM<br>c. 生成需要进一步处理 URL 的 Request 对象 </p><blockquote><p>某些网站中，url 仅仅只是一个后缀，需要将当前页面的url+后缀进行拼接，使用的是 parse.urljoin(base, url)，如果 urljoin 中的 url 没有域名，将使用base进行拼接，如果有域名，将不会进行拼接,此函数在 python3 的 urllib 库中。Request(meta参数)：meta参数是一个字典{},作为回调函数的参数</p></blockquote><p>这样，我们就获得了所有的文章</p><p><strong>扩展二：使用item，并保存图片到本地</strong><br>上一小节提到了， parse 函数提取数据之后，生成 item，scrapy 会通过 http 将 item 传到 pipeline 进行处理，那么这一小节，我们使用 item 来接收 parse 提取的数据。在 items.py 文件中，定义一个我们自己的数据类 JobBoleArticleItem，并继承 scrapy.item 类</p><pre><code>class JobBoleArticleItem(scrapy.Item):    title = scrapy.Field()          # Field()能够接收和传递任何类型的值,类似于字典的形式    create_date = scrapy.Field()    # 创建时间    url = scrapy.Field()            # 文章路径    front_img_url_download = scrapy.Field()    fav_nums = scrapy.Field()       # 收藏数    comment_nums = scrapy.Field()   # 评论数    vote_nums = scrapy.Field()      # 点赞数    tags = scrapy.Field()           # 标签分类 label    content = scrapy.Field()        # 文章内容    object_id = scrapy.Field()      # 文章内容的md5的哈希值，能够将长度不定的 url 转换成定长的序列</code></pre><p>Field() 对象，能够接收和传递任何类型的值，看源代码，就能发现，Field() 类继承自 dict 对象，具有字典的所有属性。</p><p>注意，在上面定义的类中，我们增加了一个新的成员变量 <code>front_img_url_download</code>，这是保存的是文章列表中，每一个文章的图片链接。我们需要将这个图片下载到本地环境中。既然使用了 item 接收我们提取的数据，那么 parse 函数就需要做相应的改动</p><pre><code>def parse(self, response):    post_nodes = response.css(&quot;#archive .floated-thumb .post-thumb&quot;)    # a selector, 可以在这个基础上继续做 selector    for post_node in post_nodes:        post_url = post_node.css(&quot;a::attr(href)&quot;).extract_first(&quot;&quot;)        img_url = post_node.css(&quot;a img::attr(src)&quot;).extract_first(&quot;&quot;)        yield Request(url=parse.urljoin(response.url, post_url),                      meta={&quot;front-image-url&quot;:img_url}, callback=self.parse_detail)    # 必须考虑到有前一页，当前页和下一页链接的影响，使用如下所示的方法    next_url = response.css(&quot;span.page-numbers.current+a::attr(href)&quot;).extract_first(&quot;&quot;)     if next_url:         yield Request(url=parse.urljoin(response.url, next_url), callback=self.parse)</code></pre><p>同时，解析函数 <code>parse_detail</code> 也需要修改，将数据保存到我们的item中，只需要添加下面的部分就可</p><pre><code>front_img_url = response.meta.get(&quot;front-image-url&quot;, &quot;&quot;)article_item = JobBoleArticleItem() # 实例化 item 对象# 赋值 item 对象article_item[&quot;title&quot;] = titlearticle_item[&quot;create_date&quot;] = create_datearticle_item[&quot;url&quot;] = response.urlarticle_item[&quot;front_img_url_download&quot;] = [front_img_url] # 这里传递的需要是列表的形式，否则后面保存图片的时候，会出现类型错误，必须是可迭代对象article_item[&quot;fav_nums&quot;] = fav_numsarticle_item[&quot;comment_nums&quot;] = comment_numsarticle_item[&quot;vote_nums&quot;] = vote_numsarticle_item[&quot;tags&quot;] = tags# article_item[&quot;cpyrights&quot;] = cpyrightsarticle_item[&quot;content&quot;] = &apos;&apos;.join(content)      # 取出的 content 是一个 list ,存入数据库的时候，需要转换成字符串article_item[&quot;object_id&quot;] = gen_md5(response.url)yield article_item</code></pre><p>这里，parse 函数成功生成了我们定义的 item 对象，将数据传递到 pipeline。那么，图片链接已经获取到了，我们如下将图片下载下来呢。</p><blockquote><p>解释一下上面代码中的 front-img-url，这个是在 parse 函数中作为参数 meta 传递给 Request() 函数，回调函数调用 <code>parse_detail</code>，返回的 response 对象中的 meta 成员，将包含这个元素， meta 就是一个字典， <code>response.meta.get(&quot;front-image-url&quot;)</code> 将获取到我们传递过来的图片url</p></blockquote><p>scrapy 提供了一个 ImagesPipeline 类，可直接用于图片操作，只需要我们在 settings.py 文件中进行配置即可。</p><p>在 settings.py 中，有一个配置参数为 <code>ITEM_PIPELINE</code>，这其实就是一个字典，当需要用到 pipeline 时，就需要在这个字典中进行配置，字典中存在的， scrapy 才会使用。字典中的 key 就是 pipeline 的类名，后面的数字表示优先级，数字越小表示越先调用，越大越靠后。既然我们现在需要使用到 scrapy 提供的图片下载功能，那么需要在这个字典中配置 ImagesPipeline</p><pre><code>ITEM_PIPELINES = {   &apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1,}</code></pre><p>同时，还需要在 settings.py 中配置，item 中哪一个字段是图片 url，以及图片需要存放什么位置</p><pre><code>IMAGES_URLS_FIELD = &quot;front_img_url_download&quot; # ITEM 中的图片 URL，用于下载PROJECT_IMAGE_PATH = os.path.abspath(os.path.dirname(__file__))   # 获取当前文件所在目录IMAGES_STORE = os.path.join(PROJECT_IMAGE_PATH, &quot;images&quot;) # 下载图片的保存位置</code></pre><p>这些参数，可以在 ImagesPipeline 类的源代码中查看到</p><blockquote><p>注意：上面配置好后，上面的代码是在工程路径下面创建一个 images 的目录，用于保存图片，运行 main.py，可能会出现如下错误: no module named PIL，这是因为图片操作需要 pillow 库，只需要安装即可<br>pip install pillow，快速安装，就按照我上面说的豆瓣源的方法。<br>还可能出现”ValueError: Missing scheme in request url: h”的错误，这是因为图片操作，要求 <code>front_img_url_download</code> 的值为 list 或者可以迭代的对象，所以我们在 parse 函数中给 item 赋值的时候， <code>front_img_url_download</code> 就是赋值的 list 对象</p></blockquote><p>好了，这些注意了之后，应该能够下载图片了。</p><p><strong>扩展三：使用 itemloader</strong><br>相信大家已经发现，虽然使用了 item，但是使用 css selecotor，我们的 parse 函数显得很长，而且，当数据量越来越大之后，一大堆的 css 表达式是很难维护的。在加上正则表达式的提取，代码会显得很臃肿。这里，给大家推荐是用 itemloader。itemloader 可以看成是一个容器。</p><p>首先，在 items.py 中，我们需要定义一个继承自 ItemLoader 的类</p><pre><code>class ArticleItemLoader(ItemLoader):    &quot;&quot;&quot;    自定义 ItemLoader, 就相当于一个容器    &quot;&quot;&quot;    # 这里表示，输出获取的 ArticleItemLoader 提取到的值，都是 list 中的第一个值    # 如果有的默认不是取第一个值，就在 Field() 中进行修改    default_output_processor = TakeFirst()</code></pre><p>将默认输出函数定为 <code>TakeFirst()</code>，即取结果 list 中的第一个值，定义了 ItemLoader 类之后，需要修改 jobbole.py 中的 <code>parse_detail</code> 函数了，现在就不再直接使用 css selector 了，使用 itemloader 中的 css 进行数据提取，新的 <code>parse_detail</code> 如下所示：</p><pre><code>def parse_detail(self, response):    front_img_url = response.meta.get(&quot;front-image-url&quot;, &quot;&quot;)    item_loader = ArticleItemLoader(item=JobBoleArticleItem(), response=response)    article_item_loader = JobBoleArticleItem()    item_loader.add_css(&quot;title&quot;, &quot;.entry-header h1::text&quot;)  # 通过 css 选择器获取值    item_loader.add_value(&quot;url&quot;, response.url)    item_loader.add_css(&quot;create_date&quot;, &quot;.entry-meta-hide-on-mobile::text&quot;)    item_loader.add_value(&quot;front_img_url_download&quot;, [front_img_url])    item_loader.add_css(&quot;fav_nums&quot;, &quot;.bookmark-btn::text&quot;)    item_loader.add_css(&quot;comment_nums&quot;, &quot;a[href=&apos;#article-comment&apos;] span::text&quot;)    item_loader.add_css(&quot;vote_nums&quot;, &quot;.vote-post-up h10::text&quot;)    item_loader.add_css(&quot;tags&quot;, &quot;.entry-meta-hide-on-mobile a::text&quot;)    item_loader.add_css(&quot;content&quot;, &quot;.entry *::text&quot;)    item_loader.add_value(&quot;object_id&quot;, gen_md5(response.url))    # item_loader.add_xpath()    # item_loader.add_value()    article_item_loader = item_loader.load_item()    yield article_item_loader</code></pre><p>这样，数据提取就全部交给了 <code>item_loader</code> 来执行了。代码整体都简洁和工整了很多。ItemLoader 有三个方法用于提取数据，分别是 <code>add_css()</code>, <code>add_xpath()</code>, <code>add_value()</code>，前两个分别是 css 选择器和 xpath 选择器，如果是值，就直接使用 <code>add_value()</code> 即可。</p><p>最后 <code>load_item()</code> 函数，将根据上面提供的规则进行数据解析，每一个解析的值都是以 list 结果的形式呈现，同时，将结果赋值 item。</p><p>但是，大家应该已经发现，之前我们直接使用 css selector 提取数据的时候，对于某些数据，需要使用正则表达式进行匹配才能获取所需的值，这里什么都没做，仅仅是通过 itemloader 提取了数据而已。所以，我们还需要重新定义我们的 item 类，这些操作在 item 中进行处理。修改 items.py 中的 JobBoleArticleItem 类，具体如下：</p><pre><code>class JobBoleArticleItem(scrapy.item):    title = scrapy.Field()    create_date = scrapy.Field(     # 创建时间        input_processor = MapCompose(get_date),        output_processor = Join(&quot;&quot;)    )    url = scrapy.Field()            # 文章路径    front_img_url_download = scrapy.Field(    # 文章封面图片路径,用于下载，赋值时必须为数组形式        # 默认 output_processor 是 TakeFirst()，这样返回的是一个字符串，不是 list，此处必须是 list        # 修改 output_processor        output_processor = MapCompose(return_value)    )    front_img_url = scrapy.Field()    fav_nums = scrapy.Field(        # 收藏数        input_processor=MapCompose(get_nums)    )    comment_nums = scrapy.Field(    # 评论数        input_processor=MapCompose(get_nums)    )    vote_nums = scrapy.Field(       # 点赞数        input_processor=MapCompose(get_nums)    )    tags = scrapy.Field(           # 标签分类 label        # 本身就是一个list, 输出时，将 list 以 commas 逗号连接        input_processor = MapCompose(remove_comment_tag),        output_processor = Join(&quot;,&quot;)    )    content = scrapy.Field(        # 文章内容        # content 我们不是取最后一个，是全部都要，所以不用 TakeFirst()        output_processor=Join(&quot;&quot;)    )    object_id = scrapy.Field()      # 文章内容的md5的哈希值，能够将长度不定的 url 转换成定长的序列</code></pre><p><code>input_processor</code> 对传入的值进行预处理， <code>output_processor</code> 对处理后的值按照规则进行处理和提取，比如 TakeFirst() 就是对处理的结果取第一个值。</p><p><code>input_processor = MapCompose(func1, func2, func3, ...)</code> 这行代码，说明的是， Item 传入的这个字段的值，将会分别调用 MapCompose 中的所有传入的方法进行逐个处理，这个方法也是可以是 lambda 的匿名函数。</p><p>因为上面定义 ArticleItemLoader 类的时候，使用了默认的 <code>default_output_processor</code>，如果不想使用默认的这个方法，就在 Field() 中，使用 <code>output_processor</code> 参数覆盖默认的方法，哪怕什么都不做，也不会使用默认方法获取数据了。对上面那些方法定义如下：</p><pre><code>def get_nums(value):    &quot;&quot;&quot;    通过正则表达式获取 评论数，点赞数和收藏数    &quot;&quot;&quot;    re_match = re.match(&quot;.*?(\d+).*&quot;, value)    if re_match:        nums = (int)(re_match.group(1))    else:        nums = 0    return numsdef get_date(value):    re_match = re.match(&quot;([0-9/]*).*?&quot;, value.strip())    if re_match:        create_date = re_match.group(1)    else:        create_date = &quot;&quot;    return create_datedef remove_comment_tag(value):    &quot;&quot;&quot;    去掉 tag 中的 “评论” 标签    &quot;&quot;&quot;    if &quot;评论&quot; in value:        return &quot;&quot;    else:        return valuedef return_value(value):    &quot;&quot;&quot;    do nothing, 只是为了覆盖 ItemLoader 中的 default_processor    &quot;&quot;&quot;    return value</code></pre><blockquote><p>千万注意：这些方法，每一个最后，都必须有 return，否则程序到后面将获取不到这个字段的数据，再次访问这个字段的时候，就会报错。</p></blockquote><p><strong>扩展四：将数据导出到 json 文件中</strong><br>好了，既然已经将数据通过 ItemLoader 获取到了，那么我们现在就将数据从 pipeline 输出到 json 文件中。<br>将数据以 json 格式输出，可以通过 json 库的方法，也可以使用 scrapy.exporters 的方法。</p><p><strong>json 库</strong><br>我们已经知道，对数据的处理，scrapy 是在 pipeline 中进行的，所以，我们需要在 pipelines.py 中定义我们对数据的导出操作。创建一个新类</p><pre><code>class JsonWithEncodingPipeline(object):    &quot;&quot;&quot;    处理 item 数据，保存为json格式的文件中    &quot;&quot;&quot;    def __init__(self):        self.file = codecs.open(&apos;article.json&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;)    def process_item(self, item, spider):        lines = json.dumps(dict(item), ensure_ascii=False) + &apos;\n&apos;   # False，才能够在处理非acsii编码的时候，不会出错，尤其        #中文        self.file.write(lines)        return item     # 必须 return    def spider_close(self, spider):        &quot;&quot;&quot;        把文件关闭        &quot;&quot;&quot;        self.file.close()</code></pre><p><code>__init__()</code> 构造对象的时候，就打开文件，scrapy 会调用 process_item() 函数对数据进行处理，在这个函数中，将数据以 json 的格式写入文件中。操作完成之后，将文件关闭。思路很简单。</p><p><strong>scrapy.exporters 的方式</strong>  </p><pre><code>class JsonExporterPipeline(object):    def __init__(self):        &quot;&quot;&quot;        先打开文件，传递一个文件        &quot;&quot;&quot;        self.file = open(&apos;articleexporter.json&apos;, &apos;wb&apos;)        #调用 scrapy 提供的 JsonItemExporter导出json文件        self.exporter = JsonItemExporter(self.file, encoding=&quot;utf-8&quot;, ensure_ascii=False)        self.exporter.start_exporting()    def spider_close(self, spider):        self.exporter.finish_exporting()        self.file.close()    def process_item(self, item, spider):        self.exporter.export_item(item)        return item</code></pre><p>scrapy.exporters 提供了几种不同格式的文件支持，能够将数据输出到这些不同格式的文件中，查看 JsonItemExporter 源码即可获知</p><pre><code>__all__ = [&apos;BaseItemExporter&apos;, &apos;PprintItemExporter&apos;, &apos;PickleItemExporter&apos;,           &apos;CsvItemExporter&apos;, &apos;XmlItemExporter&apos;, &apos;JsonLinesItemExporter&apos;,           &apos;JsonItemExporter&apos;, &apos;MarshalItemExporter&apos;]</code></pre><p>这些就是 scrapy 支持的文件。方法名称都差不多，这算是 scrapy 运行 pipeline 的模式，只需要将逻辑处理放在 process_item()，scrapy 就会根据规则对数据进行处理。</p><p>当然，要想使我们写的数据操作有效，别忘记了，在 settings.py 中进行配置</p><pre><code>ITEM_PIPELINES = {  &apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1,  &apos;ArticleSpider.pipelines.JsonWithEncodingPipeline&apos;: 2,  &apos;ArticleSpider.pipelines.JsonExporterPipeline&apos;:3,}</code></pre><p><strong>扩展五：将数据存储到 MySQL 数据库</strong><br>前面介绍了将数据以 json 格式导出到文件，那么将数据保存到 MySQL 中，如何操作，相信大家已经差不多了然于胸了。这里也介绍两种方法，一种是通过 MySQLdb 的API来实现的数据库存取操作，这种方法简单，适合用与数据量不大的场合，如果数据量大，数据库操作的速度跟不上数据解析的速度，就会造成数据拥堵。那么使用第二种方法就更好，使用 twisted 框架提供的异步操作方法，不会造成拥堵，速度更快。</p><p>既然是入 MySQL 数据库，首先肯定是需要创建数据库表了。表结构如下图所示：<br><img src="https://img-blog.csdn.net/20170709212315810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uZ2xpY3UxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>上图中有一个字段的值，我没有讲述怎么取，就是 <code>front_img_path</code> 这个值，大家在数据库入库的时候，直接用空置或者空字符串填充即可。这个字段是保存图片在本地保存的路径，这个需要在 ImagesPipe 的 <code>item_completed(self, results, item, info)</code> 方法中的 results 参数中获取。</p><p>好了，数据库表创建成功之后，下面就来将数据入库了。</p><p><strong>MySQLdb 的方法入库</strong>  </p><pre><code>class MysqlPipeline(object):    def __init__(self):        # 连接数据库        self.conn = MySQLdb.connect(&apos;192.168.0.101&apos;, &apos;spider&apos;, &apos;wuzhenyu&apos;, &apos;article_spider&apos;, charset=&quot;utf8&quot;, use_unicode=True)        self.cursor = self.conn.cursor()    def process_item(self, item, spider):        insert_sql = &quot;&quot;&quot;            insert into article(title, create_date, url, url_object_id, front_img_url, front_img_path, comment_nums,             fav_nums, vote_nums, tags, content) VALUES (&apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;, %d, %d, %d, &apos;%s&apos;, &apos;%s&apos;)        &quot;&quot;&quot; % (item[&quot;title&quot;], item[&quot;create_date&quot;], item[&quot;url&quot;], item[&quot;object_id&quot;],item[&quot;front_img_url&quot;],               item[&quot;front_img_path&quot;], item[&quot;comment_nums&quot;], item[&quot;fav_nums&quot;], item[&quot;vote_nums&quot;], item[&quot;tags&quot;],               item[&quot;content&quot;])        self.cursor.execute(insert_sql)        self.conn.commit()    def spider_close(self, spider):        self.cursor.close()        self.conn.close()</code></pre><p>如果对 API 想了解的更多，就去阅读 python MySQLdb 的相关API文档说明，当然，要想这个生效，首先得在 settings.py 文件中将这个 pipeline 类加入 ITEM_PIPELINE 字典中</p><pre><code>ITEM_PIPELINES = {  &apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1,  &apos;ArticleSpider.pipelines.JsonWithEncodingPipeline&apos;: 2,  &apos;ArticleSpider.pipelines.JsonExporterPipeline&apos;:3,  &apos;ArticleSpider.pipelines.MysqlPipeline&apos;: 4,}</code></pre><p><strong>通过 Twisted 框架提供的异步方法入库</strong>  </p><pre><code>class MysqlTwistedPipeline(object):    &quot;&quot;&quot;    利用 Twisted API 实现异步入库 MySQL 的功能    Twisted 提供的是一个异步的容器，MySQL 的操作还是使用的MySQLDB 的库    &quot;&quot;&quot;    def __init__(self, dbpool):        self.dbpool = dbpool    @classmethod    def from_settings(cls, settings):        &quot;&quot;&quot;        被 spider 调用，将 settings.py 传递进来，读取我们配置的参数        模仿 images.py 源代码中的 from_settings 函数的写法        &quot;&quot;&quot;        # 字典中的参数，要与 MySQLdb 中的connect 的参数相同        dbparams = dict(            host = settings[&quot;MYSQL_HOST&quot;],            db = settings[&quot;MYSQL_DBNAME&quot;],            user = settings[&quot;MYSQL_USER&quot;],            passwd = settings[&quot;MYSQL_PASSWORD&quot;],            charset = &quot;utf8&quot;,            cursorclass = MySQLdb.cursors.DictCursor,            use_unicode = True        )        # twisted 中的 adbapi 能够将sql操作转变成异步操作        dbpool = adbapi.ConnectionPool(&quot;MySQLdb&quot;, **dbparams)        return cls(dbpool)    def process_item(self, item, spider):        &quot;&quot;&quot;        使用 twisted 将 mysql 操作编程异步执行        &quot;&quot;&quot;        query = self.dbpool.runInteraction(self.do_insert, item)        query.addErrback(self.handle_error) # handle exceptions    def handle_error(self, failure):        &quot;&quot;&quot;        处理异步操作的异常        &quot;&quot;&quot;        print(failure)    def do_insert(self, cursor, item):        &quot;&quot;&quot;        执行具体的操作，能够自动 commit        &quot;&quot;&quot;        print(item[&quot;create_date&quot;])        insert_sql = &quot;&quot;&quot;                    insert into article(title, create_date, url, url_object_id, front_img_url, front_img_path, comment_nums,                     fav_nums, vote_nums, tags, content) VALUES (&apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;, %d, %d, %d, &apos;%s&apos;, &apos;%s&apos;);                &quot;&quot;&quot; % (item[&quot;title&quot;], item[&quot;create_date&quot;], item[&quot;url&quot;], item[&quot;object_id&quot;], item[&quot;front_img_url&quot;],                       item[&quot;front_img_path&quot;], item[&quot;comment_nums&quot;], item[&quot;fav_nums&quot;], item[&quot;vote_nums&quot;], item[&quot;tags&quot;],                       item[&quot;content&quot;])        # self.cursor.execute(insert_sql, (item[&quot;title&quot;], item[&quot;create_date&quot;], item[&quot;url&quot;], item[&quot;object_id&quot;],        #                                 item[&quot;front_img_url&quot;], item[&quot;front_img_path&quot;], item[&quot;comment_nums&quot;],        #                                 item[&quot;fav_nums&quot;], item[&quot;vote_nums&quot;], item[&quot;tags&quot;], item[&quot;content&quot;]))        print(insert_sql)        cursor.execute(insert_sql)</code></pre><p>需要提到的是，上面定义的 <code>from_settings(cls. settings)</code> 这个类方法， scrapy 会从 settings.py<br>文件中读取配置进行加载，这里将 MySQL 的一些配置信息放在了 settings.py 文件中，然后使用 <code>from_settings</code> 方法直接获取，在 settings.py 中需要添加如下代码：</p><pre><code># MySQL paramsMYSQL_HOST = &quot;&quot;MYSQL_DBNAME = &quot;article_spider&quot;MYSQL_USER = &quot;spider&quot;MYSQL_PASSWORD = &quot;&quot;</code></pre><p>本篇文章，主要以 scrapy 框架爬取伯乐在线文章为例，简要介绍了 scrapy 爬取数据的一些方法，博主也是最近才开始学习爬虫，有不对的地方还请大家能够指正。</p><p>windows 中安装环境与 Ubuntu 会有一些不一样，而且如果使用的是 python3.x 版本，会要求 vc++ 的版本比较高，最好安装的是 visual studio 2015 以上的版本。否则会很麻烦。</p><p>对于 python2.7版本，在windows中，可以安装 VSForPython27.msi ，依赖的那些库应该就不会再出错了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;scrapy 是一个用 python 语言编写的，为了爬取网站数据，提取结构性数据而编写的应用框架。&lt;/p&gt;
&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;p&gt;本文使用的环境：&lt;br&gt;
      
    
    </summary>
    
      <category term="scrapy" scheme="http://gnbyj.cn/categories/scrapy/"/>
    
    
      <category term="python scrapy" scheme="http://gnbyj.cn/tags/python-scrapy/"/>
    
  </entry>
  
  <entry>
    <title>装修最容易犯的错误有哪些？</title>
    <link href="http://gnbyj.cn/2018/05/15/%E5%AE%B6%E8%A3%85/%E5%AE%B6%E8%A3%85%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://gnbyj.cn/2018/05/15/家装/家装注意点/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-05-15T02:00:28.565Z</updated>
    
    <content type="html"><![CDATA[<p>1、图便宜到路边随便拎个工人就开工，事后保修自负后果。</p><p>2、图便宜选了家报价最低的，58888 家电全包，结果发现大多数主要项目都没包。</p><p>3、“设计要钱吗？”、“需要呢，每平 60 元起……”、“别的装修公司设计都免费，你家不光收费还收这么贵”，否定设计价值，否认设计师在装修过程中重要作用。</p><p>4、盲目追求环保，大理石有辐射，材料要 0 甲醛，最后被销售忽悠住带进坑。</p><p>5、没有明确需求，对装修完全懵逼。这种状态不乐观，遇上良心的公司好说，遇上不良的分分钟被坑且让你后知后觉毫无压力。所以用碎片时间做好预算、需求、功课的准备，十分建议。</p><p>6、装修合同不仔细审，模糊项不追根究底，口头承诺，将埋下隐患种子。</p><p>7、对展厅大、广告打得火热的传统装修、全国连锁的装修公司蜜汁自信，多关注新闻，跑路倒闭的都是玩大过火的。装修市场的未来还要靠小而美的装修公司，装修公司选对太太太太重要了。</p><p>8、看材料只认品牌，不关注具体型号。</p><p>9、装修过程中发现设计师没想法合作起来效率低，可以及时更换。</p><p>10、装修期间，省下误工费跑工地的车费，完全可以请个第三方独立监理，省心不是一星半点。</p><p>11、给熟人装修和请熟人装修，一旦出事，双方都很尴尬。</p><p>12、装修容易漏掉故意做增项的地方：</p><p><a href="https://www.zhihu.com/question/39516219/answer/347045581" target="_blank" rel="noopener">设计师猫姐：怎样看装修报价清单有没有漏项呢？</a></p><p><a href="https://www.zhihu.com/question/43644568/answer/360718462" target="_blank" rel="noopener">设计师猫姐：我们该如何避免装修过程中的费用增项呢？</a></p><p>13、如果不是大艺术家对设计执着追求，硬装设计上尽量少造型，吊顶不是必选项，收纳空间适可而止。</p><p>14、卫生间能干湿分离就干湿分离，尤其是家里有老人小孩的。</p><p>15、厨房吊柜地柜根据人体比例做合适。</p><p>16、开放式厨房没好坏，只有适不适合。</p><p>17、台上盆好看但难清理，密封玻璃胶要选好不然发霉难处理。</p><p>18、衣柜尽量避开 钢化玻璃 + 移门，易脏密封性一般。</p><p>19、电视柜绕开深色 + 钢化玻璃，积尘易见，尤其是家里养宠物。</p><p>20、地板不用非往实木堆里扎，现在的强化和复合地板都不错，造价低易维护。</p><p>21、卫生间洗手台别选大锐角，容易磕碰到身体。</p><p>22、五金挂件一定要选好。</p><p>23、厨房砖，哑光砖慎选，油点难擦。</p><p>24、地漏一定要防臭防生锈。</p><p>25、吊顶选轻钢龙骨不易变形、厨卫用铝扣板吊顶易维护。</p><p>26、卫生间回填用碳渣回填，防水是重中之重，卫生间防水 2 遍，48 小时闭水试验，生活阳台地面防水 1 层，厨房地面防水 1 层，墙面上翻 30 公分。</p><p>27、电地暖相较于水地暖好维护维护成本低。</p><p>28、“轻装修，重装饰”的说法在某种程度上其实是错误的，硬装设计没做好规划，后期软装会变成纯粹的家具摆放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、图便宜到路边随便拎个工人就开工，事后保修自负后果。&lt;/p&gt;
&lt;p&gt;2、图便宜选了家报价最低的，58888 家电全包，结果发现大多数主要项目都没包。&lt;/p&gt;
&lt;p&gt;3、“设计要钱吗？”、“需要呢，每平 60 元起……”、“别的装修公司设计都免费，你家不光收费还收这么贵”，
      
    
    </summary>
    
      <category term="生活实用" scheme="http://gnbyj.cn/categories/%E7%94%9F%E6%B4%BB%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="家装 生活" scheme="http://gnbyj.cn/tags/%E5%AE%B6%E8%A3%85-%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Python 3 知识点</title>
    <link href="http://gnbyj.cn/2018/05/13/Python/Python3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://gnbyj.cn/2018/05/13/Python/Python3知识点/</id>
    <published>2018-05-12T16:34:55.000Z</published>
    <updated>2018-07-25T04:11:12.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看python版本"><a href="#查看python版本" class="headerlink" title="查看python版本"></a>查看python版本</h3><pre><code>python -V</code></pre><hr><h3 id="“Hello-World-”"><a href="#“Hello-World-”" class="headerlink" title="“Hello World!”"></a>“Hello World!”</h3><pre><code>#!/usr/bin/python3print(&quot;Hello, World!&quot;);</code></pre><hr><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><pre><code># -*- coding: cp-1252 -*-# -*- coding: utf-8 -*-</code></pre><hr><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>第一个字符必须是字母表中字母或下划线 _ 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li></ul><hr><h3 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h3><p>保留字即关键字，我们不能把它们用作任何标识符名称。<br><code>import keyword  #keyword 模块</code><br><code>keyword.kwlist</code></p><hr><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释以 # 开头</li><li>多行注释可以用多个 # 号，还有 ‘’’ 和 “””  </li></ul><p>在 Windows 下可以不写第一行注释：<br><code>#!/usr/bin/python3</code><br>第一行注释标的是指向 python 的路径，告诉操作系统执行这个脚本的时候，调用 /usr/bin 下的 python 解释器。<br>此外还有以下形式（推荐写法）：<br><code>#!/usr/bin/env python3</code><br>这种用法先在 env（环境变量）设置里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作。</p><hr><h3 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h3><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。<br>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。缩进不一致，会导致运行错误。</p><hr><h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h3><p>使用反斜杠()来实现多行语句<br>    total = item_one + \<br>    item_two + \<br>    item_three</p><hr><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>记住：空行也是程序代码的一部分。<br>空行的作用<em>在于分隔两段不同功能或含义的代码</em>，便于日后代码的维护或重构。</p><hr><h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><pre><code>input(&quot;\n\n按下 enter 键后退出。&quot;)</code></pre><hr><h3 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h3><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割</p><hr><h3 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h3><p>缩进相同的一组语句构成一个代码块，我们称之代码组。<br>我们将首行及后面的代码组称为一个子句(clause)。</p><hr><h3 id="Print-输出"><a href="#Print-输出" class="headerlink" title="Print 输出"></a>Print 输出</h3><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=””<br><code>print( x, end=&quot; &quot; )</code></p><hr><h3 id="导入模块…"><a href="#导入模块…" class="headerlink" title="导入模块…"></a>导入模块…</h3><ul><li>在 python 用 import 或者 from…import 来导入相应的模块。  </li><li>将整个模块(somemodule)导入，格式为： import somemodule  </li><li>从某个模块中导入某个函数,格式为： from somemodule import somefunction  </li><li>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc  </li><li>将某个模块中的全部函数导入，格式为： from somemodule import *  </li></ul><hr><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>Python可以使用-h参数查看各参数帮助信息<br><code>python -h</code><br>如下实例，查看 max 内置函数的参数列表和规范的文档<br><code>help(max)</code></p><hr><h3 id="数据类型（基本）"><a href="#数据类型（基本）" class="headerlink" title="数据类型（基本）"></a>数据类型（基本）</h3><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。<br>等号（=）用来给变量赋值。<br>Python允许你同时为多个变量赋值，三个变量都指向同一个内存位置：<br><code>a = b = c = 1</code><br><code>a, b, c = 1, 2, &quot;dog&quot;</code></p><hr><h3 id="6种标准数据类型"><a href="#6种标准数据类型" class="headerlink" title="6种标准数据类型"></a>6种标准数据类型</h3><ul><li>不可变数据（四个）：<br>Number（数字）<br>String（字符串）<br>Tuple（元组）<br>Sets（集合）  </li><li>可变数据（两个）：<br>List（列表）<br>Dictionary（字典）  </li></ul><hr><h3 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h3><ul><li>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li>bool (布尔), 如 True。</li><li>float (浮点数), 如 1.23、3E-2</li><li>complex (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><hr><h3 id="type-与isinstance"><a href="#type-与isinstance" class="headerlink" title="type()与isinstance()"></a>type()与isinstance()</h3><p>例子：<br><code>print(type(a), type(b), type(c), type(d))</code><br><code>isinstance(a, int)</code><br>区别就是:<br>type()不会认为子类是一种父类类型。<br>isinstance()会认为子类是一种父类类型。</p><hr><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p>del语句删除一些对象引用<br><code>del var1[,var2[,var3[....,varN]]]]</code></p><hr><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><pre><code>5 + 4  # 加法94.3 - 2 # 减法2.33 * 7  # 乘法212 / 4  # 除法，得到一个浮点数0.52 // 4 # 除法，得到一个整数017 % 3 # 取余 22 ** 5 # 乘方32</code></pre><p>在混合计算时，Python会把整型转换成为浮点数；<br>复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型；</p><hr><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li>python中单引号和双引号使用完全相同。</li><li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li><li>转义符 ‘\’</li><li>反斜杠可以用来转义，<em>使用r可以让反斜杠不发生转义</em>。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li><li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量[头下标:尾下标]，<em>含头不含尾，负值表示从右往左计</em>。</li></ul><hr><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改，但它可以包含可变的对象，比如list列表。<br>元组写在小括号 () 里，元素之间用逗号隔开。<br><code>tup[1:5] = (2, 3, 4, 5)</code></p><hr><h3 id="空元组和单元组"><a href="#空元组和单元组" class="headerlink" title="空元组和单元组"></a>空元组和单元组</h3><p>构造包含 0 个或 1 个元素的元组比较特殊：<br><code>tup1 = ()  # 空元组</code><br><code>tup2 = (20,) # 一个元素，需要在元素后添加逗号</code></p><hr><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>string、list和tuple都属于sequence（序列）。</p><hr><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>集合（set）是一个<strong>无序不重复元素</strong>的序列。<br>基本功能是进行成员关系测试和删除重复元素。<br>可以使用大括号 { } 或者 set() 函数创建集合<br>注意：<em>创建一个空集合必须用 set()</em> 而不是 { }，因为 { } 是用来创建一个空字典。</p><hr><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>列表是写在方括号([])之间、用逗号分隔开的元素列表。<br>列表也可以被索引和切片（得到一个新列表）。<br>列表中的元素是可以改变的。<br><code>a[2:5] = [13, 14, 15]</code></p><hr><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>列表是有序的对象集合，字典是无序的对象集合。<br>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。<br>字典是一种映射类型，字典用”{ }”标识，它是一个无序的<strong>键(key) : 值(value)</strong>对集合。键(key)必须使用不可变类型。<br><code>dict = {&#39;name&#39;: &#39;baidu&#39;,&#39;code&#39;:1, &#39;site&#39;: &#39;www.baidu.com&#39;}</code><br>构造函数：<br><code>dict([(&#39;first&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])</code></p><hr><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><pre><code>int(x [,base])    将x转换为一个整数float(x)    将x转换到一个浮点数complex(real [,imag])    创建一个复数str(x)    将对象 x 转换为字符串repr(x)    将对象 x 转换为表达式字符串eval(str)    用来计算在字符串中的有效Python表达式,并返回一个对象tuple(s)       将序列 s 转换为一个元组list(s)    将序列 s 转换为一个列表set(s)    转换为可变集合dict(d)        创建一个字典。d 必须是一个序列 (key,value)元组。frozenset(s)        转换为不可变集合chr(x)    将一个整数转换为一个字符ord(x)        将一个字符转换为它的整数值hex(x)        将一个整数转换为一个十六进制字符串oct(x)        将一个整数转换为一个八进制字符串</code></pre><hr><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><pre><code>**            指数 (最高优先级)~ + -        按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)* / % //    乘，除，取模和取整除+ -            加法减法&gt;&gt; &lt;&lt;        右移，左移运算符&amp;            位 &apos;AND&apos;^ |            位运算符&lt;= &lt; &gt; &gt;=    比较运算符&lt;&gt; == !=    等于运算符= %= /= //= -= += *= **=        赋值运算符is is not    身份运算符in not in    成员运算符and or not    逻辑运算符</code></pre><hr><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p><strong>abs(x)</strong>        返回数字的绝对值，如abs(-10) 返回 10<br><strong>ceil(x)</strong>        返回数字的上入整数，如math.ceil(4.1) 返回 5<br><strong>cmp(x, y)</strong>     如果 <code>x &lt; y</code> 返回 -1, 如果 <code>x == y</code> 返回 0, 如果 <code>x &gt; y</code> 返回 1。 Python 3 已废弃 。使用 使用 <code>(x&gt;y)-(x&lt;y)</code> 替换。<br><strong>exp(x)</strong>        返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045<br><strong>fabs(x)</strong>        返回数字的绝对值，如math.fabs(-10) 返回10.0<br><strong>floor(x)</strong>    返回数字的下舍整数，如math.floor(4.9)返回 4<br><strong>log(x)</strong>        如math.log(math.e)返回1.0,math.log(100,10)返回2.0<br><strong>log10(x)</strong>    返回以10为基数的x的对数，如math.log10(100)返回 2.0<br><strong>max(x1, x2,…)</strong>        返回给定参数的最大值，参数可以为序列。<br><strong>min(x1, x2,…)</strong>        返回给定参数的最小值，参数可以为序列。<br><strong>modf(x)</strong>        返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。<br><strong>pow(x, y)</strong>    <code>x**y</code> 运算后的值。<br><strong>round(x [,n])</strong>    返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。<br><strong>sqrt(x)</strong>        返回数字x的平方根。</p><hr><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p><strong>choice(seq)</strong>    从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。<br><strong>randrange ([start,] stop [,step])</strong>    从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1<br><strong>random()</strong>    随机生成下一个实数，它在[0,1)范围内。<br><strong>seed([x])</strong>    改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。<br><strong>shuffle(lst)</strong>    将序列的所有元素随机排序<br><strong>uniform(x, y)</strong>    随机生成下一个实数，它在[x,y]范围内。</p><hr><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p><strong>acos(x)</strong>    返回x的反余弦弧度值。<br><strong>asin(x)</strong>    返回x的反正弦弧度值。<br><strong>atan(x)</strong>    返回x的反正切弧度值。<br><strong>atan2(y, x)</strong>    返回给定的 X 及 Y 坐标值的反正切值。<br><strong>cos(x)</strong>    返回x的弧度的余弦值。<br><strong>hypot(x, y)</strong>    返回欧几里德范数 sqrt(x<em>x + y</em>y)。<br><strong>sin(x)</strong>    返回的x弧度的正弦值。<br><strong>tan(x)</strong>    返回x弧度的正切值。<br><strong>degrees(x)</strong>    将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0<br><strong>radians(x)</strong>    将角度转换为弧度</p><hr><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p><code>print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;, 10))</code><br>%s     格式化字符串<br>%d     格式化整数</p><hr><h3 id="字符串内建函数"><a href="#字符串内建函数" class="headerlink" title="字符串内建函数"></a>字符串内建函数</h3><ul><li>capitalize()<br>  符串的第一个字符转换为大写    </li><li>center(width, fillchar)<br>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</li><li>count(str, beg= 0,end=len(string))<br>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</li><li>bytes.decode(encoding=”utf-8”, errors=”strict”)<br>Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</li><li>encode(encoding=’UTF-8’,errors=’strict’)<br>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</li><li>endswith(suffix, beg=0, end=len(string))<br>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</li><li>expandtabs(tabsize=8)<br>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</li><li>find(str, beg=0 end=len(string))<br>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</li><li>index(str, beg=0, end=len(string))<br>跟find()方法一样，只不过如果str不在字符串中会报一个异常.</li><li>isalnum()<br>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False</li><li>isalpha()<br>如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False</li><li>isdigit()<br>如果字符串只包含数字则返回 True 否则返回 False..</li><li>islower()<br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</li><li>isnumeric()<br>如果字符串中只包含数字字符，则返回 True，否则返回 False</li><li>isspace()<br>如果字符串中只包含空白，则返回 True，否则返回 False.</li><li>istitle()<br>如果字符串是标题化的(见 title())则返回 True，否则返回 False</li><li>isupper()<br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</li><li>join(seq)<br>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</li><li>len(string)<br>返回字符串长度</li><li>ljust(width[, fillchar])<br>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</li><li>lower()<br>转换字符串中所有大写字符为小写.</li><li>lstrip()<br>截掉字符串左边的空格或指定字符。</li><li>maketrans()<br>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</li><li>max(str)<br>返回字符串 str 中最大的字母。</li><li>min(str)<br>返回字符串 str 中最小的字母。</li><li>replace(old, new [, max])<br>把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。</li><li>rfind(str, beg=0,end=len(string))<br>类似于 find()函数，不过是从右边开始查找.</li><li>rindex( str, beg=0, end=len(string))<br>类似于 index()，不过是从右边开始.</li><li>rjust(width,[, fillchar])<br>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</li><li>rstrip()<br>删除字符串字符串末尾的空格.</li><li>split(str=””, num=string.count(str))<br>num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串</li><li>splitlines([keepends])<br>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</li><li>startswith(str, beg=0,end=len(string))<br>检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</li><li>strip([chars])<br>在字符串上执行 lstrip()和 rstrip()</li><li>swapcase()<br>将字符串中大写转换为小写，小写转换为大写</li><li>title()<br>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</li><li>translate(table, deletechars=””)<br>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</li><li>upper()<br>转换字符串中的小写字母为大写</li><li>zfill (width)<br>返回长度为 width 的字符串，原字符串右对齐，前面填充0</li><li>isdecimal()<br>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</li></ul><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>len([1, 2, 3]) – 3<br>计算长度</li><li>[1, 2, 3] + [4, 5, 6] – [1, 2, 3, 4, 5, 6]<br>列表组合</li><li>[‘Hi!’] * 4 – [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]<br>重复4次</li><li>3 in [1, 2, 3] – True<br>元素是否存在于列表中</li><li>for x in [1, 2, 3]: print(x, end=” “) – 1 2 3<br>迭代</li></ul><hr><h3 id="列表函数及方法"><a href="#列表函数及方法" class="headerlink" title="列表函数及方法"></a>列表函数及方法</h3><ul><li>函数：<br>len(list)<br>列表元素个数<br>max(list)<br>返回列表元素最大值<br>min(list)<br>返回列表元素最小值<br>list(seq)<br>将元组转换为列表  </li><li>方法：<br>list.append(obj)<br>在列表末尾添加新的对象<br>list.count(obj)<br>统计某个元素在列表中出现的次数<br>list.extend(seq)<br>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）<br>list.index(obj)<br>从列表中找出某个值第一个匹配项的索引位置<br>list.insert(index, obj)<br>将对象插入列表<br>list.pop(obj=list[-1])<br>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值<br>list.remove(obj)<br>移除列表中某个值的第一个匹配项<br>list.reverse()<br>反向列表中元素<br>list.sort([func])<br>对原列表进行排序<br>list.clear()<br>清空列表<br>list.copy()<br>复制列表</li></ul><hr><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul><li>计算元素个数<br>len(tuple)  </li><li>连接<br>tuple1 + tuple2  </li><li>重复<br>tuple * 4  </li><li>元素是否存在<br>item in tuple  </li><li>迭代<br>for x in tuple: do sth.</li></ul><hr><h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><ul><li>len(tuple)  </li><li>max(tuple)  </li><li>min(tuple)  </li><li>tuple(seq)</li></ul><hr><h3 id="字典内置函数"><a href="#字典内置函数" class="headerlink" title="字典内置函数"></a>字典内置函数</h3><ul><li>计算长度<br>len(dict)  </li><li>输出字典，以可打印的字符串表示<br>str(dict)  </li><li>返回输入的变量类型<br>type(variable)</li></ul><hr><h3 id="字典内置方法"><a href="#字典内置方法" class="headerlink" title="字典内置方法"></a>字典内置方法</h3><ul><li>radiansdict.clear()<br>删除字典内所有元素</li><li>radiansdict.copy()<br>返回一个字典的浅复制</li><li>radiansdict.fromkeys()<br>创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</li><li>radiansdict.get(key, default=None)<br>返回指定键的值，如果值不在字典中返回default值</li><li>key in dict<br>如果键在字典dict里返回true，否则返回false</li><li>radiansdict.items()<br>以列表返回可遍历的(键, 值) 元组数组</li><li>radiansdict.keys()<br>以列表返回一个字典所有的键</li><li>radiansdict.setdefault(key, default=None)<br>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</li><li>radiansdict.update(dict2)<br>把字典dict2的键/值对更新到dict里</li><li>radiansdict.values()<br>以列表返回字典中的所有值</li><li>pop(key[,default])<br>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</li><li>popitem()<br>随机返回并删除字典中的一对键和值(一般删除末尾对)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;查看python版本&quot;&gt;&lt;a href=&quot;#查看python版本&quot; class=&quot;headerlink&quot; title=&quot;查看python版本&quot;&gt;&lt;/a&gt;查看python版本&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;python -V
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h
      
    
    </summary>
    
      <category term="python" scheme="http://gnbyj.cn/categories/python/"/>
    
    
      <category term="python" scheme="http://gnbyj.cn/tags/python/"/>
    
  </entry>
  
</feed>
